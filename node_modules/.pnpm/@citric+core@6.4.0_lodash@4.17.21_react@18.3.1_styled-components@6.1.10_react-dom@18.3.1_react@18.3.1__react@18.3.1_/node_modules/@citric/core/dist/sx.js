import { get } from 'lodash';
import { down, up } from './utils/media-queries.js';
import { getFontStyle, getFontWeight } from './utils/theme.js';
const handlerNameRegex = /(Inline|Block|Top|Bottom|Left|Right)/g;
export function handleSxColor(theme, value = '') {
    const key = value.includes('.') ? value : `${value}.500`;
    return get(theme.colorScheme, key) || get(theme.palette, key) || value;
}
export function handleSxSpacing(theme, value = '') {
    const values = value.toString().split(' ');
    return values
        .map((key) => {
        const isNumber = key.match(/^\d+$/);
        return isNumber ? theme.spacing(parseInt(key, 10)) : key;
    })
        .join(' ');
}
export function handleSxRadius(theme, value = '') {
    const values = value.split(' ');
    return values.map((key) => get(theme, `radius.${key}`) || key).join(' ');
}
export function handleSxWidth(_theme, value = '') {
    return typeof value === 'string' ? value : `${(value / 12) * 100}%`;
}
export function handleSxFontWeight(theme, value = '') {
    return getFontWeight(theme, value) || value;
}
export function handleSxContent(theme, value) {
    if (value === undefined) {
        return undefined;
    }
    return value === '' ? '""' : `"${value}"`;
}
export function handleSxFont(theme, value) {
    if (value === undefined) {
        return undefined;
    }
    const final = value.split(' ');
    if (final.length === 1) {
        return getFontStyle(theme, final[0]);
    }
    return value;
}
export function handleSxBorder(theme, value = '') {
    const values = value.replace(/, /g, ',').split(' ');
    if (value === 'none') {
        return 'none';
    }
    if (values.length === 1) {
        return `1px solid ${handleSxColor(theme, values[0])}`;
    }
    if (values.length === 2) {
        return `${values[0]} solid ${handleSxColor(theme, values[1])}`;
    }
    return `${values[0]} ${values[1]} ${handleSxColor(theme, values[2])}`;
}
export function handleSxBoxShadow(theme, value = '') {
    const values = value.split(' ');
    return values.length === 1 ? `0px 0px 0px 2px ${handleSxColor(theme, value)}` : value;
}
const handlers = {
    fill: handleSxColor,
    color: handleSxColor,
    padding: handleSxSpacing,
    margin: handleSxSpacing,
    background: handleSxColor,
    backgroundColor: handleSxColor,
    borderRadius: handleSxRadius,
    border: handleSxBorder,
    borderColor: handleSxColor,
    fontWeight: handleSxFontWeight,
    width: handleSxWidth,
    content: handleSxContent,
    font: handleSxFont,
    boxShadow: handleSxBoxShadow,
};
export const alias = {
    w: 'width',
    m: 'margin',
    mt: 'marginTop',
    mb: 'marginBottom',
    ml: 'marginLeft',
    mr: 'marginRight',
    mx: 'marginInline',
    my: 'marginBlock',
    p: 'padding',
    pt: 'paddingTop',
    pb: 'paddingBottom',
    pl: 'paddingLeft',
    pr: 'paddingRight',
    px: 'paddingInline',
    py: 'paddingBlock',
    bg: 'backgroundColor',
    r: 'borderRadius',
    rtl: 'borderTopLeftRadius',
    rbl: 'borderBottomLeftRadius',
    rtr: 'borderTopRightRadius',
    rbr: 'borderBottomRightRadius',
};
function findHandler(cssProperty) {
    const handlerName = cssProperty.replace(handlerNameRegex, '');
    return handlers[handlerName];
}
function replaceByBreakpointUp(prop, theme) {
    const breakpoint = prop.replace('up(', '').replace(')', '');
    return up(breakpoint)({ theme });
}
function replaceByBreakpointDown(prop, theme) {
    const breakpoint = prop.replace('down(', '').replace(')', '');
    return down(breakpoint)({ theme });
}
function convertSxPropertyToCss(sxProp, theme) {
    if (sxProp.startsWith('down(')) {
        return replaceByBreakpointDown(sxProp, theme);
    }
    if (sxProp.startsWith('up(')) {
        return replaceByBreakpointUp(sxProp, theme);
    }
    return alias[sxProp] || sxProp;
}
const breakpoints = ['md', 'md', 'sm'];
const defaultBreakers = (cssProp) => {
    const defaultBreakersObj = {
        width: 12,
    };
    return defaultBreakersObj[cssProp] || {};
};
export function sx(theme, props = {}) {
    const result = {};
    let prop;
    for (prop in props) {
        const cssProperty = convertSxPropertyToCss(prop, theme);
        const value = props[prop];
        const handler = findHandler(cssProperty);
        if (Array.isArray(value)) {
            for (const index in value) {
                if (index === '0') {
                    result[cssProperty] = handler ? handler(theme, value[index]) : value[index];
                    const breakpoint = down(breakpoints[index])({ theme });
                    const breakpointValue = sx(theme, { [cssProperty]: defaultBreakers(cssProperty) });
                    result[breakpoint] = { ...result[breakpoint], ...breakpointValue };
                }
                else {
                    const breakpoint = down(breakpoints[index])({ theme });
                    const breakpointValue = sx(theme, { [cssProperty]: value[index] });
                    result[breakpoint] = { ...result[breakpoint], ...breakpointValue };
                }
            }
        }
        else if (typeof value === 'object') {
            result[cssProperty] = sx(theme, value);
        }
        else {
            result[cssProperty] = handler ? handler(theme, value) : value;
        }
    }
    return result;
}
//# sourceMappingURL=sx.js.map