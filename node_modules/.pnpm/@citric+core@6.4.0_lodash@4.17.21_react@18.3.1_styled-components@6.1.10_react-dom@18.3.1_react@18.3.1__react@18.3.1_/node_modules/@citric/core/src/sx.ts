
import { Properties, Property, SimplePseudos } from 'csstype'
import { get } from 'lodash'
import { CSSObject, CSSProperties } from 'styled-components'
import {
  OneOfBreakpoints,
  OneOfFontAppearances, OneOfFontWeights, OneOfRadius, Theme,
} from './theme-types'
import { down, up } from './utils/media-queries'
import { getFontStyle, getFontWeight } from './utils/theme'

const handlerNameRegex = /(Inline|Block|Top|Bottom|Left|Right)/g

/**
 * A predefined unit for declaring spaces. Check the table below for a reference in px or rem.
 * 
 * Attention: these values can be overwritten by the theme ({@link Theme.spacing}).
 * 
 * | value | px  | rem   |
 * | ----- | --- | ----- |
 * | 1     | 2   | 0.125 |
 * | 2     | 4   | 0.25  |
 * | 3     | 8   | 0.5   |
 * | 4     | 12  | 0.75  |
 * | 5     | 16  | 1     |
 * | 6     | 20  | 1.25  |
 * | 7     | 24  | 1.5   |
 * | 8     | 28  | 1.75  |
 * | 9     | 32  | 2     |
 * | 10    | 36  | 2.25  |
 * | 11    | 40  | 2.5   |
 * | 12    | 44  | 2.75  |
 * | 13    | 48  | 3     |
 * | 14    | 52  | 3.25  |
 * | 15    | 56  | 3.5   |
 * | 16    | 60  | 3.75  |
 * | 17    | 64  | 4     |
 * | ...   | ... | ...   |
 */
export type Spacing = number
export type Spacing2 = `${Spacing} ${Spacing}`

export type Radius = OneOfRadius
export type Radius2 = `${Radius} ${Radius}`
export type Radius4 = `${Radius2} ${Radius2}`

type SxCssProperty<T> = T | T[]

export interface SxCssProperties {
  width?: SxCssProperty<Property.Width | number>,
  color?: SxCssProperty<Property.Color>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  margin?: SxCssProperty<Spacing | Spacing2 | Property.Margin>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  marginLeft?: SxCssProperty<Spacing | Property.MarginLeft>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  marginRight?: SxCssProperty<Spacing | Property.MarginRight>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  marginTop?: SxCssProperty<Spacing | Property.MarginTop>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  marginBottom?: SxCssProperty<Spacing | Property.MarginBottom>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  padding?: SxCssProperty<Spacing | Spacing2 | Property.Padding>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  paddingLeft?: SxCssProperty<Spacing | Property.PaddingLeft>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  paddingRight?: SxCssProperty<Spacing | Property.PaddingRight>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  paddingTop?: SxCssProperty<Spacing | Property.PaddingTop>,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  paddingBottom?: SxCssProperty<Spacing | Property.PaddingBottom>,
  borderRadius?: SxCssProperty<Radius | Radius4 | Property.BorderRadius>,
  borderTopLeftRadius?: SxCssProperty<Radius | Property.BorderTopLeftRadius>,
  borderTopRightRadius?: SxCssProperty<Radius | Property.BorderTopRightRadius>,
  borderBottomLeftRadius?: SxCssProperty<Radius | Property.BorderBottomLeftRadius>,
  borderBottomRightRadius?: SxCssProperty<Radius | Property.BorderBottomRightRadius>,
  font?: SxCssProperty<OneOfFontAppearances | Property.Font>,
  fontWeight?: SxCssProperty<OneOfFontWeights | Property.FontWeight>,
}

interface BrekapointAlias {
  'up(sm)'?: SxProperties,
  'up(md)'?: SxProperties,
  'up(lg)'?: SxProperties,
  'down(sm)'?: SxProperties,
  'down(md)'?: SxProperties,
  'down(lg)'?: SxProperties,
}

export interface SxCssAlias extends BrekapointAlias {
  w?: Property.Width | number,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  m?: Spacing | Spacing2 | Property.Margin,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  ml?: Spacing | Property.MarginLeft,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  mr?: Spacing | Property.MarginRight,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  mt?: Spacing | Property.MarginTop,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  mb?: Spacing | Property.MarginBottom,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  mx?: Spacing | Property.MarginBlock,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  my?: Spacing | Property.MarginInline,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  p?: Spacing | Spacing2 | Property.Padding,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  pl?: Spacing | Property.PaddingLeft,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  pr?: Spacing | Property.PaddingRight,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  pt?: Spacing | Property.PaddingTop,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  pb?: Spacing | Property.Bottom,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  px?: Spacing | Property.PaddingBlock,
  /**
   * Spacing or css value. Prefer using {@link Spacing}.
   */
  py?: Spacing | Property.PaddingInline,
  bg?: Property.Color | Property.BackgroundColor,
  r?: Radius | Radius4 | Property.BorderRadius,
  rtl?: Radius | Property.BorderTopLeftRadius,
  rbl?: Radius | Property.BorderBottomLeftRadius,
  rtr?: Radius | Property.BorderTopRightRadius,
  rbr?: Radius | Property.BorderBottomRightRadius,
}

type CssProperties = Omit<Properties, keyof SxCssProperties> & SxCssProperties & SxCssAlias

type CssPropertiesWithArray = {
  [K in keyof CssProperties]?: CssProperties[K] | Array<CssProperties[K]>
}

type Pseudo = { [P in SimplePseudos]?: CssPropertiesWithArray }
export type SxProperties = CssPropertiesWithArray & Pseudo

export function handleSxColor(theme: Theme, value = '') {
  const key = value.includes('.') ? value : `${value}.500`
  return get(theme.colorScheme, key) || get(theme.palette, key) || value
}

export function handleSxSpacing(theme: Theme, value: number | string = '') {
  const values = value.toString().split(' ')

  return values
    .map((key) => {
      const isNumber = key.match(/^\d+$/)
      return isNumber ? theme.spacing(parseInt(key, 10)) : key
    })
    .join(' ')
}

export function handleSxRadius(theme: Theme, value = '') {
  const values = value.split(' ')
  return values.map((key) => get(theme, `radius.${key}`) || key).join(' ')
}

export function handleSxWidth(_theme: Theme, value: string | number = '') {
  return typeof value === 'string' ? value : `${(value / 12) * 100}%`
}

export function handleSxFontWeight(theme: Theme, value = '') {
  return getFontWeight(theme, value as OneOfFontWeights) || value
}

export function handleSxContent(theme: Theme, value?: string) {
  if (value === undefined) {
    return undefined
  }

  return value === '' ? '""' : `"${value}"`
}

export function handleSxFont(theme: Theme, value?: string) {
  if (value === undefined) {
    return undefined
  }

  const final = value.split(' ')

  if (final.length === 1) {
    return getFontStyle(theme, final[0] as OneOfFontAppearances)
  }

  return value
}

export function handleSxBorder(theme: Theme, value = '') {
  const values = value.replace(/, /g, ',').split(' ')

  if (value === 'none') {
    return 'none'
  }

  if (values.length === 1) {
    return `1px solid ${handleSxColor(theme, values[0])}`
  }

  if (values.length === 2) {
    return `${values[0]} solid ${handleSxColor(theme, values[1])}`
  }

  return `${values[0]} ${values[1]} ${handleSxColor(theme, values[2])}`
}

export function handleSxBoxShadow(theme: Theme, value = '') {
  const values = value.split(' ')
  return values.length === 1 ? `0px 0px 0px 2px ${handleSxColor(theme, value)}` : value
}

const handlers = {
  fill: handleSxColor,
  color: handleSxColor,
  padding: handleSxSpacing,
  margin: handleSxSpacing,
  background: handleSxColor,
  backgroundColor: handleSxColor,
  borderRadius: handleSxRadius,
  border: handleSxBorder,
  borderColor: handleSxColor,
  fontWeight: handleSxFontWeight,
  width: handleSxWidth,
  content: handleSxContent,
  font: handleSxFont,
  boxShadow: handleSxBoxShadow,
}

export const alias = {
  w: 'width',
  m: 'margin',
  mt: 'marginTop',
  mb: 'marginBottom',
  ml: 'marginLeft',
  mr: 'marginRight',
  mx: 'marginInline',
  my: 'marginBlock',
  p: 'padding',
  pt: 'paddingTop',
  pb: 'paddingBottom',
  pl: 'paddingLeft',
  pr: 'paddingRight',
  px: 'paddingInline',
  py: 'paddingBlock',
  bg: 'backgroundColor',
  r: 'borderRadius',
  rtl: 'borderTopLeftRadius',
  rbl: 'borderBottomLeftRadius',
  rtr: 'borderTopRightRadius',
  rbr: 'borderBottomRightRadius',
}

type AliasNames = keyof typeof alias
type HandlerNames = keyof typeof handlers

function findHandler(cssProperty: string) {
  const handlerName = cssProperty.replace(handlerNameRegex, '') as HandlerNames
  return handlers[handlerName]
}

function replaceByBreakpointUp(prop: string, theme: Theme) {
  const breakpoint = prop.replace('up(', '').replace(')', '')

  return up(breakpoint as OneOfBreakpoints)({ theme })
}

function replaceByBreakpointDown(prop: string, theme: Theme) {
  const breakpoint = prop.replace('down(', '').replace(')', '')

  return down(breakpoint as OneOfBreakpoints)({ theme })
}

function convertSxPropertyToCss(sxProp: keyof SxProperties, theme: Theme) {
  if (sxProp.startsWith('down(')) {
    return replaceByBreakpointDown(sxProp, theme)
  }

  if (sxProp.startsWith('up(')) {
    return replaceByBreakpointUp(sxProp, theme)
  }

  return alias[sxProp as AliasNames] || sxProp
}

const breakpoints: Array<OneOfBreakpoints> = ['md', 'md', 'sm']

const defaultBreakers = (cssProp: string) => {
  const defaultBreakersObj: Record<string, CSSProperties> = {
    width: 12 as CSSProperties,
  }
  return defaultBreakersObj[cssProp] || {}
}

export function sx(theme: Theme, props: SxProperties = {}): CSSObject {
  const result: Record<string, CSSObject> = {}
  let prop: keyof SxProperties

  for (prop in props) {
    const cssProperty = convertSxPropertyToCss(prop, theme)
    const value = props[prop]
    const handler = findHandler(cssProperty)

    if (Array.isArray(value)) {
      for (const index in value) {
        if (index === '0') {
          result[cssProperty] = handler ? handler(theme, value[index] as string) : value[index]
          const breakpoint = down(breakpoints[index])({ theme })
          const breakpointValue = sx(theme, { [cssProperty]: defaultBreakers(cssProperty) })
          result[breakpoint] = { ...result[breakpoint], ...breakpointValue }
        } else {
          const breakpoint = down(breakpoints[index])({ theme })
          const breakpointValue = sx(theme, { [cssProperty]: value[index] })
          result[breakpoint] = { ...result[breakpoint], ...breakpointValue }
        }
      }
    } else if (typeof value === 'object') {
      result[cssProperty] = sx(theme, value as SxProperties)
    } else {
      result[cssProperty] = handler ? handler(theme, value as string) : value
    }
  }
  return result
}
