import 'jest-styled-components'
import { createRef } from 'react'
import Button from '../src/Button'
import defaultTheme from '../src/default-theme'
import { OneOfColorSchemes } from '../src/theme-types'
import { buildThemeWithComponents, render } from './react'

const colorSchemes = Object.keys(defaultTheme.colorScheme) as OneOfColorSchemes[]

test('should render a Button component', () => {
  const { container } = render(<Button>foo</Button>)

  expect(container.firstChild).toMatchInlineSnapshot(`
.c1 {
  height: fit-content;
  display: inline-flex;
  border-radius: 0.25rem;
  align-items: center;
  user-select: none;
  text-decoration: none;
  box-sizing: border-box;
  justify-content: center;
  cursor: pointer;
  border-width: 1px;
  border-style: solid;
  white-space: nowrap;
  font: 500 1rem/1.5 Roboto,sans-serif;
  color: #000000;
  background-color: #FF6633;
  border-color: #FF6633;
  padding-inline: 0.75rem;
  padding-block: 0.5rem;
}

.c0+.c0 {
  margin-left: 0.5rem;
}

.c1:active,
.c1:focus,
.c1:hover {
  background-color: #FF9775;
  border-color: #FF9775;
}

<button
  class="c0 c1"
>
  foo
</button>
`)
})

test('should render a Button spreading props in root element', () => {
  const { container } = render(<Button id="bar">foo</Button>)

  expect(container.firstChild).toHaveAttribute('id', 'bar')
})

test('should render a Button using ref', () => {
  const ref = createRef<HTMLButtonElement>()
  const { container } = render(<Button ref={ref}>foo</Button>)

  expect(ref.current).toBe(container.firstChild)
})

test('should render a Button using AsProp', () => {
  const { container } = render(
    <Button as="a" href="#">
      foo
    </Button>,
  )

  expect(container.firstChild?.nodeName).toBe('A')
  expect(container.firstChild).toHaveAttribute('href', '#')
})

test('should render a Button with disabled prop as true', () => {
  const { container } = render(<Button disabled>foo</Button>)

  expect(container.firstChild).toHaveAttribute('disabled')

  expect(container.firstChild).toHaveStyleRule('opacity', '0.24')
  expect(container.firstChild).toHaveStyleRule('pointer-events', 'none')
})

test('should render a Button with block prop as true', () => {
  const { container } = render(<Button block>foo</Button>)
  expect(container.firstChild).toHaveStyleRule('width', '100%')
})

describe('ColorScheme Prop', () => {
  it.each(colorSchemes)('as %s', (colorSchemeName) => {
    const { container } = render(<Button colorScheme={colorSchemeName}>foo</Button>)
    const colorScheme = defaultTheme.colorScheme[colorSchemeName]

    expect(container.firstChild).toHaveStyleRule('background-color', colorScheme['500'])
    expect(container.firstChild).toHaveStyleRule('border-color', colorScheme['500'])
    expect(container.firstChild).toHaveStyleRule('color', colorScheme.contrastText)
  })
})

describe('Size Prop', () => {
  test('as Large', () => {
    const { container } = render(<Button size="lg">Button</Button>)

    expect(container.firstChild).toHaveStyleRule('padding-inline', '0.75rem')
    expect(container.firstChild).toHaveStyleRule('padding-block', '0.5rem')
  })

  test('as Medium', () => {
    const { container } = render(<Button size="md">Button</Button>)

    expect(container.firstChild).toHaveStyleRule('padding-inline', '0.5rem')
    expect(container.firstChild).toHaveStyleRule('padding-block', '0.25rem')
  })

  test('as Small', () => {
    const { container } = render(<Button size="sm">Button</Button>)

    const fontMicrotext = defaultTheme.font.appearance.microtext1
    const fontWeight = defaultTheme.font.weight.regular
    const fontFamily = defaultTheme.font.family.system2

    const fontExpected = `${fontWeight} ${fontMicrotext.size}/${fontMicrotext.lineHeight} ${fontFamily}`

    expect(container.firstChild).toHaveStyleRule('padding-inline', '0.5rem')
    expect(container.firstChild).toHaveStyleRule('padding-block', '0.25rem')
    expect(container.firstChild).toHaveStyleRule('font', fontExpected)
  })
})

describe('Appearance Prop', () => {
  it.each(colorSchemes)('as contained with color scheme %s', (colorSchemeName) => {
    const colorScheme = defaultTheme.colorScheme[colorSchemeName]

    const { container } = render(
      <Button appearance="contained" colorScheme={colorSchemeName}>
        foo
      </Button>,
    )

    const element = container.firstChild

    expect(element).toHaveStyleRule('color', colorScheme.contrastText)
    expect(element).toHaveStyleRule('background-color', colorScheme['500'])
    expect(element).toHaveStyleRule('border-color', colorScheme['500'])

    expect(element).toHaveStyleRule('background-color', colorScheme['400'], { modifier: ':hover' })
    expect(element).toHaveStyleRule('border-color', colorScheme['400'], { modifier: ':hover' })

    expect(element).toHaveStyleRule('background-color', colorScheme['400'], { modifier: ':focus' })
    expect(element).toHaveStyleRule('border-color', colorScheme['400'], { modifier: ':focus' })

    expect(element).toHaveStyleRule('background-color', colorScheme['400'], { modifier: ':active' })
    expect(element).toHaveStyleRule('border-color', colorScheme['400'], { modifier: ':active' })
  })

  it.each(colorSchemes)('as outlined with color scheme %s', (colorSchemeName) => {
    const colorScheme = defaultTheme.colorScheme[colorSchemeName]

    const { container } = render(
      <Button appearance="outlined" colorScheme={colorSchemeName}>
        foo
      </Button>,
    )

    const element = container.firstChild

    expect(element).toHaveStyleRule('color', colorScheme['500'])
    expect(element).toHaveStyleRule('background-color', 'transparent')
    expect(element).toHaveStyleRule('border-color', colorScheme['500'])

    expect(element).toHaveStyleRule('background-color', colorScheme['500'], { modifier: ':hover' })
    expect(element).toHaveStyleRule('color', colorScheme.contrastText, { modifier: ':hover' })

    expect(element).toHaveStyleRule('outline', '1px solid #FF6633', { modifier: ':focus' })

    expect(element).toHaveStyleRule('background-color', colorScheme['500'], { modifier: ':active' })
    expect(element).toHaveStyleRule('color', colorScheme.contrastText, { modifier: ':active' })
  })

  it.each(colorSchemes)('as text with color scheme %s', (colorSchemeName) => {
    const colorScheme = defaultTheme.colorScheme[colorSchemeName]

    const { container } = render(
      <Button appearance="text" colorScheme={colorSchemeName}>
        foo
      </Button>,
    )

    const element = container.firstChild

    expect(element).toHaveStyleRule('color', colorScheme['500'])
    expect(element).toHaveStyleRule('background-color', 'transparent')
    expect(element).toHaveStyleRule('border-color', 'transparent')

    expect(element).toHaveStyleRule('border-color', colorScheme['500'], { modifier: ':focus' })
    expect(element).toHaveStyleRule('border-color', colorScheme['500'], { modifier: ':hover' })
    expect(element).toHaveStyleRule('border-color', colorScheme['500'], { modifier: ':active' })
  })
})

describe('Component Style', () => {
  it('extends style from theme', () => {
    const customTheme = buildThemeWithComponents('Button', 'base', {
      padding: '100px',
    })

    const { container } = render(<Button>foo</Button>, {
      theme: customTheme,
    })

    expect(container.firstChild).toHaveStyleRule('padding', '100px')
  })

  it('overwrite style from theme', () => {
    const customTheme = buildThemeWithComponents('Button', 'overwrite', {
      backgroundColor: 'aqua',
    })

    const { container } = render(<Button colorScheme="primary">foo</Button>, {
      theme: customTheme,
    })

    expect(container.firstChild).toHaveStyleRule('background-color', 'aqua')
  })

  test('overwrite style with sx prop', () => {
    const { container } = render(<Button sx={{ color: 'aqua' }}>foo</Button>)

    expect(container.firstChild).toHaveStyleRule('color', 'aqua')
  })
})
