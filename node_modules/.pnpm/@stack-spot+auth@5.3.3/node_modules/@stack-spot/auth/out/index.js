'use strict';

var lodash = require('lodash');
var jose = require('jose');
var CryptoJS = require('crypto-es');
var sha256_js = require('crypto-es/lib/sha256.js');
var encBase64_js = require('crypto-es/lib/enc-base64.js');

var __defProp$7 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
var __publicField$7 = (obj, key, value) => {
  __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class AuthInterceptor {
  constructor(config, session) {
    __publicField$7(this, "originalFetch");
    __publicField$7(this, "session");
    __publicField$7(this, "maxRetrials");
    __publicField$7(this, "retryDelay");
    this.originalFetch = config.fetch;
    this.session = session;
    this.maxRetrials = config.retry;
    this.retryDelay = config.retryDelay;
  }
  /**
   * The Fetch API can receive headers as an object in the format `{ headerKey: headerValue }`, an array with key-value pairs
   * `[[headerKey, headerValue]]` or an instance of the class `Headers`. This function receives any type of headers and normalizes it into
   * an object in the format `{ headerKey: headerValue }`.
   * @param headers the headers to normalize.
   * @returns an object where each entry is composed by a header key and a header value.
   */
  normalizeHeaders(headers) {
    try {
      if (headers instanceof Headers) {
        const record = {};
        headers.forEach((value, key) => record[key] = value);
        return record;
      }
    } catch (e) {
    }
    if (Array.isArray(headers)) {
      return headers.reduce((result, [key, value]) => __spreadProps$3(__spreadValues$4({}, result), { [key]: value }), {});
    }
    return headers;
  }
  /**
   * Intercepts the request to include the authentication token.
   * 
   * @param request the original request
   * @returns the request with the authentication header.
   */
  async interceptRequest(request) {
    var _a;
    const token = await this.session.getToken();
    const headers = lodash.omitBy(this.normalizeHeaders((_a = request.init) == null ? void 0 : _a.headers), (_, key) => key.toLowerCase() === "authorization");
    const init = __spreadProps$3(__spreadValues$4({}, request.init), {
      headers: __spreadProps$3(__spreadValues$4({}, headers), {
        authorization: `Bearer ${token}`
      })
    });
    return { url: request.url, init };
  }
  /**
   * Intercepts the response in order to perform retrials in case of errors.
   * 
   * @param response the original response.
   * @param request the request.
   * @param retrials the number of retrials already performed.
   * @returns the retried response.
   */
  async interceptResponse(response, request, retrials = 0) {
    var _a, _b, _c, _d;
    if (response.ok || retrials >= this.maxRetrials || ((_b = (_a = request.init) == null ? void 0 : _a.signal) == null ? void 0 : _b.aborted))
      return response;
    await new Promise((resolve) => {
      var _a2, _b2;
      const timeout = setTimeout(resolve, this.retryDelay);
      (_b2 = (_a2 = request.init) == null ? void 0 : _a2.signal) == null ? void 0 : _b2.addEventListener("abort", () => {
        clearTimeout(timeout);
        resolve();
      });
    });
    if ((_d = (_c = request.init) == null ? void 0 : _c.signal) == null ? void 0 : _d.aborted)
      return response;
    const newRequest = await this.interceptRequest(request);
    const newResponse = await this.originalFetch(newRequest.url, newRequest.init);
    return this.interceptResponse(newResponse, request, retrials + 1);
  }
  /**
   * A custom implementation of {@link global.fetch} including authentication and retrials on errors.
   * 
   * @param input the URL to the request.
   * @param init the request options.
   * @returns the response.
   */
  async fetch(input, init) {
    const request = await this.interceptRequest({ init, url: input });
    const response = await this.originalFetch(request.url, request.init);
    return this.interceptResponse(response, request);
  }
}

var __defProp$6 = Object.defineProperty;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$6 = (obj, key, value) => {
  __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class AuthenticationError extends Error {
  constructor(message) {
    super(message);
  }
}
class ConnectionError extends AuthenticationError {
  constructor() {
    super(`Unable to complete request. Please check your internet connection or contact your network administrator if the problem persists.`);
  }
}
class SessionExpiredError extends AuthenticationError {
  constructor() {
    super("The session is expired, please reauthenticate.");
  }
}
class MalFormedAccessToken extends AuthenticationError {
  constructor(token, cause) {
    super(`Unable to decode the access token, it seems to be malformed.
Cause: ${cause}`);
    __publicField$6(this, "token");
    this.cause = cause;
    this.token = token;
  }
}
class InvalidTenantError extends AuthenticationError {
  constructor(tenant) {
    super(`The tenant for authentication (${tenant}) is invalid.`);
    __publicField$6(this, "tenant");
    this.tenant = tenant;
  }
}
class InvalidCredentialsError extends AuthenticationError {
  constructor(status, method, tenant, description) {
    const reason = description || "The provided credentials are invalid. Please, try again.";
    super(`Error while retrieving token from the authentication service. Method: ${method}. Tenant: ${tenant}. Status: ${status}. Reason:
${reason}`);
  }
}
class InvalidSSOError extends AuthenticationError {
  constructor() {
    super("The e-mail provided doesn't correspond to any authentication provider in the database.");
  }
}
class InvalidProvider extends AuthenticationError {
  constructor() {
    super("The chosen provider is not currently supported");
  }
}
class AuthMethodUnavailable extends AuthenticationError {
  constructor(causes) {
    super(`The authentication is not currently available for the e-mail provided${causes ? `(${causes.filter((c) => !!c).join(", ")})` : ""}`);
  }
}
class LogoutError extends Error {
  constructor(response) {
    super(`Unable to logout from IAM. Cause: ${response.statusText}.`);
    __publicField$6(this, "response");
    this.response = response;
  }
}
class NetworkError extends Error {
  constructor(response, body) {
    super(`${response.status}. ${body}.`);
    __publicField$6(this, "response");
    this.response = response;
  }
  static async create(response) {
    let body = "";
    try {
      body = await response.text();
    } catch (e) {
    }
    return new NetworkError(response, body);
  }
}

function queryStringToObject(qs) {
  return [...new URLSearchParams(qs)].reduce(
    (result, [key, value]) => (result[key] = value, result),
    {}
  );
}
function secondsToMilliseconds(seconds) {
  return seconds * 1e3;
}
const numberOfSymbols = 36;
const aCode = "a".charCodeAt(0);
function randomizeString(numberOfChars) {
  const rand = lodash.random(0, numberOfSymbols - 1);
  const char = rand < 10 ? `${rand}` : String.fromCharCode(aCode + (rand - 10));
  return numberOfChars > 1 ? `${char}${randomizeString(numberOfChars - 1)}` : char;
}
function randomizeNumericString(numberOfChars) {
  const rand = lodash.random(0, 9);
  return numberOfChars > 1 ? `${rand}${randomizeNumericString(numberOfChars - 1)}` : `${rand}`;
}
async function printResponseError(response) {
  let body = "";
  try {
    body = await response.text();
  } catch (e) {
  }
  const headers = [];
  response.headers.forEach((v, k) => headers.push(`${k} = ${v}`));
  console.error(`Request to ${response.url} failed.
status: ${response.status}
statusText: ${response.statusText}
body: "${body}"
headers: ${headers.join(", ")}.`);
}
async function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __publicField$5 = (obj, key, value) => {
  __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const refreshCheck = {
  maxAttempts: 10,
  intervalMS: 500
};
const expiryTimeMarginSeconds = 15;
function jwtToAccessTokenPayload(token) {
  try {
    return jose.decodeJwt(token);
  } catch (error) {
    throw new MalFormedAccessToken(token, error);
  }
}
function isInThePast(timestamp) {
  if (!timestamp)
    return false;
  const expiration = secondsToMilliseconds(timestamp);
  return Date.now() >= expiration;
}
function parseSerializedSession(serialized) {
  var _a;
  const [_, time, data] = (_a = serialized.match(/^(\d*);(.*)$/)) != null ? _a : [];
  const error = new Error(`Error while deserializing Session. Malformed string.
${serialized}`);
  if (!time || !data)
    throw error;
  try {
    return { time, data: JSON.parse(data) };
  } catch (e) {
    throw error;
  }
}
class Session {
  constructor(data, config, tokenClient, lastPersisted = "") {
    __publicField$5(this, "data", {});
    // this is initialized in the constructor
    __publicField$5(this, "accessTokenData", {});
    __publicField$5(this, "refreshTokenData", {});
    __publicField$5(this, "currentRefresh");
    __publicField$5(this, "tokenClient");
    __publicField$5(this, "persistence");
    __publicField$5(this, "interceptor");
    __publicField$5(this, "lastPersisted");
    this.setSessionData(data);
    this.tokenClient = tokenClient;
    this.interceptor = new AuthInterceptor(config, this);
    this.persistence = config.sessionPersistence;
    this.lastPersisted = lastPersisted;
    if (!lastPersisted)
      this.persist();
  }
  setSessionData(data) {
    this.data = data;
    this.accessTokenData = jwtToAccessTokenPayload(data.access_token);
    this.refreshTokenData = jwtToAccessTokenPayload(data.refresh_token);
    this.serialize();
  }
  /**
   * Updates values in the session data. Values not available in the object passed as parameter will keep their previous values.
   * Useful for changing tokens with arbitrary values.
   * @param data the properties to update
   */
  updateSessionData(data) {
    this.setSessionData(__spreadValues$3(__spreadValues$3({}, this.data), data));
    this.persist();
  }
  /**
   * Restores a serialized session created with `Session#serialize()`.
   * 
   * It's a good idea to call `Session#isExpired()` right after this to check the session validity.
   * 
   * @param serialized the serialized session as a string.
   * @param tokenClient a TokenClient.
   * @returns the restored session.
   */
  static fromSerializedSession(serialized, config, tokenClient) {
    const { time, data } = parseSerializedSession(serialized);
    return new Session(data, config, tokenClient, time);
  }
  async loadPersisted() {
    var _a;
    const persisted = await ((_a = this.persistence) == null ? void 0 : _a.load());
    if (!persisted || persisted.startsWith(`${this.lastPersisted};`))
      return;
    try {
      const { data } = parseSerializedSession(persisted);
      this.setSessionData(data);
    } catch (error) {
      console.error("Error while recovering session.", error);
    }
  }
  persist() {
    if (!this.persistence)
      return;
    this.lastPersisted = `${Date.now()}`;
    return this.persistence.save(this.serialize());
  }
  async refreshSession() {
    try {
      const data = await this.tokenClient.authenticate(
        "refreshToken",
        {
          refreshToken: this.data.refresh_token,
          clientId: this.data.client_id,
          tenant: this.data.tenant
        }
      );
      this.setSessionData(data);
      await this.persist();
      return this.data.access_token;
    } catch (error) {
      if (error instanceof InvalidCredentialsError) {
        let attempts = refreshCheck.maxAttempts;
        while (attempts && this.shouldRefreshToken()) {
          await delay(refreshCheck.intervalMS);
          await this.loadPersisted();
          attempts--;
        }
        if (this.shouldRefreshToken())
          throw error;
        else
          return this.data.access_token;
      } else {
        throw error;
      }
    }
  }
  shouldRefreshToken() {
    var _a;
    const expiryTime = (_a = this.accessTokenData) == null ? void 0 : _a.exp;
    return isInThePast(expiryTime - expiryTimeMarginSeconds);
  }
  /**
   * Gets the current access token.
   * 
   * - If the access token is set to expire within the next 15 seconds, it refreshes it before returning (async).
   * - If the refresh token is also invalid, then this session is no longer valid and a {@link SessionExpiredError} is thrown.
   * - If an error occurs while refreshing, this error is thrown.
   * 
   * Important: this function never produces multiple concurrent calls to the authentication API. Whenever multiple calls are made, they
   * use the same ongoing request. In summary, there's no need to worry about multiple requests triggering this at the same time.
   * 
   * @throws
   * - {@link SessionExpiredError} when the both the access token and refresh token are expired.
   * - {@link AuthenticationError}, {@link InvalidCredentialsError}, {@link InvalidTenantError} when the refresh fails.
   * 
   * @returns a promise that resolves to the access token.
   */
  async getToken() {
    if (this.currentRefresh)
      return this.currentRefresh;
    await this.loadPersisted();
    if (this.isExpired())
      throw new SessionExpiredError();
    if (this.shouldRefreshToken()) {
      this.currentRefresh = this.refreshSession();
      await this.currentRefresh;
      this.currentRefresh = void 0;
    }
    return this.data.access_token;
  }
  /**
   * A Session is expired if its refresh token is expired.
   * @returns true if the session is expired, false otherwise.
   */
  isExpired() {
    var _a;
    return isInThePast((_a = this.refreshTokenData) == null ? void 0 : _a.exp);
  }
  /**
   * Gets the data contained in the access token.
   * Useful for getting user information like name and email.
   * @returns the access token data.
   */
  getTokenData() {
    return this.accessTokenData;
  }
  /**
   * Gets the raw data used to build the session.
   * @returns the session data.
   */
  getSessionData() {
    return this.data;
  }
  /**
   * Serializes this session.
   * 
   * The session can be restored with Session.fromSerializedSession(string).
   * 
   * Format: {unix time in ms when the session was created or restored};{session data ({@link SessionPayload}) in json form}
   * 
   * @returns the serialized session.
   */
  serialize() {
    return `${this.lastPersisted};${JSON.stringify(this.data)}`;
  }
  /**
   * A custom implementation of {@link global.fetch} including authentication and retrials on errors. Ths will take care of refreshing the
   * token when necessary.
   * 
   * @throws
   * - {@link SessionExpiredError} when the both the access token and refresh token are expired.
   * - {@link AuthenticationError}, {@link InvalidCredentialsError}, {@link InvalidTenantError} when the refresh fails.
   * 
   * @param input the URL to the request.
   * @param init the request options.
   * @returns the response.
   */
  fetch(input, init) {
    return this.interceptor.fetch(input, init);
  }
  /**
   * Logs out from IAM.
   * @throws
   * - {@link LogoutError} if the logout fails. This error has the original response as one of its properties.
   */
  logout() {
    return this.tokenClient.logout(this.data);
  }
}

const UUID_V4_TEMPLATE = "10000000-1000-4000-8000-100000000000";
class CryptoUtils {
  static _randomWord() {
    return CryptoJS.lib.WordArray.random(1).words[0];
  }
  /**
   * Generates RFC4122 version 4 guid
   */
  static generateUUIDv4() {
    const uuid = UUID_V4_TEMPLATE.replace(
      /[018]/g,
      (c) => (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16)
    );
    return uuid.replace(/-/g, "");
  }
  /**
   * PKCE: Generate a code verifier
   */
  static generateCodeVerifier() {
    return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();
  }
  /**
   * PKCE: Generate a code challenge
   */
  static generateCodeChallenge(code_verifier) {
    try {
      const hashed = sha256_js.SHA256(code_verifier);
      return encBase64_js.Base64.stringify(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    } catch (err) {
      throw err;
    }
  }
}
const random = CryptoUtils.generateCodeVerifier;
const generators = {
  random,
  state: random,
  nonce: random,
  codeVerifier: random,
  codeChallenge: CryptoUtils.generateCodeChallenge
};

var __defProp$4 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var __publicField$4 = (obj, key, value) => {
  __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const MAX_ATTEMPTS_TO_GENERATE_ACCOUNT = 5;
const storageKeyPrefix = "stackSpotAuth.thirdPartyLogin.";
const maxLoginTimeMs = 24 * 60 * 60 * 1e3;
function buildPKCE() {
  const codeVerifier = generators.codeVerifier();
  return {
    state: generators.state(),
    codeVerifier,
    codeChallenge: generators.codeChallenge(codeVerifier)
  };
}
function buildStorageKey(state) {
  return `${storageKeyPrefix}${state}`;
}
class ThirdPartyClient {
  constructor(config, tokenClient) {
    __publicField$4(this, "config");
    __publicField$4(this, "tokenClient");
    this.config = config;
    this.tokenClient = tokenClient;
  }
  async findAuthDataByEmail(email) {
    const url = `${this.config.accountUrl}/v1/accounts?email=${encodeURIComponent(email)}`;
    const response = await this.config.fetch(url);
    if (response.ok) {
      const { tenant, idp, accountType, iamTenant } = await response.json();
      if (!tenant)
        throw new InvalidSSOError();
      return { tenant, idp, accountType, iamTenant };
    }
    printResponseError(response);
    let errorCode;
    try {
      errorCode = (await response.json()).code;
    } catch (e) {
    }
    throw errorCode === "ACC_ACCOUNT_NOT_FOUND_ERROR" ? new InvalidSSOError() : new AuthMethodUnavailable([response.statusText, response.status, errorCode]);
  }
  buildSearchParams({ codeChallenge, state, email, locale }) {
    const params = {
      state,
      client_id: this.config.clientId,
      redirect_uri: this.config.redirectUrl,
      response_type: "code",
      scope: "openid email offline_access profile attributes roles",
      code_challenge: codeChallenge,
      code_challenge_method: "S256",
      ui_locales: locale || "en"
    };
    if (email) {
      params.login_hint = email;
    }
    return new URLSearchParams(params);
  }
  clearExpiredLoginAttempts() {
    var _a;
    const st = this.config.storage;
    for (let i = 0; i < st.length; i++) {
      const key = st.key(i);
      if (key == null ? void 0 : key.startsWith(storageKeyPrefix)) {
        const data = JSON.parse((_a = st.getItem(key)) != null ? _a : "{}");
        if (Date.now() - data.createdAt > maxLoginTimeMs)
          st.removeItem(key);
      }
    }
  }
  /**
   * Performs an authenticated fetch and returns the JSON result.
   */
  async authFetch(input, token, init) {
    const headers = __spreadProps$2(__spreadValues$2({}, init == null ? void 0 : init.headers), { authorization: `Bearer ${token}`, "content-type": "application/json; charset=utf-8" });
    const response = await this.config.fetch(input, __spreadProps$2(__spreadValues$2({}, init), { headers }));
    if (!response.ok)
      throw await NetworkError.create(response);
    return response.json();
  }
  async isAccountAvailable(acc, accessToken) {
    var _a;
    const params = new URLSearchParams(acc);
    const url = `${this.config.accountUrl}/v1/accounts/freemium/available?${params}`;
    try {
      const { available } = await this.authFetch(url, accessToken);
      return available != null ? available : false;
    } catch (error) {
      console.error("Error while validating account name and slug. Cause:", (_a = error.message) != null ? _a : error);
    }
    return false;
  }
  createSlug(name) {
    return lodash.deburr(name).toLowerCase().replaceAll(/^-+|-+$/g, "").replace(/ /g, "-").replace(/(-)+/g, "-").replace(/[^a-z-\d]/g, "").substring(0, 60);
  }
  async generateAccount(accessToken, name, remainingAttempts = MAX_ATTEMPTS_TO_GENERATE_ACCOUNT) {
    if (remainingAttempts === 0 || !name) {
      const name2 = randomizeString(20);
      return { name: name2, slug: name2 };
    }
    const suffix = remainingAttempts === MAX_ATTEMPTS_TO_GENERATE_ACCOUNT ? void 0 : randomizeNumericString(4);
    name = suffix ? `${name} ${suffix}` : name;
    const acc = { name, slug: this.createSlug(name) };
    const available = await this.isAccountAvailable(acc, accessToken);
    return available ? acc : this.generateAccount(accessToken, name, remainingAttempts - 1);
  }
  getUserName({ name, given_name, family_name, preferred_username, email }) {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = name != null ? name : given_name && family_name ? `${given_name} ${family_name}` : void 0) != null ? _a : email) != null ? _b : preferred_username) != null ? _c : given_name) != null ? _d : family_name;
  }
  async createAccount(accessToken) {
    var _a;
    const data = jwtToAccessTokenPayload(accessToken);
    if (data.freemium_status === "PENDING") {
      const url = `${this.config.accountUrl}/v1/accounts/freemium`;
      const acc = await this.generateAccount(accessToken, this.getUserName(data));
      try {
        await this.authFetch(url, accessToken, { method: "post", body: JSON.stringify(acc) });
      } catch (error) {
        console.error(
          "It was not possible to complete the account creation. The user will be able to use some features, but not all. A new attempt will be made in the next login. Cause:",
          (_a = error.message) != null ? _a : error
        );
      }
      return true;
    }
    return false;
  }
  async refreshToken(session) {
    var _a;
    try {
      return this.tokenClient.authenticate(
        "refreshToken",
        { refreshToken: session.refresh_token, clientId: session.client_id, tenant: session.tenant }
      );
    } catch (error) {
      console.error(
        "Could not refresh token after account creation. Permissions will be reduced during this session. Cause:",
        (_a = error.message) != null ? _a : error
      );
      return session;
    }
  }
  /**
   * Performs a 3rd party login (first part).
   * 
   * This operation happens in two parts, this is the first one and it returns the URL to redirect the user to login.
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   * 
   * @throws
   * - {@link InvalidSSOError}: if the email doesn't correspond to any SSO registered.
   * - {@link AuthMethodUnavailable}: if the 3rd party login is temporally unavailable.
   * - {@link PasswordExpectedError}: if the email address is managed by StackSpot itself and should instead use password login. This
   * exception has the property `tenant`, so it can be catch and redirect the user to the expected login method.
   * 
   * @param login parameters to the 3rd party login.
   * @returns the external url to login and the state. The state can be used to identify this login attempt.
   */
  async getThirdPartyLoginUrlAndState(login, data) {
    this.clearExpiredLoginAttempts();
    const { idp, iamTenant = "" } = login.type === "sso" ? await this.findAuthDataByEmail(login.email) : {
      idp: login.provider,
      iamTenant: this.config.defaultTenant
    };
    const path = `${iamTenant}/oidc/auth`;
    const { codeVerifier, codeChallenge, state } = buildPKCE();
    const storageData = {
      codeVerifier,
      tenant: iamTenant,
      createdAt: Date.now(),
      data
    };
    this.config.storage.setItem(buildStorageKey(state), JSON.stringify(storageData));
    const params = this.buildSearchParams({
      codeChallenge,
      state,
      email: login.type === "sso" ? login.email : void 0,
      idp,
      locale: login.locale
    });
    return { url: `${this.config.authUrl}/${path}?${params}`, state };
  }
  /**
  * Performs a 3rd party login (first part) using the given tenant.
  * 
  * This operation happens in two parts, this is the first one and it returns the URL to redirect the user to login.
  * This function does not depend on the user email, instead will use the given tenant to mount the url.
  * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
  * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
  * 
  * @param login parameters to the 3rd party login.
  * @param tenant tenant to mount the 3rd party login url.
  * @returns the external url to login and the state. The state can be used to identify this login attempt.
  */
  async getThirdPartyLoginFromTenant(login, tenant, data) {
    this.clearExpiredLoginAttempts();
    const { idp, iamTenant = "" } = login.type === "sso" ? { iamTenant: tenant, idp: void 0 } : {
      idp: login.provider,
      iamTenant: this.config.defaultTenant
    };
    const path = `${iamTenant}/oidc/auth`;
    const { codeVerifier, codeChallenge, state } = buildPKCE();
    const storageData = {
      codeVerifier,
      tenant: iamTenant,
      createdAt: Date.now(),
      data
    };
    this.config.storage.setItem(buildStorageKey(state), JSON.stringify(storageData));
    const params = this.buildSearchParams({
      codeChallenge,
      state,
      email: login.type === "sso" ? login.email : void 0,
      idp,
      locale: login.locale
    });
    return { url: `${this.config.authUrl}/${path}?${params}`, state };
  }
  /**
   * Performs a 3rd party login (second and final part).
   * 
   * This operation happens in two parts, this is the last one and it returns a SessionPayload.
   * This should be called by whatever is in `config.redirectUrl`. The only parameter it receives must be the query string in the url.
   * 
   * If the account is new and PENDING, another service will be called to finish the account creation. If the account creation cannot be
   * completed, it will not fail. Instead, it will try again on the next login while the user has some reduced permissions.
   * 
   * @throws
   * - {@link AuthenticationError}: if something goes wrong.
   * 
   * @param queryString 
   * @returns the session payload, which may be used to create a Session object.
   */
  async completeThirdPartyLogin(queryString) {
    const queryObject = queryStringToObject(queryString);
    if (queryObject.error) {
      throw new AuthenticationError(`${queryObject.error}. ${decodeURIComponent(queryObject.error_description)}.`);
    }
    const { code, state } = queryObject;
    const storageKey = buildStorageKey(state);
    const fromStorage = this.config.storage.getItem(storageKey);
    const { codeVerifier, tenant, data } = fromStorage ? JSON.parse(fromStorage) : {};
    this.config.storage.removeItem(storageKey);
    if (!codeVerifier || !tenant)
      throw new AuthenticationError("Not enough data to perform 3rd party login.");
    const sessionData = await this.tokenClient.authenticate("authorizationCode", { code, tenant, codeVerifier });
    const hasAccountBeenCreated = await this.createAccount(sessionData.access_token);
    const finalSessionData = hasAccountBeenCreated ? await this.refreshToken(sessionData) : sessionData;
    return { sessionData: finalSessionData, data };
  }
  /**
   * List all accounts available for the user of the access token passed as parameter.
   * 
   * @throws
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param accessToken 
   * @returns the accounts
   */
  listAccounts(accessToken) {
    const url = `${this.config.accountUrl}/v1/users/accounts`;
    try {
      return this.authFetch(url, accessToken);
    } catch (error) {
      if (error instanceof NetworkError && [401, 403].includes(error.response.status)) {
        throw new AuthenticationError(`You are not allowed to list accounts. Check the error below for more details:
${error.message}`);
      }
      throw error;
    }
  }
  /**
   * Switches the active account for the user of the access token passed as parameter.
   * 
   * @throws
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param accountId the id of the account to switch to.
   * @param accessToken 
   * @returns the tokens linking to the new accont.
   */
  switchAccount(accountId, accessToken) {
    const url = `${this.config.accountUrl}/v1/authentication/switch-account`;
    try {
      return this.authFetch(url, accessToken, { method: "post", body: JSON.stringify({ accountId }) });
    } catch (error) {
      if (error instanceof NetworkError && [401, 403].includes(error.response.status)) {
        throw new AuthenticationError(
          `You are not allowed to switch to this account. Check the error below for more details:
${error.message}`
        );
      }
      throw error;
    }
  }
}

var __defProp$3 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
async function buildError(method, tenant, response) {
  var _a;
  if (response.status === 404)
    return new InvalidTenantError(tenant);
  let errorMessage = void 0;
  try {
    const errorData = await response.json();
    errorMessage = errorData.error_description;
    errorMessage || (errorMessage = await response.text());
  } catch (e) {
  }
  return [400, 401, 403].includes(response.status) ? new InvalidCredentialsError(response.status, method, tenant, errorMessage) : new AuthenticationError((_a = errorMessage != null ? errorMessage : response.statusText) != null ? _a : "Unknown error.");
}
const credentialMethodToGrantType = {
  password: "password",
  client: "client_credentials",
  refreshToken: "refresh_token",
  authorizationCode: "authorization_code"
};
class TokenClient {
  constructor(config) {
    __publicField$3(this, "config");
    this.config = config;
  }
  /**
   * Authenticates using one of the authentication methods available.
   * 
   * This throws an AuthenticationError on errors:
   * - {@link InvalidTenantError}: if the tenant or the url is invalid (on 404).
   * - {@link InvalidCredentialsError}: if the credentials are invalid.
   * - Plain {@link AuthenticationError}: if the error is unknown.
   * 
   * @param url the url to the authentication API.
   * @param method the authentication method.
   * @param credentials the credentials for signing in.
   * @returns the session data. You can use it to create an instance of Session.
   * @throws AuthenticationError
   */
  async authenticate(method, _a) {
    var _b = _a, { tenant = this.config.defaultTenant, clientId = this.config.clientId } = _b, credentials = __objRest(_b, ["tenant", "clientId"]);
    const encoded = lodash.map(
      __spreadProps$1(__spreadValues$1({}, credentials), { clientId, grantType: credentialMethodToGrantType[method], redirectUri: this.config.redirectUrl }),
      (value, key) => `${lodash.snakeCase(key)}=${encodeURIComponent(`${value}`)}`
    ).join("&");
    let response;
    try {
      response = await this.config.fetch(
        `${this.config.authUrl}/${encodeURIComponent(tenant)}/oidc/oauth/token`,
        {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: encoded
        }
      );
    } catch (e) {
      throw new ConnectionError();
    }
    if (!response.ok)
      throw await buildError(method, tenant, response);
    try {
      const sessionData = await response.json();
      return __spreadProps$1(__spreadValues$1({}, sessionData), { client_id: clientId, tenant });
    } catch (e) {
      throw new AuthenticationError(
        "There was an error while deserializing the body of the authentication response."
      );
    }
  }
  /**
   * Logs out from Stk Iam.
   * @throws
   * - {@link LogoutError} if the logout fails. This error has the original response as one of its properties.
   * @param the session data to log out 
   */
  async logout({
    tenant,
    id_token
  }) {
    const logoutUrl = `${this.config.authUrl}/${tenant}/oidc/end_session`;
    const params = new URLSearchParams({ id_token_hint: id_token });
    const response = await this.config.fetch(`${logoutUrl}?${params}`, {});
    if (!response.ok)
      throw new LogoutError(response);
  }
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MemoryStorage {
  constructor() {
    __publicField$2(this, "map", /* @__PURE__ */ new Map());
    __publicField$2(this, "length", 0);
  }
  clear() {
    this.map.clear();
    this.length = 0;
  }
  getItem(key) {
    var _a;
    return (_a = this.map.get(key)) != null ? _a : null;
  }
  key(index) {
    var _a;
    return (_a = Array.from(this.map.keys())[index]) != null ? _a : null;
  }
  removeItem(key) {
    this.map.delete(key);
    this.length = this.map.size;
  }
  setItem(key, value) {
    this.map.set(key, value);
    this.length = this.map.size;
  }
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ThirdPartyObservable {
  constructor() {
    __publicField$1(this, "listeners", {
      error: [],
      redirect: [],
      success: [],
      url: []
    });
    __publicField$1(this, "events", {
      error: [],
      redirect: [],
      success: [],
      url: []
    });
  }
  /**
   * Registers a listener for whenever an error occurs during login.
   * The original error object is passed as a parameter to the listener.
   * @param listener the lister to register.
   * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
   */
  onError(listener, runPreviousEvents = true) {
    if (runPreviousEvents)
      this.events.error.forEach((params) => listener(...params));
    this.listeners.error.push(listener);
    return this;
  }
  /**
   * Register a listener to run when the external login redirects the user back to the application.
   * @param listener the lister to register.
   * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
   */
  onRedirect(listener, runPreviousEvents = true) {
    if (runPreviousEvents)
      this.events.redirect.forEach((params) => listener(...params));
    this.listeners.redirect.push(listener);
    return this;
  }
  /**
   * Register a listener to run when the login succeeds and a session is created.
   * The new session is passed as a parameter to the listener.
   * If the data parameter was passed to the `startThirdPartyLogin` method, it is provided here as the second parameter.
   * @param listener the lister to register.
   * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
   */
  onSuccess(listener, runPreviousEvents = true) {
    if (runPreviousEvents)
      this.events.success.forEach((params) => listener(...params));
    this.listeners.success.push(listener);
    return this;
  }
  /**
   * Register a listener to run when the url for the external login is obtained.
   * The url is passed as a parameter to the listener.
   * @param listener the lister to register.
   * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
   */
  onUrl(listener, runPreviousEvents = true) {
    if (runPreviousEvents)
      this.events.url.forEach((params) => listener(...params));
    this.listeners.url.push(listener);
    return this;
  }
  /**
   * Triggers a login event.
   * @param event the event to trigger.
   * @param args the arguments expected by the event.
   */
  trigger(event, ...args) {
    this.listeners[event].forEach((l) => l(...args));
    this.events[event].push(args);
  }
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class AuthManager {
  constructor(config) {
    __publicField(this, "config");
    __publicField(this, "tokenClient");
    __publicField(this, "thirdPartyClient");
    __publicField(this, "thirdPartyLoginAttempts", /* @__PURE__ */ new Map());
    var _a, _b, _c, _d, _e;
    this.config = __spreadProps(__spreadValues({}, config), {
      fetch: (_a = config.fetch) != null ? _a : (...args) => window.fetch.apply(window, args),
      storage: (_b = config.storage) != null ? _b : new MemoryStorage(),
      retry: (_c = config.retry) != null ? _c : 1,
      retryDelay: (_d = config.retryDelay) != null ? _d : 500,
      sessionPersistence: (_e = config.sessionPersistence) != null ? _e : null
    });
    if (!this.config.fetch) {
      throw new Error(
        "This platform doesn't have a global implementation of the fetch function. Please, provide an implementation in you configuration."
      );
    }
    this.tokenClient = new TokenClient(this.config);
    this.thirdPartyClient = new ThirdPartyClient(this.config, this.tokenClient);
  }
  /**
   * Authenticates using one of the authentication methods available.
   * 
   * @throws
   * - {@link InvalidTenantError}: if the tenant or the url is invalid (on 404).
   * - {@link InvalidCredentialsError}: if the credentials are invalid.
   * - Plain {@link AuthenticationError}: if the error is unknown.
   * 
   * @param url the url to the authentication API.
   * @param method the authentication method.
   * @param credentials the credentials for signing in.
   * @returns the session.
   */
  async startSession(method, credentials) {
    const sessionData = await this.tokenClient.authenticate(method, credentials);
    return new Session(sessionData, this.config, this.tokenClient);
  }
  /**
   * Restores a serialized session using `config.sessionPersistence.load`. If there's no session persisted or the persisted session is
   * expired, undefined is returned.
   * 
   * @returns the restored session.
   */
  async restoreSession() {
    var _a;
    try {
      const restored = await ((_a = this.config.sessionPersistence) == null ? void 0 : _a.load());
      const session = restored ? Session.fromSerializedSession(restored, this.config, this.tokenClient) : void 0;
      if (session && !session.isExpired())
        return session;
    } catch (error) {
      console.error(error);
    }
  }
  async startObservableThirdPartyLoginAsync(login, observable, data) {
    try {
      const { url, state } = await this.thirdPartyClient.getThirdPartyLoginUrlAndState(login, data);
      this.thirdPartyLoginAttempts.set(state, observable);
      observable.onSuccess(() => this.thirdPartyLoginAttempts.delete(state));
      observable.trigger("url", url);
    } catch (error) {
      observable.trigger("error", error);
    }
  }
  /**
   * Performs a 3rd party login (first part).
   * 
   * This operation happens in two parts, this is the first one and it returns the url to perform the 3rd party login.
   * 
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * 
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   * 
   * @throws
   * - {@link InvalidSSOError}: if the email doesn't correspond to any SSO registered.
   * - {@link AuthMethodUnavailable}: if the 3rd party login is temporally unavailable.
   * 
   * @param login parameters to the 3rd party login.
   * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
   * @returns the url to perform the 3rd party login.
   */
  async startThirdPartyLogin(login, ...data) {
    const { url } = await this.thirdPartyClient.getThirdPartyLoginUrlAndState(login, data[0]);
    return url;
  }
  /**
   * Just like {@link startThirdPartyLogin}. But instead of returning the URL, it returns an observable object that can listen to any
   * login event. A login event is triggered on every step: url generated, redirected to application, success and error.
   * 
   * @param login parameters to the 3rd party login.
   * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
   * @returns an observable object that will update whenever a login step succeeds or fails.
   */
  startObservableThirdPartyLogin(login, ...data) {
    const observable = new ThirdPartyObservable();
    this.startObservableThirdPartyLoginAsync(login, observable, data[0]);
    return observable;
  }
  async completeObservableThirdPartyLoginAsync(queryString) {
    const { state } = queryStringToObject(queryString);
    const observable = this.thirdPartyLoginAttempts.get(state);
    if (!observable)
      throw new Error("Login attempt not found. This is a bug, please contact the team.");
    observable.trigger("redirect");
    try {
      const { sessionData, data } = await this.thirdPartyClient.completeThirdPartyLogin(queryString);
      const session = new Session(sessionData, this.config, this.tokenClient);
      observable.trigger("success", session, data);
    } catch (error) {
      observable.trigger("error", error);
    }
  }
  /**
   * Performs a 3rd party login (second and final part).
   * 
   * This operation happens in two parts, this is the last one and it returns a Session.
   * This should be called by whatever is in `config.redirectUrl`. The only parameter it receives must be the query string in the url.
   * 
   * @throws
   * - {@link AuthenticationError}: if something goes wrong.
   * 
   * @param queryString 
   * @returns an object containing the session and the data object passed to the `startThirdPartyLogin` method (if any).
   */
  async completeThirdPartyLogin(queryString) {
    const { sessionData, data } = await this.thirdPartyClient.completeThirdPartyLogin(queryString);
    const session = new Session(sessionData, this.config, this.tokenClient);
    return { session, data };
  }
  /**
   * Performs a 3rd party login (first part) using the given tenant
   * 
   * This operation happens in two parts, this is the first one and it returns the url to perform the 3rd party login.
   * This function does not use or depend on the user email, instead it will use the given tenant.
   * 
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * 
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   *
   * @param login parameters to the 3rd party login.
   * @param tenant parameters the tenant to mount the url.
   * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
   * @returns the url to perform the 3rd party login.
   */
  async getThirdPartyLoginFromTenant(login, tenant, ...data) {
    const { url } = await this.thirdPartyClient.getThirdPartyLoginFromTenant(login, tenant, data[0]);
    return url;
  }
  /**
   * Just like {@link completeThirdPartyLogin}. But instead of returning a Session, it completes the login for an existing
   * {@link ThirdPartyObservable} instantiated by the function {@link startObservableThirdPartyLogin}.
   * 
   * @param queryString.
   */
  completeObservableThirdPartyLogin(queryString) {
    this.completeObservableThirdPartyLoginAsync(queryString);
  }
  /**
   * List all accounts available for the user of the session passed as parameter.
   * 
   * @throws
   * - {@link SessionExpiredError}: if the session passed as parameter is expired.
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param session 
   * @returns the accounts
   */
  async listAccounts(session) {
    if (session.isExpired())
      throw new SessionExpiredError();
    const token = await session.getToken();
    return this.thirdPartyClient.listAccounts(token);
  }
  /**
   * Switches the active account for the user of the session passed as parameter.
   * 
   * @throws
   * - {@link SessionExpiredError}: if the session passed as parameter is expired.
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param accountId the id of the account to switch to.
   * @param accessToken 
   * @returns the tokens linking to the new accont.
   */
  async switchAccount(accountId, session) {
    if (session.isExpired())
      throw new SessionExpiredError();
    const token = await session.getToken();
    const sessionData = await this.thirdPartyClient.switchAccount(accountId, token);
    session.updateSessionData(sessionData);
  }
}

exports.AuthInterceptor = AuthInterceptor;
exports.AuthManager = AuthManager;
exports.AuthMethodUnavailable = AuthMethodUnavailable;
exports.AuthenticationError = AuthenticationError;
exports.ConnectionError = ConnectionError;
exports.InvalidCredentialsError = InvalidCredentialsError;
exports.InvalidProvider = InvalidProvider;
exports.InvalidSSOError = InvalidSSOError;
exports.InvalidTenantError = InvalidTenantError;
exports.LogoutError = LogoutError;
exports.MalFormedAccessToken = MalFormedAccessToken;
exports.NetworkError = NetworkError;
exports.Session = Session;
exports.SessionExpiredError = SessionExpiredError;
exports.ThirdPartyClient = ThirdPartyClient;
exports.ThirdPartyObservable = ThirdPartyObservable;
exports.TokenClient = TokenClient;
//# sourceMappingURL=index.js.map
