import { JWTPayload } from 'jose';

interface SessionPersistence {
    save: (session: string) => void | Promise<void>;
    load: () => string | undefined | null | Promise<string | undefined | null>;
}
interface AuthConfig {
    /**
     * The URL to the authentication API. e.g. STK-IAM.
     */
    readonly authUrl: string;
    /**
     * The default client id to perform an authentication.
     * This will be used whenever `clientId` is not provided when calling an authentication function.
     */
    readonly clientId: string;
    /**
     * The default tenant to perform an authentication.
     * This will be used whenever `tenant` is not provided when calling an authentication function.
     */
    readonly defaultTenant: string;
    /**
     * The URL to the account API of StackSpot.
     * This is used to retrieve the tenant when performing third-party SSO authentication.
     */
    readonly accountUrl: string;
    /**
     * The URL to redirect to when performing third-party authentication.
     */
    readonly redirectUrl: string;
    /**
     * The fetch function to be used by this library. Must respect the specifications of {@link global.fetch}.
     * If not provided, `global.fetch` will be used.
     *
     * Attention: an error will be throw if not provided and on a platform where `global.fetch` is not available, e.g. Node.
     * @default global.fetch
     */
    readonly fetch?: typeof fetch;
    /**
     * A storage to place data from third-party login. This will be an in-memory storage by default.
     *
     * If your login flow replaces the current view with an external site, then the default in-memory storage won't work and you should
     * provide something like the localStorage.
     *
     * @default
     * {@link MemoryStorage}
     */
    readonly storage?: Pick<Storage, 'clear' | 'getItem' | 'key' | 'removeItem' | 'setItem' | 'length'>;
    /**
     * Number of retries when a request fails.
     * @default 1
     */
    readonly retry?: number;
    /**
     * Milliseconds to wait before retrying a failed request.
     * @default 500
     */
    readonly retryDelay?: number;
    /**
     * A way to persist sessions across multiple executions, concurrent or not.
     *
     * If not provided, the session will be valid only for this single execution.
     *
     * @example
     * localStorage (browser):
     * ```
     * {
     *   save: (session) => localStorage.set('session', session),
     *   load: () => localStorage.get('session')
     * }
     * ```
     */
    readonly sessionPersistence?: SessionPersistence | null;
}
interface SessionPayload {
    readonly access_token: string;
    /**
     * seconds
     */
    readonly expires_in: number;
    /**
     * seconds
     */
    readonly refresh_expires_in: number;
    readonly refresh_token: string;
    readonly id_token: string;
    readonly token_type: string;
    readonly 'not-before-policy': number;
    readonly session_state: string;
    readonly scope: string;
    readonly tenant: string;
    readonly client_id: string;
    readonly is_iam_migrated: boolean;
}
interface AccessTokenPayload extends JWTPayload {
    readonly account_name?: string;
    readonly name?: string;
    readonly tenant?: string;
    readonly preferred_username?: string;
    readonly given_name?: string;
    readonly family_name?: string;
    readonly email?: string;
    readonly freemium_status?: 'FINALIZED' | 'PENDING';
    readonly account_id_v2?: string;
    readonly account_type?: 'ENTERPRISE' | 'FREEMIUM';
}
interface Credentials {
    tenant?: string;
    clientId?: string;
}
interface PasswordCredentials extends Credentials {
    username: string;
    password: string;
}
interface ClientCredentials extends Credentials {
    clientSecret: string;
}
interface RefreshTokenCredentials extends Credentials {
    refreshToken: string;
}
interface AuthorizationCodeCredentials extends Credentials {
    code: string;
    codeVerifier: string;
}
type CredentialMethod = 'password' | 'client' | 'refreshToken' | 'authorizationCode';
type CredentialOf<T extends CredentialMethod> = T extends 'password' ? PasswordCredentials : T extends 'client' ? ClientCredentials : T extends 'refreshToken' ? RefreshTokenCredentials : T extends 'authorizationCode' ? AuthorizationCodeCredentials : never;
type ThirdPartyAuthType = 'sso' | 'idp';
type ThirdPartyProvider = 'external-idp:github';
interface BaseThirdPartyLoginParams {
    type: ThirdPartyAuthType;
    locale?: 'pt' | 'en';
}
interface SSOLoginParams extends BaseThirdPartyLoginParams {
    type: 'sso';
    email: string;
}
interface IDPLoginParams extends BaseThirdPartyLoginParams {
    type: 'idp';
    provider: ThirdPartyProvider;
}
type ThirdPartyLoginParams = SSOLoginParams | IDPLoginParams;
interface FetchRequest {
    url: URL | RequestInfo;
    init?: RequestInit;
}
type ThirdPartyLoginEvent = 'url' | 'redirect' | 'success' | 'error';
interface ThirdPartyLoginEventParams extends Record<ThirdPartyLoginEvent, any[]> {
    url: [string];
    redirect: [];
    success: [Session, any];
    error: [any];
}
interface ThirdPartyLoginResult<T = undefined> {
    session: Session;
    data: T;
}
interface Account {
    id: string;
    name: string;
    tenant: string;
    slug: string;
    roleType: string;
}
interface AccountTokens {
    access_token: string;
    refresh_token: string;
    token_type: string;
    expires_in: 0;
}

declare class TokenClient {
    readonly config: Required<AuthConfig>;
    constructor(config: Required<AuthConfig>);
    /**
     * Authenticates using one of the authentication methods available.
     *
     * This throws an AuthenticationError on errors:
     * - {@link InvalidTenantError}: if the tenant or the url is invalid (on 404).
     * - {@link InvalidCredentialsError}: if the credentials are invalid.
     * - Plain {@link AuthenticationError}: if the error is unknown.
     *
     * @param url the url to the authentication API.
     * @param method the authentication method.
     * @param credentials the credentials for signing in.
     * @returns the session data. You can use it to create an instance of Session.
     * @throws AuthenticationError
     */
    authenticate<T extends CredentialMethod>(method: T, { tenant, clientId, ...credentials }: CredentialOf<T>): Promise<SessionPayload>;
    /**
     * Logs out from Stk Iam.
     * @throws
     * - {@link LogoutError} if the logout fails. This error has the original response as one of its properties.
     * @param the session data to log out
     */
    logout({ tenant, id_token, }: Pick<SessionPayload, 'tenant' | 'id_token'>): Promise<void>;
}

declare class Session {
    private data;
    private accessTokenData;
    private refreshTokenData;
    private currentRefresh;
    private readonly tokenClient;
    private readonly persistence;
    private readonly interceptor;
    private lastPersisted;
    constructor(data: SessionPayload, config: Required<AuthConfig>, tokenClient: TokenClient, lastPersisted?: string);
    private setSessionData;
    /**
     * Updates values in the session data. Values not available in the object passed as parameter will keep their previous values.
     * Useful for changing tokens with arbitrary values.
     * @param data the properties to update
     */
    updateSessionData(data: Partial<SessionPayload>): void;
    /**
     * Restores a serialized session created with `Session#serialize()`.
     *
     * It's a good idea to call `Session#isExpired()` right after this to check the session validity.
     *
     * @param serialized the serialized session as a string.
     * @param tokenClient a TokenClient.
     * @returns the restored session.
     */
    static fromSerializedSession(serialized: string, config: Required<AuthConfig>, tokenClient: TokenClient): Session;
    private loadPersisted;
    private persist;
    private refreshSession;
    private shouldRefreshToken;
    /**
     * Gets the current access token.
     *
     * - If the access token is set to expire within the next 15 seconds, it refreshes it before returning (async).
     * - If the refresh token is also invalid, then this session is no longer valid and a {@link SessionExpiredError} is thrown.
     * - If an error occurs while refreshing, this error is thrown.
     *
     * Important: this function never produces multiple concurrent calls to the authentication API. Whenever multiple calls are made, they
     * use the same ongoing request. In summary, there's no need to worry about multiple requests triggering this at the same time.
     *
     * @throws
     * - {@link SessionExpiredError} when the both the access token and refresh token are expired.
     * - {@link AuthenticationError}, {@link InvalidCredentialsError}, {@link InvalidTenantError} when the refresh fails.
     *
     * @returns a promise that resolves to the access token.
     */
    getToken(): Promise<string>;
    /**
     * A Session is expired if its refresh token is expired.
     * @returns true if the session is expired, false otherwise.
     */
    isExpired(): boolean;
    /**
     * Gets the data contained in the access token.
     * Useful for getting user information like name and email.
     * @returns the access token data.
     */
    getTokenData(): AccessTokenPayload;
    /**
     * Gets the raw data used to build the session.
     * @returns the session data.
     */
    getSessionData(): SessionPayload;
    /**
     * Serializes this session.
     *
     * The session can be restored with Session.fromSerializedSession(string).
     *
     * Format: {unix time in ms when the session was created or restored};{session data ({@link SessionPayload}) in json form}
     *
     * @returns the serialized session.
     */
    serialize(): string;
    /**
     * A custom implementation of {@link global.fetch} including authentication and retrials on errors. Ths will take care of refreshing the
     * token when necessary.
     *
     * @throws
     * - {@link SessionExpiredError} when the both the access token and refresh token are expired.
     * - {@link AuthenticationError}, {@link InvalidCredentialsError}, {@link InvalidTenantError} when the refresh fails.
     *
     * @param input the URL to the request.
     * @param init the request options.
     * @returns the response.
     */
    fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
    /**
     * Logs out from IAM.
     * @throws
     * - {@link LogoutError} if the logout fails. This error has the original response as one of its properties.
     */
    logout(): Promise<void>;
}

declare class AuthInterceptor {
    private originalFetch;
    private session;
    private maxRetrials;
    private retryDelay;
    constructor(config: Required<AuthConfig>, session: Session);
    /**
     * The Fetch API can receive headers as an object in the format `{ headerKey: headerValue }`, an array with key-value pairs
     * `[[headerKey, headerValue]]` or an instance of the class `Headers`. This function receives any type of headers and normalizes it into
     * an object in the format `{ headerKey: headerValue }`.
     * @param headers the headers to normalize.
     * @returns an object where each entry is composed by a header key and a header value.
     */
    private normalizeHeaders;
    /**
     * Intercepts the request to include the authentication token.
     *
     * @param request the original request
     * @returns the request with the authentication header.
     */
    interceptRequest(request: FetchRequest): Promise<FetchRequest>;
    /**
     * Intercepts the response in order to perform retrials in case of errors.
     *
     * @param response the original response.
     * @param request the request.
     * @param retrials the number of retrials already performed.
     * @returns the retried response.
     */
    interceptResponse(response: Response, request: FetchRequest, retrials?: number): Promise<Response>;
    /**
     * A custom implementation of {@link global.fetch} including authentication and retrials on errors.
     *
     * @param input the URL to the request.
     * @param init the request options.
     * @returns the response.
     */
    fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
}

declare class ThirdPartyClient {
    readonly config: Required<AuthConfig>;
    private readonly tokenClient;
    constructor(config: Required<AuthConfig>, tokenClient: TokenClient);
    private findAuthDataByEmail;
    private buildSearchParams;
    private clearExpiredLoginAttempts;
    /**
     * Performs an authenticated fetch and returns the JSON result.
     */
    private authFetch;
    private isAccountAvailable;
    private createSlug;
    private generateAccount;
    private getUserName;
    private createAccount;
    private refreshToken;
    /**
     * Performs a 3rd party login (first part).
     *
     * This operation happens in two parts, this is the first one and it returns the URL to redirect the user to login.
     * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
     * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
     *
     * @throws
     * - {@link InvalidSSOError}: if the email doesn't correspond to any SSO registered.
     * - {@link AuthMethodUnavailable}: if the 3rd party login is temporally unavailable.
     * - {@link PasswordExpectedError}: if the email address is managed by StackSpot itself and should instead use password login. This
     * exception has the property `tenant`, so it can be catch and redirect the user to the expected login method.
     *
     * @param login parameters to the 3rd party login.
     * @returns the external url to login and the state. The state can be used to identify this login attempt.
     */
    getThirdPartyLoginUrlAndState(login: ThirdPartyLoginParams, data?: unknown): Promise<{
        url: string;
        state: string;
    }>;
    /**
    * Performs a 3rd party login (first part) using the given tenant.
    *
    * This operation happens in two parts, this is the first one and it returns the URL to redirect the user to login.
    * This function does not depend on the user email, instead will use the given tenant to mount the url.
    * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
    * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
    *
    * @param login parameters to the 3rd party login.
    * @param tenant tenant to mount the 3rd party login url.
    * @returns the external url to login and the state. The state can be used to identify this login attempt.
    */
    getThirdPartyLoginFromTenant(login: ThirdPartyLoginParams, tenant: string, data?: unknown): Promise<{
        url: string;
        state: string;
    }>;
    /**
     * Performs a 3rd party login (second and final part).
     *
     * This operation happens in two parts, this is the last one and it returns a SessionPayload.
     * This should be called by whatever is in `config.redirectUrl`. The only parameter it receives must be the query string in the url.
     *
     * If the account is new and PENDING, another service will be called to finish the account creation. If the account creation cannot be
     * completed, it will not fail. Instead, it will try again on the next login while the user has some reduced permissions.
     *
     * @throws
     * - {@link AuthenticationError}: if something goes wrong.
     *
     * @param queryString
     * @returns the session payload, which may be used to create a Session object.
     */
    completeThirdPartyLogin(queryString: string): Promise<{
        sessionData: SessionPayload;
        data?: unknown;
    }>;
    /**
     * List all accounts available for the user of the access token passed as parameter.
     *
     * @throws
     * - {@link AuthenticationError}: if the operation is not allowed.
     *
     * @param accessToken
     * @returns the accounts
     */
    listAccounts(accessToken: string): Promise<Account[]>;
    /**
     * Switches the active account for the user of the access token passed as parameter.
     *
     * @throws
     * - {@link AuthenticationError}: if the operation is not allowed.
     *
     * @param accountId the id of the account to switch to.
     * @param accessToken
     * @returns the tokens linking to the new accont.
     */
    switchAccount(accountId: string, accessToken: string): Promise<AccountTokens>;
}

declare class ThirdPartyObservable<Data = undefined> {
    private listeners;
    private events;
    /**
     * Registers a listener for whenever an error occurs during login.
     * The original error object is passed as a parameter to the listener.
     * @param listener the lister to register.
     * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
     */
    onError(listener: (error: any) => any, runPreviousEvents?: boolean): this;
    /**
     * Register a listener to run when the external login redirects the user back to the application.
     * @param listener the lister to register.
     * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
     */
    onRedirect(listener: () => any, runPreviousEvents?: boolean): this;
    /**
     * Register a listener to run when the login succeeds and a session is created.
     * The new session is passed as a parameter to the listener.
     * If the data parameter was passed to the `startThirdPartyLogin` method, it is provided here as the second parameter.
     * @param listener the lister to register.
     * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
     */
    onSuccess(listener: (session: Session, data: Data) => any, runPreviousEvents?: boolean): this;
    /**
     * Register a listener to run when the url for the external login is obtained.
     * The url is passed as a parameter to the listener.
     * @param listener the lister to register.
     * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
     */
    onUrl(listener: (url: string) => any, runPreviousEvents?: boolean): this;
    /**
     * Triggers a login event.
     * @param event the event to trigger.
     * @param args the arguments expected by the event.
     */
    trigger<T extends ThirdPartyLoginEvent>(event: T, ...args: ThirdPartyLoginEventParams[T]): void;
}

/**
 * LogIn to the StackSpot application and easily manage sessions to make authenticated requests.
 *
 * The optional generic type `<Data>` refers to the extra data needed for third party login. This extra data is passed to the 1st phase of a
 * third party login and recovered on the last phase. An example of this would be a finalRedirect string, to redirect the user at the end of
 * the login process dependending on `data.finalRedirect`, passed at the start of the login.
 *
 * @example
 * ```
 * const auth = new AuthManager({
 *   authUrl: 'https://idm.stackspot.com',
 *   clientId: 'stackspot-portal',
 *   defaultTenant: 'stackspot-freemium',
 *   accountUrl: 'https://account.v1.stackspot.com',
 *   redirectUrl: 'https://stackspot.com/api/auth/callback',
 * })
 * const session = await auth.startSession('password', { username: 'user', password: 'pass' })
 * // you can now make authenticated requests without worrying about authentication!
 * const workspaces = await session.fetch('https://workspace.v1.stackspot.com/v1/workspaces')
 * ```
 */
declare class AuthManager<Data = undefined> {
    readonly config: Required<AuthConfig>;
    readonly tokenClient: TokenClient;
    readonly thirdPartyClient: ThirdPartyClient;
    private thirdPartyLoginAttempts;
    constructor(config: AuthConfig);
    /**
     * Authenticates using one of the authentication methods available.
     *
     * @throws
     * - {@link InvalidTenantError}: if the tenant or the url is invalid (on 404).
     * - {@link InvalidCredentialsError}: if the credentials are invalid.
     * - Plain {@link AuthenticationError}: if the error is unknown.
     *
     * @param url the url to the authentication API.
     * @param method the authentication method.
     * @param credentials the credentials for signing in.
     * @returns the session.
     */
    startSession<T extends CredentialMethod>(method: T, credentials: CredentialOf<T>): Promise<Session>;
    /**
     * Restores a serialized session using `config.sessionPersistence.load`. If there's no session persisted or the persisted session is
     * expired, undefined is returned.
     *
     * @returns the restored session.
     */
    restoreSession(): Promise<Session | undefined>;
    private startObservableThirdPartyLoginAsync;
    /**
     * Performs a 3rd party login (first part).
     *
     * This operation happens in two parts, this is the first one and it returns the url to perform the 3rd party login.
     *
     * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
     *
     * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
     *
     * @throws
     * - {@link InvalidSSOError}: if the email doesn't correspond to any SSO registered.
     * - {@link AuthMethodUnavailable}: if the 3rd party login is temporally unavailable.
     *
     * @param login parameters to the 3rd party login.
     * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
     * @returns the url to perform the 3rd party login.
     */
    startThirdPartyLogin(login: ThirdPartyLoginParams, ...data: Data extends undefined ? [] : [Data]): Promise<string>;
    /**
     * Just like {@link startThirdPartyLogin}. But instead of returning the URL, it returns an observable object that can listen to any
     * login event. A login event is triggered on every step: url generated, redirected to application, success and error.
     *
     * @param login parameters to the 3rd party login.
     * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
     * @returns an observable object that will update whenever a login step succeeds or fails.
     */
    startObservableThirdPartyLogin(login: ThirdPartyLoginParams, ...data: Data extends undefined ? [] : [Data]): ThirdPartyObservable<Data>;
    private completeObservableThirdPartyLoginAsync;
    /**
     * Performs a 3rd party login (second and final part).
     *
     * This operation happens in two parts, this is the last one and it returns a Session.
     * This should be called by whatever is in `config.redirectUrl`. The only parameter it receives must be the query string in the url.
     *
     * @throws
     * - {@link AuthenticationError}: if something goes wrong.
     *
     * @param queryString
     * @returns an object containing the session and the data object passed to the `startThirdPartyLogin` method (if any).
     */
    completeThirdPartyLogin(queryString: string): Promise<ThirdPartyLoginResult<Data>>;
    /**
     * Performs a 3rd party login (first part) using the given tenant
     *
     * This operation happens in two parts, this is the first one and it returns the url to perform the 3rd party login.
     * This function does not use or depend on the user email, instead it will use the given tenant.
     *
     * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
     *
     * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
     *
     * @param login parameters to the 3rd party login.
     * @param tenant parameters the tenant to mount the url.
     * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
     * @returns the url to perform the 3rd party login.
     */
    getThirdPartyLoginFromTenant(login: ThirdPartyLoginParams, tenant: string, ...data: Data extends undefined ? [] : [Data]): Promise<string>;
    /**
     * Just like {@link completeThirdPartyLogin}. But instead of returning a Session, it completes the login for an existing
     * {@link ThirdPartyObservable} instantiated by the function {@link startObservableThirdPartyLogin}.
     *
     * @param queryString.
     */
    completeObservableThirdPartyLogin(queryString: string): void;
    /**
     * List all accounts available for the user of the session passed as parameter.
     *
     * @throws
     * - {@link SessionExpiredError}: if the session passed as parameter is expired.
     * - {@link AuthenticationError}: if the operation is not allowed.
     *
     * @param session
     * @returns the accounts
     */
    listAccounts(session: Session): Promise<Account[]>;
    /**
     * Switches the active account for the user of the session passed as parameter.
     *
     * @throws
     * - {@link SessionExpiredError}: if the session passed as parameter is expired.
     * - {@link AuthenticationError}: if the operation is not allowed.
     *
     * @param accountId the id of the account to switch to.
     * @param accessToken
     * @returns the tokens linking to the new accont.
     */
    switchAccount(accountId: string, session: Session): Promise<void>;
}

declare class AuthenticationError extends Error {
    constructor(message: string);
}
declare class ConnectionError extends AuthenticationError {
    constructor();
}
declare class SessionExpiredError extends AuthenticationError {
    constructor();
}
declare class MalFormedAccessToken extends AuthenticationError {
    token: string;
    constructor(token: string, cause: any);
}
declare class InvalidTenantError extends AuthenticationError {
    tenant: string;
    constructor(tenant: string);
}
declare class InvalidCredentialsError extends AuthenticationError {
    constructor(status: number, method: CredentialMethod, tenant: string, description: string | undefined);
}
declare class InvalidSSOError extends AuthenticationError {
    constructor();
}
declare class InvalidProvider extends AuthenticationError {
    constructor();
}
declare class AuthMethodUnavailable extends AuthenticationError {
    constructor(causes?: (string | undefined | number)[]);
}
declare class LogoutError extends Error {
    readonly response: Response;
    constructor(response: Response);
}
declare class NetworkError extends Error {
    readonly response: Response;
    private constructor();
    static create(response: Response): Promise<NetworkError>;
}

export { AccessTokenPayload, Account, AuthConfig, AuthInterceptor, AuthManager, AuthMethodUnavailable, AuthenticationError, ConnectionError, CredentialMethod, InvalidCredentialsError, InvalidProvider, InvalidSSOError, InvalidTenantError, LogoutError, MalFormedAccessToken, NetworkError, Session, SessionExpiredError, SessionPayload, SessionPersistence, ThirdPartyAuthType, ThirdPartyClient, ThirdPartyLoginParams, ThirdPartyObservable, ThirdPartyProvider, TokenClient };
