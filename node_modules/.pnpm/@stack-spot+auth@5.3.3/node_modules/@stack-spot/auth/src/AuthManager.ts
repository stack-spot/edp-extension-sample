import { Session } from './Session'
import { ThirdPartyClient } from './ThirdPartyClient'
import { TokenClient } from './TokenClient'
import {
  Account, AuthConfig, CredentialMethod, CredentialOf,
  ThirdPartyAuthResponse, ThirdPartyLoginParams, ThirdPartyLoginResult
} from './types'
// the following imports are used by the ts-docs, don't remove.
/* eslint-disable @typescript-eslint/no-unused-vars */
import { MemoryStorage } from './MemoryStorage'
import { ThirdPartyObservable } from './ThirdPartyObservable'
import {
  AuthMethodUnavailable,
  AuthenticationError,
  InvalidCredentialsError,
  InvalidSSOError,
  InvalidTenantError,
  SessionExpiredError,
} from './error'
import { queryStringToObject } from './utils'


/**
 * LogIn to the StackSpot application and easily manage sessions to make authenticated requests.
 * 
 * The optional generic type `<Data>` refers to the extra data needed for third party login. This extra data is passed to the 1st phase of a
 * third party login and recovered on the last phase. An example of this would be a finalRedirect string, to redirect the user at the end of
 * the login process dependending on `data.finalRedirect`, passed at the start of the login.
 * 
 * @example
 * ```
 * const auth = new AuthManager({
 *   authUrl: 'https://idm.stackspot.com',
 *   clientId: 'stackspot-portal',
 *   defaultTenant: 'stackspot-freemium',
 *   accountUrl: 'https://account.v1.stackspot.com',
 *   redirectUrl: 'https://stackspot.com/api/auth/callback',
 * })
 * const session = await auth.startSession('password', { username: 'user', password: 'pass' })
 * // you can now make authenticated requests without worrying about authentication!
 * const workspaces = await session.fetch('https://workspace.v1.stackspot.com/v1/workspaces')
 * ```
 */
export class AuthManager<Data = undefined> {
  readonly config: Required<AuthConfig>
  readonly tokenClient: TokenClient
  readonly thirdPartyClient: ThirdPartyClient
  private thirdPartyLoginAttempts: Map<string, ThirdPartyObservable<Data>> = new Map()

  constructor(config: AuthConfig) {
    this.config = {
      ...config,
      fetch: config.fetch ?? ((...args) => window.fetch.apply(window, args)),
      storage: config.storage ?? new MemoryStorage(),
      retry: config.retry ?? 1,
      retryDelay: config.retryDelay ?? 500,
      sessionPersistence: config.sessionPersistence ?? null,
    }
    if (!this.config.fetch) {
      throw new Error(
        "This platform doesn't have a global implementation of the fetch function. Please, provide an implementation in you configuration.",
      )
    }
    this.tokenClient = new TokenClient(this.config)
    this.thirdPartyClient = new ThirdPartyClient(this.config, this.tokenClient)
  }

  /**
   * Authenticates using one of the authentication methods available.
   * 
   * @throws
   * - {@link InvalidTenantError}: if the tenant or the url is invalid (on 404).
   * - {@link InvalidCredentialsError}: if the credentials are invalid.
   * - Plain {@link AuthenticationError}: if the error is unknown.
   * 
   * @param url the url to the authentication API.
   * @param method the authentication method.
   * @param credentials the credentials for signing in.
   * @returns the session.
   */
  async startSession<T extends CredentialMethod>(method: T, credentials: CredentialOf<T>): Promise<Session> {
    const sessionData = await this.tokenClient.authenticate(method, credentials)
    return new Session(sessionData, this.config, this.tokenClient)
  }

  /**
   * Restores a serialized session using `config.sessionPersistence.load`. If there's no session persisted or the persisted session is
   * expired, undefined is returned.
   * 
   * @returns the restored session.
   */
  async restoreSession(): Promise<Session | undefined> {
    try {
      const restored = await this.config.sessionPersistence?.load()
      const session = restored ? Session.fromSerializedSession(restored, this.config, this.tokenClient) : undefined
      if (session && !session.isExpired()) return session
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error(error)
    }
  }

  private async startObservableThirdPartyLoginAsync(
    login: ThirdPartyLoginParams,
    observable: ThirdPartyObservable<Data>,
    data?: Data,
  ): Promise<void> {
    try {
      const { url, state } = await this.thirdPartyClient.getThirdPartyLoginUrlAndState(login, data)
      this.thirdPartyLoginAttempts.set(state, observable)
      observable.onSuccess(() => this.thirdPartyLoginAttempts.delete(state))
      observable.trigger('url', url)
    } catch (error: any) {
      observable.trigger('error', error)
    }
  }

  /**
   * Performs a 3rd party login (first part).
   * 
   * This operation happens in two parts, this is the first one and it returns the url to perform the 3rd party login.
   * 
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * 
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   * 
   * @throws
   * - {@link InvalidSSOError}: if the email doesn't correspond to any SSO registered.
   * - {@link AuthMethodUnavailable}: if the 3rd party login is temporally unavailable.
   * 
   * @param login parameters to the 3rd party login.
   * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
   * @returns the url to perform the 3rd party login.
   */
  async startThirdPartyLogin(login: ThirdPartyLoginParams, ...data: Data extends undefined ? [] : [Data]): Promise<string> {
    const { url } = await this.thirdPartyClient.getThirdPartyLoginUrlAndState(login, data[0])
    return url
  }

  /**
   * Just like {@link startThirdPartyLogin}. But instead of returning the URL, it returns an observable object that can listen to any
   * login event. A login event is triggered on every step: url generated, redirected to application, success and error.
   * 
   * @param login parameters to the 3rd party login.
   * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
   * @returns an observable object that will update whenever a login step succeeds or fails.
   */
  startObservableThirdPartyLogin(login: ThirdPartyLoginParams, ...data: Data extends undefined ? [] : [Data]): ThirdPartyObservable<Data> {
    const observable = new ThirdPartyObservable<Data>()
    this.startObservableThirdPartyLoginAsync(login, observable, data[0])
    return observable
  }

  private async completeObservableThirdPartyLoginAsync(queryString: string) {
    const { state } = queryStringToObject<ThirdPartyAuthResponse>(queryString)
    const observable = this.thirdPartyLoginAttempts.get(state)
    if (!observable) throw new Error('Login attempt not found. This is a bug, please contact the team.')
    observable.trigger('redirect')
    try {
      const { sessionData, data } = await this.thirdPartyClient.completeThirdPartyLogin(queryString)
      const session = new Session(sessionData, this.config, this.tokenClient)
      observable.trigger('success', session, data)
    } catch (error: any) {
      observable.trigger('error', error)
    }
  }

  /**
   * Performs a 3rd party login (second and final part).
   * 
   * This operation happens in two parts, this is the last one and it returns a Session.
   * This should be called by whatever is in `config.redirectUrl`. The only parameter it receives must be the query string in the url.
   * 
   * @throws
   * - {@link AuthenticationError}: if something goes wrong.
   * 
   * @param queryString 
   * @returns an object containing the session and the data object passed to the `startThirdPartyLogin` method (if any).
   */
  async completeThirdPartyLogin(queryString: string): Promise<ThirdPartyLoginResult<Data>> {
    const { sessionData, data } = await this.thirdPartyClient.completeThirdPartyLogin(queryString)
    const session = new Session(sessionData, this.config, this.tokenClient)
    return { session, data: data as Data }
  }
  
  /**
   * Performs a 3rd party login (first part) using the given tenant
   * 
   * This operation happens in two parts, this is the first one and it returns the url to perform the 3rd party login.
   * This function does not use or depend on the user email, instead it will use the given tenant.
   * 
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * 
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   *
   * @param login parameters to the 3rd party login.
   * @param tenant parameters the tenant to mount the url.
   * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
   * @returns the url to perform the 3rd party login.
   */
  async getThirdPartyLoginFromTenant(login: ThirdPartyLoginParams, tenant: string, ...data: Data extends undefined ? [] : [Data]):  Promise<string> {
    const {url} = await this.thirdPartyClient.getThirdPartyLoginFromTenant(login, tenant, data[0])
    return url
  }

  /**
   * Just like {@link completeThirdPartyLogin}. But instead of returning a Session, it completes the login for an existing
   * {@link ThirdPartyObservable} instantiated by the function {@link startObservableThirdPartyLogin}.
   * 
   * @param queryString.
   */
  completeObservableThirdPartyLogin(queryString: string): void {
    this.completeObservableThirdPartyLoginAsync(queryString)
  }

  /**
   * List all accounts available for the user of the session passed as parameter.
   * 
   * @throws
   * - {@link SessionExpiredError}: if the session passed as parameter is expired.
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param session 
   * @returns the accounts
   */
  async listAccounts(session: Session): Promise<Account[]> {
    if (session.isExpired()) throw new SessionExpiredError()
    const token = await session.getToken()
    return this.thirdPartyClient.listAccounts(token)
  }

  /**
   * Switches the active account for the user of the session passed as parameter.
   * 
   * @throws
   * - {@link SessionExpiredError}: if the session passed as parameter is expired.
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param accountId the id of the account to switch to.
   * @param accessToken 
   * @returns the tokens linking to the new accont.
   */
  async switchAccount(accountId: string, session: Session): Promise<void> {
    if (session.isExpired()) throw new SessionExpiredError()
    const token = await session.getToken()
    const sessionData = await this.thirdPartyClient.switchAccount(accountId, token)
    session.updateSessionData(sessionData)
  }
}
