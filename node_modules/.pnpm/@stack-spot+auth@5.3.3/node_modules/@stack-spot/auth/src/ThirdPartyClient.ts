/* eslint-disable no-console */
import { deburr } from 'lodash'
import { generators } from './openid'
import {
  AccessTokenPayload,
  AuthConfig,
  AccountParams,
  SessionPayload,
  ThirdPartyAuthData,
  ThirdPartyAuthRequest,
  ThirdPartyAuthResponse,
  ThirdPartyLoginParams,
  Account,
  AccountTokens,
} from './types'
import { AuthMethodUnavailable, AuthenticationError, InvalidSSOError, NetworkError } from './error'
import { printResponseError, queryStringToObject, randomizeNumericString, randomizeString } from './utils'
import { TokenClient } from './TokenClient'
import { jwtToAccessTokenPayload } from './Session'

// maximum number of attempts to generate a unique account before resorting to a random string as the account slug.
const MAX_ATTEMPTS_TO_GENERATE_ACCOUNT = 5

interface StorageData {
  codeVerifier: string,
  tenant: string,
  createdAt: number,
  data?: unknown,
}

const storageKeyPrefix = 'stackSpotAuth.thirdPartyLogin.'
// Maximum time to finish a 3rd party login
const maxLoginTimeMs = 24 * 60 * 60 * 1000 // 24 hours

function buildPKCE() {
  const codeVerifier = generators.codeVerifier()
  return {
    state: generators.state(),
    codeVerifier,
    codeChallenge: generators.codeChallenge(codeVerifier),
  }
}

function buildStorageKey(state: string) {
  return `${storageKeyPrefix}${state}`
}

export class ThirdPartyClient {
  readonly config: Required<AuthConfig>
  private readonly tokenClient: TokenClient

  constructor(config: Required<AuthConfig>, tokenClient: TokenClient) {
    this.config = config
    this.tokenClient = tokenClient
  }

  private async findAuthDataByEmail(email: string): Promise<ThirdPartyAuthData> {
    const url = `${this.config.accountUrl}/v1/accounts?email=${encodeURIComponent(email)}`
    const response = await this.config.fetch(url)
    if (response.ok) {
      const { tenant, idp, accountType, iamTenant } = await response.json() as Record<string, any>
      if (!tenant) throw new InvalidSSOError()
      return { tenant, idp, accountType, iamTenant }
    }
    printResponseError(response)
    let errorCode: string | undefined
    try {
      errorCode = (await response.json()).code
    } catch { }
    throw errorCode === 'ACC_ACCOUNT_NOT_FOUND_ERROR'
      ? new InvalidSSOError()
      : new AuthMethodUnavailable([response.statusText, response.status, errorCode])
  }

  private buildSearchParams({ codeChallenge, state, email, locale }: ThirdPartyAuthRequest) {
    const params: Record<string, string> = {
      state,
      client_id: this.config.clientId,
      redirect_uri: this.config.redirectUrl,
      response_type: 'code',
      scope: 'openid email offline_access profile attributes roles',
      code_challenge: codeChallenge,
      code_challenge_method: 'S256',
      ui_locales: locale || 'en',
    }

    if (email) { params.login_hint = email }

    return new URLSearchParams(params)
  }

  private clearExpiredLoginAttempts() {
    const st = this.config.storage
    for (let i = 0; i < st.length; i++) {
      const key = st.key(i)
      if (key?.startsWith(storageKeyPrefix)) {
        const data: StorageData = JSON.parse(st.getItem(key) ?? '{}')
        if (Date.now() - data.createdAt > maxLoginTimeMs) st.removeItem(key)
      }
    }
  }

  /**
   * Performs an authenticated fetch and returns the JSON result.
   */
  private async authFetch(input: RequestInfo | URL, token: string, init?: RequestInit) {
    const headers = { ...init?.headers, authorization: `Bearer ${token}`, 'content-type': 'application/json; charset=utf-8' }
    const response = await this.config.fetch(input, { ...init, headers })
    if (!response.ok) throw await NetworkError.create(response)
    return response.json()
  }

  private async isAccountAvailable(acc: AccountParams, accessToken: string): Promise<boolean> {
    const params = new URLSearchParams(acc as unknown as Record<string, string>)
    const url = `${this.config.accountUrl}/v1/accounts/freemium/available?${params}`
    try {
      const { available } = await this.authFetch(url, accessToken)
      return available ?? false
    } catch (error: any) {
      console.error('Error while validating account name and slug. Cause:', error.message ?? error)
    }
    return false
  }

  private createSlug(name: string) {
    return deburr(name)
      .toLowerCase()
      .replaceAll(/^-+|-+$/g, '')
      .replace(/ /g, '-')
      .replace(/(-)+/g, '-')
      .replace(/[^a-z-\d]/g, '')
      .substring(0, 60)
  }

  private async generateAccount(
    accessToken: string,
    name?: string,
    remainingAttempts = MAX_ATTEMPTS_TO_GENERATE_ACCOUNT,
  ): Promise<AccountParams> {
    if (remainingAttempts === 0 || !name) {
      const name = randomizeString(20)
      return { name, slug: name }
    }
    const suffix = remainingAttempts === MAX_ATTEMPTS_TO_GENERATE_ACCOUNT ? undefined : randomizeNumericString(4)
    name = suffix ? `${name} ${suffix}` : name
    const acc = { name, slug: this.createSlug(name) }
    const available = await this.isAccountAvailable(acc, accessToken)
    return available ? acc : this.generateAccount(accessToken, name, remainingAttempts - 1)
  }

  private getUserName({ name, given_name, family_name, preferred_username, email }: AccessTokenPayload) {
    return name
      ?? (given_name && family_name ? `${given_name} ${family_name}` : undefined)
      ?? email
      ?? preferred_username
      ?? given_name
      ?? family_name
  }

  private async createAccount(accessToken: string): Promise<boolean> {
    const data = jwtToAccessTokenPayload(accessToken)
    if (data.freemium_status === 'PENDING') {
      const url = `${this.config.accountUrl}/v1/accounts/freemium`
      const acc = await this.generateAccount(accessToken, this.getUserName(data))
      try {
        await this.authFetch(url, accessToken, { method: 'post', body: JSON.stringify(acc) })
      } catch (error: any) {
        console.error(
          'It was not possible to complete the account creation. The user will be able to use some features, but not all. A new attempt will be made in the next login. Cause:',
          error.message ?? error,
        )
      }
      /* we return true despite the error because the API will always fail with status 500 in Sandbox and QA. In spite of the failure, the
      account will be created. */
      return true
    }
    return false
  }

  private async refreshToken(session: SessionPayload): Promise<SessionPayload> {
    try {
      return this.tokenClient.authenticate(
        'refreshToken',
        { refreshToken: session.refresh_token, clientId: session.client_id, tenant: session.tenant },
      )
    } catch (error: any) {
      console.error(
        'Could not refresh token after account creation. Permissions will be reduced during this session. Cause:',
        error.message ?? error,
      )
      return session
    }
  }

  /**
   * Performs a 3rd party login (first part).
   * 
   * This operation happens in two parts, this is the first one and it returns the URL to redirect the user to login.
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   * 
   * @throws
   * - {@link InvalidSSOError}: if the email doesn't correspond to any SSO registered.
   * - {@link AuthMethodUnavailable}: if the 3rd party login is temporally unavailable.
   * - {@link PasswordExpectedError}: if the email address is managed by StackSpot itself and should instead use password login. This
   * exception has the property `tenant`, so it can be catch and redirect the user to the expected login method.
   * 
   * @param login parameters to the 3rd party login.
   * @returns the external url to login and the state. The state can be used to identify this login attempt.
   */
  async getThirdPartyLoginUrlAndState(login: ThirdPartyLoginParams, data?: unknown): Promise<{ url: string, state: string }> {
    this.clearExpiredLoginAttempts()
    const { idp, iamTenant = '' } = login.type === 'sso' ? await this.findAuthDataByEmail(login.email)
      : {
        idp: login.provider,
        iamTenant: this.config.defaultTenant
      }

    const path = `${iamTenant}/oidc/auth`
    const { codeVerifier, codeChallenge, state } = buildPKCE()
    const storageData: StorageData = {
      codeVerifier,
      tenant: iamTenant,
      createdAt: Date.now(),
      data,
    }
    this.config.storage.setItem(buildStorageKey(state), JSON.stringify(storageData))
    const params = this.buildSearchParams({
      codeChallenge,
      state,
      email: login.type === 'sso' ? login.email : undefined,
      idp,
      locale: login.locale,
    })
    return { url: `${this.config.authUrl}/${path}?${params}`, state }
  }

   /**
   * Performs a 3rd party login (first part) using the given tenant.
   * 
   * This operation happens in two parts, this is the first one and it returns the URL to redirect the user to login.
   * This function does not depend on the user email, instead will use the given tenant to mount the url.
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   * 
   * @param login parameters to the 3rd party login.
   * @param tenant tenant to mount the 3rd party login url.
   * @returns the external url to login and the state. The state can be used to identify this login attempt.
   */
  async getThirdPartyLoginFromTenant(login: ThirdPartyLoginParams, tenant: string, data?: unknown): Promise<{ url: string, state: string }> {
    this.clearExpiredLoginAttempts()
    const { idp, iamTenant = '' } = login.type === 'sso' ? {iamTenant: tenant, idp: undefined}
      : {
        idp: login.provider,
        iamTenant: this.config.defaultTenant
      }

    const path = `${iamTenant}/oidc/auth`
    const { codeVerifier, codeChallenge, state } = buildPKCE()
    const storageData: StorageData = {
      codeVerifier,
      tenant: iamTenant,
      createdAt: Date.now(),
      data,
    }
    this.config.storage.setItem(buildStorageKey(state), JSON.stringify(storageData))
    const params = this.buildSearchParams({
      codeChallenge,
      state,
      email: login.type === 'sso' ? login.email : undefined,
      idp,
      locale: login.locale,
    })
    return { url: `${this.config.authUrl}/${path}?${params}`, state }
  }

  /**
   * Performs a 3rd party login (second and final part).
   * 
   * This operation happens in two parts, this is the last one and it returns a SessionPayload.
   * This should be called by whatever is in `config.redirectUrl`. The only parameter it receives must be the query string in the url.
   * 
   * If the account is new and PENDING, another service will be called to finish the account creation. If the account creation cannot be
   * completed, it will not fail. Instead, it will try again on the next login while the user has some reduced permissions.
   * 
   * @throws
   * - {@link AuthenticationError}: if something goes wrong.
   * 
   * @param queryString 
   * @returns the session payload, which may be used to create a Session object.
   */
  async completeThirdPartyLogin(queryString: string): Promise<{ sessionData: SessionPayload, data?: unknown }> {
    const queryObject = queryStringToObject(queryString)
    if (queryObject.error) {
      throw new AuthenticationError(`${queryObject.error}. ${decodeURIComponent(queryObject.error_description)}.`)
    }
    const { code, state } = queryObject as unknown as ThirdPartyAuthResponse
    const storageKey = buildStorageKey(state)
    const fromStorage = this.config.storage.getItem(storageKey)
    const { codeVerifier, tenant, data }: Partial<StorageData> = fromStorage ? JSON.parse(fromStorage) : {}
    this.config.storage.removeItem(storageKey)
    if (!codeVerifier || !tenant) throw new AuthenticationError('Not enough data to perform 3rd party login.')
    const sessionData = await this.tokenClient.authenticate('authorizationCode', { code, tenant, codeVerifier })
    const hasAccountBeenCreated = await this.createAccount(sessionData.access_token)
    const finalSessionData = hasAccountBeenCreated ? await this.refreshToken(sessionData) : sessionData
    return { sessionData: finalSessionData, data }
  }

  /**
   * List all accounts available for the user of the access token passed as parameter.
   * 
   * @throws
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param accessToken 
   * @returns the accounts
   */
  listAccounts(accessToken: string): Promise<Account[]> {
    const url = `${this.config.accountUrl}/v1/users/accounts`
    try {
      return this.authFetch(url, accessToken)
    } catch (error) {
      if (error instanceof NetworkError && [401, 403].includes(error.response.status)) {
        throw new AuthenticationError(`You are not allowed to list accounts. Check the error below for more details:\n${error.message}`)
      }
      throw error
    }
  }

  /**
   * Switches the active account for the user of the access token passed as parameter.
   * 
   * @throws
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param accountId the id of the account to switch to.
   * @param accessToken 
   * @returns the tokens linking to the new accont.
   */
  switchAccount(accountId: string, accessToken: string): Promise<AccountTokens> {
    const url = `${this.config.accountUrl}/v1/authentication/switch-account`
    try {
      return this.authFetch(url, accessToken, { method: 'post', body: JSON.stringify({ accountId }) })
    } catch (error) {
      if (error instanceof NetworkError && [401, 403].includes(error.response.status)) {
        throw new AuthenticationError(
          `You are not allowed to switch to this account. Check the error below for more details:\n${error.message}`,
        )
      }
      throw error
    }
  }
}
