import { JWTPayload } from 'jose'
import { Session } from './Session'

export interface SessionPersistence {
  save: (session: string) => void | Promise<void>,
  load: () => string | undefined | null | Promise<string | undefined | null>,
}

export interface AuthConfig {
  /**
   * The URL to the authentication API. e.g. STK-IAM.
   */
  readonly authUrl: string,
  /**
   * The default client id to perform an authentication.
   * This will be used whenever `clientId` is not provided when calling an authentication function.
   */
  readonly clientId: string,
  /**
   * The default tenant to perform an authentication.
   * This will be used whenever `tenant` is not provided when calling an authentication function.
   */
  readonly defaultTenant: string,
  /**
   * The URL to the account API of StackSpot.
   * This is used to retrieve the tenant when performing third-party SSO authentication.
   */
  readonly accountUrl: string,
  /**
   * The URL to redirect to when performing third-party authentication.
   */
  readonly redirectUrl: string,
  /**
   * The fetch function to be used by this library. Must respect the specifications of {@link global.fetch}.
   * If not provided, `global.fetch` will be used.
   * 
   * Attention: an error will be throw if not provided and on a platform where `global.fetch` is not available, e.g. Node. 
   * @default global.fetch
   */
  readonly fetch?: typeof fetch,
  /**
   * A storage to place data from third-party login. This will be an in-memory storage by default.
   * 
   * If your login flow replaces the current view with an external site, then the default in-memory storage won't work and you should
   * provide something like the localStorage.
   * 
   * @default
   * {@link MemoryStorage}
   */
  readonly storage?: Pick<Storage, 'clear' | 'getItem' | 'key' | 'removeItem' | 'setItem' | 'length'>,
  /**
   * Number of retries when a request fails.
   * @default 1
   */
  readonly retry?: number,
  /**
   * Milliseconds to wait before retrying a failed request.
   * @default 500
   */
  readonly retryDelay?: number,
  /**
   * A way to persist sessions across multiple executions, concurrent or not.
   * 
   * If not provided, the session will be valid only for this single execution.
   * 
   * @example
   * localStorage (browser):
   * ```
   * {
   *   save: (session) => localStorage.set('session', session),
   *   load: () => localStorage.get('session')
   * }
   * ```
   */
  readonly sessionPersistence?: SessionPersistence | null,
}

export interface SessionPayload {
  readonly access_token: string,
  /**
   * seconds
   */
  readonly expires_in: number,
  /**
   * seconds
   */
  readonly refresh_expires_in: number,
  readonly refresh_token: string,
  readonly id_token: string,
  readonly token_type: string,
  readonly 'not-before-policy': number,
  readonly session_state: string,
  readonly scope: string,
  readonly tenant: string,
  readonly client_id: string,
  readonly is_iam_migrated: boolean,
}

export interface AccessTokenPayload extends JWTPayload {
  readonly account_name?: string,
  readonly name?: string,
  readonly tenant?: string,
  readonly preferred_username?: string,
  readonly given_name?: string,
  readonly family_name?: string,
  readonly email?: string,
  readonly freemium_status?: 'FINALIZED' | 'PENDING',
  readonly account_id_v2?: string,
  readonly account_type?: 'ENTERPRISE' | 'FREEMIUM',
}

export interface AuthenticationErrorPayload {
  error: string,
  error_description: string,
}

export interface Credentials {
  tenant?: string,
  clientId?: string,
}

interface PasswordCredentials extends Credentials {
  username: string,
  password: string,
}

interface ClientCredentials extends Credentials {
  clientSecret: string,
}

interface RefreshTokenCredentials extends Credentials {
  refreshToken: string,
}

interface AuthorizationCodeCredentials extends Credentials {
  code: string,
  codeVerifier: string,
}

export type CredentialMethod = 'password' | 'client' | 'refreshToken' | 'authorizationCode'

export type CredentialOf<T extends CredentialMethod> = T extends 'password'
  ? PasswordCredentials
  : T extends 'client'
  ? ClientCredentials
  : T extends 'refreshToken'
  ? RefreshTokenCredentials
  : T extends 'authorizationCode'
  ? AuthorizationCodeCredentials
  : never

export interface ThirdPartyAuthRequest {
  state: string,
  codeChallenge: string,
  idp?: string,
  email?: string,
  locale?: 'pt' | 'en'
}

export interface ThirdPartyAuthResponse {
  code: string,
  session_state: string,
  state: string,
}

export interface ThirdPartyAuthData {
  tenant: string,
  idp?: string,
  accountType: string,
  iamTenant?: string,
}

export type ThirdPartyAuthType = 'sso' | 'idp'
export type ThirdPartyProvider = 'external-idp:github'

interface BaseThirdPartyLoginParams {
  type: ThirdPartyAuthType,
  locale?: 'pt' | 'en'
}

interface SSOLoginParams extends BaseThirdPartyLoginParams {
  type: 'sso',
  email: string,
}

interface IDPLoginParams extends BaseThirdPartyLoginParams {
  type: 'idp',
  provider: ThirdPartyProvider,
}

export type ThirdPartyLoginParams = SSOLoginParams | IDPLoginParams

export interface FetchRequest {
  url: URL | RequestInfo,
  init?: RequestInit,
}

export type ThirdPartyLoginEvent = 'url' | 'redirect' | 'success' | 'error'

export interface ThirdPartyLoginEventParams extends Record<ThirdPartyLoginEvent, any[]> {
  url: [string],
  redirect: [],
  success: [Session, any],
  error: [any],
}

export interface AccountParams {
  name: string,
  slug: string,
}

export interface ThirdPartyLoginResult<T = undefined> {
  session: Session,
  data: T,
}

export interface Account {
  id: string,
  name: string,
  tenant: string,
  slug: string,
  roleType: string,
}

export interface AccountTokens {
  access_token: string,
  refresh_token: string,
  token_type: string,
  expires_in: 0,
}
