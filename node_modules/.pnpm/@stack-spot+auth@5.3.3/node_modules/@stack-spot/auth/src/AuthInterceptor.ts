import { omitBy } from 'lodash'
import { Session } from './Session'
import { AuthConfig, FetchRequest } from './types'

export class AuthInterceptor {
  private originalFetch: typeof fetch
  private session: Session
  private maxRetrials: number
  private retryDelay: number

  constructor(config: Required<AuthConfig>, session: Session) {
    this.originalFetch = config.fetch
    this.session = session
    this.maxRetrials = config.retry
    this.retryDelay = config.retryDelay
  }

  /**
   * The Fetch API can receive headers as an object in the format `{ headerKey: headerValue }`, an array with key-value pairs
   * `[[headerKey, headerValue]]` or an instance of the class `Headers`. This function receives any type of headers and normalizes it into
   * an object in the format `{ headerKey: headerValue }`.
   * @param headers the headers to normalize.
   * @returns an object where each entry is composed by a header key and a header value.
   */
  private normalizeHeaders(headers?: HeadersInit): Record<string, string> | undefined {
    // we use a try-catch here to not break the application if running inside an environment that doesn't support the class `Headers`.
    try {
      if (headers instanceof Headers) {
        const record: Record<string, string> = {}
        headers.forEach((value, key) => record[key] = value)
        return record
      }
    } catch { /* empty */ }
    if (Array.isArray(headers)) {
      return headers.reduce<Record<string, string>>((result, [key, value]) => ({ ...result, [key]: value }), {})
    }
    return headers as Record<string, string>
  } 

  /**
   * Intercepts the request to include the authentication token.
   * 
   * @param request the original request
   * @returns the request with the authentication header.
   */
  async interceptRequest(request: FetchRequest): Promise<FetchRequest> {
    const token = await this.session.getToken()
    const headers = omitBy(this.normalizeHeaders(request.init?.headers), (_, key) => key.toLowerCase() === 'authorization')
    const init = {
      ...request.init,
      headers: { 
        ...headers,
        authorization: `Bearer ${token}`,
      },
    } as RequestInit
    return { url: request.url, init }
  }

  /**
   * Intercepts the response in order to perform retrials in case of errors.
   * 
   * @param response the original response.
   * @param request the request.
   * @param retrials the number of retrials already performed.
   * @returns the retried response.
   */
  async interceptResponse(response: Response, request: FetchRequest, retrials = 0): Promise<Response> {
    if (response.ok || retrials >= this.maxRetrials || request.init?.signal?.aborted) return response
    await new Promise<void>((resolve) => {
      const timeout = setTimeout(resolve, this.retryDelay)
      request.init?.signal?.addEventListener('abort', () => {
        clearTimeout(timeout)
        resolve()
      })
    })
    if (request.init?.signal?.aborted) return response
    const newRequest = await this.interceptRequest(request)
    const newResponse = await this.originalFetch(newRequest.url, newRequest.init)
    return this.interceptResponse(newResponse, request, retrials + 1)
  }

  /**
   * A custom implementation of {@link global.fetch} including authentication and retrials on errors.
   * 
   * @param input the URL to the request.
   * @param init the request options.
   * @returns the response.
   */
  async fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
    const request = await this.interceptRequest({ init, url: input })
    const response = await this.originalFetch(request.url, request.init)
    return this.interceptResponse(response, request)
  }
}
