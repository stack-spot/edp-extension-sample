import { map, snakeCase } from 'lodash'
import { AuthenticationError, ConnectionError, InvalidCredentialsError, InvalidTenantError, LogoutError } from './error'
import { AuthConfig, AuthenticationErrorPayload, CredentialMethod, CredentialOf, SessionPayload } from './types'

async function buildError(method: CredentialMethod, tenant: string, response: Response): Promise<AuthenticationError> {
  if (response.status === 404) return new InvalidTenantError(tenant)
  let errorMessage: string | undefined = undefined
  try {
    const errorData = await response.json() as AuthenticationErrorPayload
    errorMessage = errorData.error_description
    errorMessage ||= await response.text()
  } catch { }
  return [400, 401, 403].includes(response.status)
    ? new InvalidCredentialsError(response.status, method, tenant, errorMessage)
    : new AuthenticationError(errorMessage ?? response.statusText ?? 'Unknown error.')
}

const credentialMethodToGrantType: Record<CredentialMethod, string> = {
  password: 'password',
  client: 'client_credentials',
  refreshToken: 'refresh_token',
  authorizationCode: 'authorization_code',
}

export class TokenClient {
  readonly config: Required<AuthConfig>

  constructor(config: Required<AuthConfig>) {
    this.config = config
  }

  /**
   * Authenticates using one of the authentication methods available.
   * 
   * This throws an AuthenticationError on errors:
   * - {@link InvalidTenantError}: if the tenant or the url is invalid (on 404).
   * - {@link InvalidCredentialsError}: if the credentials are invalid.
   * - Plain {@link AuthenticationError}: if the error is unknown.
   * 
   * @param url the url to the authentication API.
   * @param method the authentication method.
   * @param credentials the credentials for signing in.
   * @returns the session data. You can use it to create an instance of Session.
   * @throws AuthenticationError
   */
  async authenticate<T extends CredentialMethod>(
    method: T,
    { tenant = this.config.defaultTenant, clientId = this.config.clientId, ...credentials }: CredentialOf<T>,
  ): Promise<SessionPayload> {
    const encoded = map(
      { ...credentials, clientId, grantType: credentialMethodToGrantType[method], redirectUri: this.config.redirectUrl },
      (value, key) => `${snakeCase(key)}=${encodeURIComponent(`${value}`)}`,
    ).join('&')

    let response
    try {
      response = await this.config.fetch(`${this.config.authUrl}/${encodeURIComponent(tenant)}/oidc/oauth/token`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: encoded,
        },
      )
    } catch {
      // By itself, fetch will only throw an error if there is a network-level issue (e.g., no internet connection, DNS failure, or the request is blocked by CORS).
      throw new ConnectionError()
    }

    if (!response.ok) throw await buildError(method, tenant, response)

    try {
      const sessionData = await response.json()
      return { ...sessionData, client_id: clientId, tenant }
    } catch {
      throw new AuthenticationError(
        'There was an error while deserializing the body of the authentication response.'
      )
    }

  }

  /**
   * Logs out from Stk Iam.
   * @throws
   * - {@link LogoutError} if the logout fails. This error has the original response as one of its properties.
   * @param the session data to log out 
   */
  async logout({
    tenant,
    id_token,
  }: Pick<SessionPayload, 'tenant' | 'id_token'>) {
    const logoutUrl = `${this.config.authUrl}/${tenant}/oidc/end_session`
    const params = new URLSearchParams({ id_token_hint: id_token })

    const response = await this.config.fetch(`${logoutUrl}?${params}`, {
    })

    if (!response.ok) throw new LogoutError(response)
  }
}
