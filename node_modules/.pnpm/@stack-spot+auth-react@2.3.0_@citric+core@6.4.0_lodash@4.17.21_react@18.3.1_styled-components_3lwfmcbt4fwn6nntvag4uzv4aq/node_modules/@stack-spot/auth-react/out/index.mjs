import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { Text, Input, Button, IconBox, Flex } from '@citric/core';
import { BannerWarning, getCookieDomain, setCookie, getCookie, removeCookie, useEffectOnce } from '@stack-spot/portal-components';
import { theme, CSSToCitricAdapter } from '@stack-spot/portal-theme';
import '@stack-spot/portal-theme/dist/theme.css';
import { useTranslate, useLanguage } from '@stack-spot/portal-translate';
import { useState, useEffect } from 'react';
import { Github } from '@citric/icons';
import { LoadingCircular } from '@citric/ui';
import { MiniLogo } from '@stack-spot/portal-components/svg';
import { styled } from 'styled-components';
import { AuthManager } from '@stack-spot/auth';

const LoginBox = styled.form`
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 24px;

  header {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 24px;
  }

  .title {
    font-size: 1rem;
  }

  .separator {
    padding: 0 8px;
    background-color: ${theme.color.light["300"]};
    color: ${theme.color.light["700"]};
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 20px;
    margin: 0;

    &:before, &:after {
      content: '';
      height: 1px;
      flex: 1;
      background-color: ${theme.color.light["600"]};
    }
  }

  .error {
    color: ${theme.color.danger["500"]};
    line-height: 1.5rem;
  }
`;
const Login = ({ onSubmit, initialValue = "", welcomeText, removeLoadingOnSuccess, className, style, banner, loginTypes = ["idp", "sso"] }) => {
  const t = useTranslate(dictionary);
  const searchParams = new URLSearchParams(location.search);
  const [error, setError] = useState(searchParams.get("error_description") || searchParams.get("error") || "");
  const [loading, setLoading] = useState(false);
  const [email, setEmail] = useState(initialValue);
  const disabled = !email.match(/\w+@\w+/);
  const idpLoginEnabled = loginTypes.includes("idp");
  const ssoLoginEnabled = loginTypes.includes("sso");
  async function login(type) {
    setError("");
    setLoading(true);
    try {
      const data = type === "sso" ? { type: "sso", email } : { type: "idp", provider: "external-idp:github" };
      await onSubmit(data);
      if (removeLoadingOnSuccess)
        setLoading(false);
    } catch (error2) {
      setLoading(false);
      setError(error2.message || error2.toString());
    }
  }
  function submitForm(e) {
    e.preventDefault();
    if (disabled)
      return;
    login("sso");
  }
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(LoginBox, { onSubmit: submitForm, className, style, children: [
      /* @__PURE__ */ jsxs("header", { children: [
        /* @__PURE__ */ jsx(MiniLogo, {}),
        /* @__PURE__ */ jsx(Text, { className: "title", children: welcomeText || t.welcome })
      ] }),
      ssoLoginEnabled && /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Input, { name: "email", value: email, onChange: (e) => setEmail(e.target.value), placeholder: t.placeholder }),
        /* @__PURE__ */ jsx(Button, { colorScheme: "primary", disabled: disabled || loading, children: loading ? /* @__PURE__ */ jsx(LoadingCircular, {}) : /* @__PURE__ */ jsx(Text, { children: t.continue }) })
      ] }),
      ssoLoginEnabled && idpLoginEnabled && /* @__PURE__ */ jsx("p", { className: "separator", children: t.or }),
      idpLoginEnabled && /* @__PURE__ */ jsx(Button, { colorScheme: "light", type: "button", onClick: () => login("idp"), disabled: loading, children: loading ? /* @__PURE__ */ jsx(LoadingCircular, {}) : /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(IconBox, { children: /* @__PURE__ */ jsx(Github, {}) }),
        /* @__PURE__ */ jsx(Text, { children: t.loginWithGithub })
      ] }) }),
      error && /* @__PURE__ */ jsxs(Text, { className: "error", children: [
        t.error,
        ": ",
        error
      ] })
    ] }),
    banner ? /* @__PURE__ */ jsx(BannerWarning, { children: banner }) : null
  ] });
};
const dictionary = {
  en: {
    welcome: "Welcome to StackSpot",
    placeholder: "your@email.com",
    continue: "Continue",
    or: "or",
    loginWithGithub: "Login with Github",
    error: "Error while attempting to login"
  },
  pt: {
    welcome: "Bem vindo \xE0 StackSpot",
    placeholder: "nome@email.com",
    continue: "Continuar",
    or: "ou",
    loginWithGithub: "Logar com o GitHub",
    error: "Erro ao fazer login"
  }
};

const sessionKey$1 = `stk-session${getCookieDomain()}`;
const sessionCookie = Object.freeze({
  set: (data) => setCookie(sessionKey$1, JSON.stringify(data)),
  get: () => {
    try {
      const cookie = getCookie(sessionKey$1);
      return cookie ? JSON.parse(cookie) : void 0;
    } catch (error) {
      console.error(error);
    }
  },
  delete: () => removeCookie(sessionKey$1)
});

const isValidDomain = (url) => {
  const portalDomainRegex = new RegExp(`^https?://[a-zA-Z0-9.-]*${getCookieDomain().replaceAll(".", ".")}(:[0-9]{2,4})*.*$`, "g");
  const platformDomainRegex = new RegExp(/^https:\/\/[a-zA-Z0-9.-]+\.stackspot\.com.*$/, "g");
  const result = portalDomainRegex.test(url) || platformDomainRegex.test(url);
  return result;
};
const redirect = async (url) => {
  if (!isValidDomain(url))
    throw new Error("Redirect URL invalid domain");
  window.location.href = url;
  await new Promise(() => "");
};

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __publicField = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const sessionKey = "session";
const _SessionManager = class _SessionManager {
  constructor(config) {
    __publicField(this, "current");
    __publicField(this, "auth");
    __publicField(this, "config");
    __publicField(this, "changeListeners", []);
    config.loginUrl || (config.loginUrl = location.origin);
    const redirectUrl = (config.redirectUrl || config.loginUrl).replace(/([^/])$/, "$1/");
    this.config = config;
    this.auth = new AuthManager(__spreadProps$1(__spreadValues$1({}, config), {
      redirectUrl,
      storage: localStorage,
      sessionPersistence: {
        load: () => localStorage.getItem(sessionKey),
        save: (session) => localStorage.setItem(sessionKey, session)
      }
    }));
    _SessionManager.instance = this;
    addEventListener("focus", () => this.validateSharedSession());
  }
  static create(config) {
    var _a;
    return (_a = _SessionManager.instance) != null ? _a : new _SessionManager(config);
  }
  setSession(session) {
    this.current = session;
    this.changeListeners.forEach((l) => l(session));
    if (session)
      this.setSessionCookie(session);
  }
  async restoreSession() {
    const session = await this.auth.restoreSession();
    const sessionValid = await this.validateSharedSession(session);
    this.setSession(sessionValid ? session : void 0);
  }
  async validateSharedSession(session = this.current) {
    var _a;
    if (this.urlHasThirdPartyLoginData())
      return false;
    const sharedSessionCookie = sessionCookie.get();
    if (!sharedSessionCookie) {
      session && await this.logout();
      return false;
    }
    const isDifferentSessionActive = sharedSessionCookie.sub != (session == null ? void 0 : session.getTokenData().sub);
    const isSharedSessionTypeBlocked = (_a = this.config.blockedAuthTypes) == null ? void 0 : _a.includes(sharedSessionCookie.type);
    if (isSharedSessionTypeBlocked)
      return false;
    else if (isDifferentSessionActive || !session) {
      await this.startThirdPartyLoginUsingTenant(sharedSessionCookie);
      return false;
    }
    return true;
  }
  hasSession() {
    return !!this.current && !this.current.isExpired();
  }
  getSession() {
    if (!this.hasSession()) {
      this.endSession();
      throw new Error("Session is not available, redirecting to login.");
    }
    return this.current;
  }
  async endSession(redirectToLogin = true) {
    this.current = void 0;
    localStorage.removeItem(sessionKey);
    sessionCookie.delete();
    if (redirectToLogin && this.config.loginUrl)
      await redirect(this.config.loginUrl);
  }
  async logout() {
    var _a;
    try {
      await ((_a = this.current) == null ? void 0 : _a.logout());
    } catch (error) {
      console.error(`Could not logout from IDM.
${error}`);
    }
    await this.endSession();
  }
  async startThirdPartyLogin(data) {
    const params = new URLSearchParams(location.search);
    const authUrl = await this.auth.startThirdPartyLogin(data, {
      from: location.href,
      finalRedirect: params.get("finalRedirect")
    });
    await redirect(authUrl);
  }
  urlHasThirdPartyLoginData() {
    const url = new URL(location.toString());
    return url.searchParams.has("state") && !url.searchParams.has("error");
  }
  async startThirdPartyLoginUsingTenant(data) {
    const params = new URLSearchParams(location.search);
    const cookie = sessionCookie.get();
    if (!cookie || !cookie.tenant) {
      await this.logout();
      return;
    }
    const authUrl = await this.auth.getThirdPartyLoginFromTenant(
      data,
      cookie.tenant,
      {
        from: location.href,
        finalRedirect: params.get("finalRedirect")
      }
    );
    await redirect(authUrl);
  }
  async completeThirdPartyLogin() {
    var _a, _b;
    const url = new URL(location.toString());
    if (url.searchParams.has("error")) {
      throw new Error(`Error while signing in: ${url.searchParams.get("error_description")}`);
    }
    const { session, data: { from, finalRedirect } } = await this.auth.completeThirdPartyLogin(location.search);
    this.setSession(session);
    history.replaceState(null, "", from || location.toString().replace(/\?.*$/, ""));
    this.sendLoginEventRd((_a = this.current) == null ? void 0 : _a.getTokenData().email, (_b = this.current) == null ? void 0 : _b.getTokenData().name);
    if (finalRedirect)
      await redirect(finalRedirect);
  }
  getEmailForLogin() {
    const session = sessionCookie.get();
    return (session == null ? void 0 : session.type) == "sso" ? session.email : void 0;
  }
  async switchAccount(accountId) {
    this.current && await this.auth.switchAccount(accountId, this.current);
    this.setSession(this.current);
  }
  onChange(listener) {
    this.changeListeners.push(listener);
    return () => {
      const index = this.changeListeners.indexOf(listener);
      if (index != -1)
        this.changeListeners.splice(index, 1);
    };
  }
  setSessionCookie(session) {
    const { email, account_type, sub, tenant } = session.getTokenData();
    if (!email || !sub || !tenant)
      return;
    const isFreemium = account_type == "FREEMIUM";
    if (isFreemium) {
      sessionCookie.set({ type: "idp", provider: "external-idp:github", sub, tenant });
    } else {
      sessionCookie.set({ email, type: "sso", sub, tenant });
    }
  }
  async sendLoginEventRd(email, name) {
    if (!this.config.rdUrl)
      return;
    if (!email && !name) {
      console.error("Unable to trigger login hook. No sessionEmail or name identified.");
      return;
    }
    const rdObject = {
      event_type: "CONVERSION",
      event_family: "CDP",
      payload: {
        email,
        name,
        conversion_identifier: "login-v1"
      }
    };
    const response = await fetch(this.config.rdUrl, {
      method: "POST",
      body: JSON.stringify(rdObject),
      headers: {
        "content-type": "application/json"
      }
    });
    const data = await response.json();
    if (!response.ok) {
      console.error("Error while sending event to RD Station", data);
    }
  }
};
__publicField(_SessionManager, "instance");
let SessionManager = _SessionManager;

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const Authenticated = ({ children, onLogin, onSession, customLoginProps, sessionManager, onChangeStatus }) => {
  const [authStatus, setAuthStatus] = useState("unknown");
  const language = useLanguage();
  sessionManager != null ? sessionManager : sessionManager = SessionManager.instance;
  if (!sessionManager)
    throw new Error("Please, provide a sessionManager");
  useEffectOnce(() => {
    async function checkAuth() {
      if (!sessionManager)
        throw new Error("Please, provide a sessionManager");
      await sessionManager.restoreSession();
      if (sessionManager.urlHasThirdPartyLoginData()) {
        await sessionManager.completeThirdPartyLogin();
        onLogin == null ? void 0 : onLogin();
      }
      if (sessionManager.hasSession()) {
        setAuthStatus("authenticated");
        onSession == null ? void 0 : onSession();
        onChangeStatus == null ? void 0 : onChangeStatus("authenticated");
      } else {
        setAuthStatus("unauthenticated");
        onChangeStatus == null ? void 0 : onChangeStatus("unauthenticated");
      }
    }
    checkAuth();
  });
  if (authStatus === "unknown")
    return null;
  if (authStatus === "authenticated")
    return children;
  return /* @__PURE__ */ jsx(CSSToCitricAdapter, { children: /* @__PURE__ */ jsx(Flex, { justifyContent: "center", alignItems: "center", flex: 1, style: { height: "100%" }, children: /* @__PURE__ */ jsx(
    Login,
    __spreadValues({
      style: { width: "360px" },
      onSubmit: (data) => sessionManager.startThirdPartyLogin(__spreadProps(__spreadValues({}, data), { locale: language })),
      initialValue: sessionManager.getEmailForLogin()
    }, customLoginProps || {})
  ) }) });
};

function useSession() {
  const manager = SessionManager.instance;
  const [session, setSession] = useState((manager == null ? void 0 : manager.hasSession()) ? manager.getSession() : void 0);
  useEffect(() => {
    return manager == null ? void 0 : manager.onChange(setSession);
  }, []);
  return session;
}

export { Authenticated, Login, SessionManager, useSession };
//# sourceMappingURL=index.mjs.map
