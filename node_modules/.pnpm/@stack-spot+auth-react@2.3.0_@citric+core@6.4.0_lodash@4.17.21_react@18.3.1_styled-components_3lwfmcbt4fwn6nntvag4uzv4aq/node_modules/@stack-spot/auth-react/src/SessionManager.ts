import { AuthConfig, AuthManager, Session, ThirdPartyAuthType, ThirdPartyLoginParams } from '@stack-spot/auth'
import { sessionCookie } from './utils/cookies'
import { redirect } from './utils/redirect'

const sessionKey = 'session'

interface SessionManagerConfig extends Pick<AuthConfig, 'accountUrl' | 'authUrl' | 'clientId' | 'defaultTenant' | 'retry' | 'retryDelay'> {
  /**
   * The URL to redirect to when the user logs out.
   * @default location.origin
   */
  loginUrl?: string,
  /**
   * The URL to redirect to when the login completes in the authentication app. If not provided, will be the same as `loginUrl`.
   * @default loginUrl
   */
  redirectUrl?: string,
  /**
   * Forbidden authentication types to this Session Manager.
   */
  blockedAuthTypes?: ThirdPartyAuthType[]
  /**
   * A URL to send login events to (observability).
   */
  rdUrl?: string,
}

type AuthExtraData = { from?: string | null, finalRedirect?: string | null }

type ChangeListener = (session: Session | undefined) => void

/**
 * Controls the current session in a browser.
 * 
 * This should not be used under a Node.JS environment.
 * 
 * This is a singleton. To create the first instance or recover the current one, use `SessionManager.create`.
 */
export class SessionManager {
  private current: Session | undefined
  private readonly auth: AuthManager<AuthExtraData>
  private config: SessionManagerConfig
  private changeListeners: ChangeListener[] = []
  static instance: SessionManager | undefined

  private constructor(config: SessionManagerConfig) {
    config.loginUrl ||= location.origin
    const redirectUrl = (config.redirectUrl || config.loginUrl).replace(/([^/])$/, '$1/') // the trailing "/" is required by Stackspot IAM.
    this.config = config
    this.auth = new AuthManager<AuthExtraData>({
      ...config,
      redirectUrl,
      storage: localStorage,
      sessionPersistence: {
        load: () => localStorage.getItem(sessionKey),
        save: (session) => localStorage.setItem(sessionKey, session),
      },
    })
    SessionManager.instance = this

    // Keep session in sync with other app's session
    addEventListener('focus', () => this.validateSharedSession())
  }

  static create(config: SessionManagerConfig) {
    return SessionManager.instance ?? new SessionManager(config)
  }

  private setSession(session: Session | undefined) {
    this.current = session
    this.changeListeners.forEach(l => l(session))
    if (session) this.setSessionCookie(session)
  }

  async restoreSession() {
    const session = await this.auth.restoreSession()
    const sessionValid = await this.validateSharedSession(session)
    this.setSession(sessionValid ? session : undefined)
  }

  async validateSharedSession(session: Session | undefined = this.current): Promise<boolean> {

    // skipping because authentication is in progress
    if (this.urlHasThirdPartyLoginData()) return false

    const sharedSessionCookie = sessionCookie.get()

    // It has been logged out on another portal, so logout on this one too
    if (!sharedSessionCookie) {
      session && await this.logout()
      return false
    }

    const isDifferentSessionActive = sharedSessionCookie.sub != session?.getTokenData().sub
    const isSharedSessionTypeBlocked = this.config.blockedAuthTypes?.includes(sharedSessionCookie.type)
    if (isSharedSessionTypeBlocked) return false
    else if (isDifferentSessionActive || !session) {
      await this.startThirdPartyLoginUsingTenant(sharedSessionCookie)
      return false
    }
    return true
  }

  hasSession() {
    return !!this.current && !this.current.isExpired()
  }

  getSession() {
    if (!this.hasSession()) {
      this.endSession()
      throw new Error('Session is not available, redirecting to login.')
    }
    return this.current!
  }

  async endSession(redirectToLogin = true) {
    this.current = undefined
    localStorage.removeItem(sessionKey)
    sessionCookie.delete()
    if (redirectToLogin && this.config.loginUrl) await redirect(this.config.loginUrl)
  }

  async logout() {
    try {
      await this.current?.logout()
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error(`Could not logout from IDM.\n${error}`)
    }
    await this.endSession()
  }

  async startThirdPartyLogin(data: ThirdPartyLoginParams) {
    const params = new URLSearchParams(location.search)
    const authUrl = await this.auth.startThirdPartyLogin(data, {
      from: location.href,
      finalRedirect: params.get('finalRedirect'),
    })
    await redirect(authUrl)
  }

  urlHasThirdPartyLoginData() {
    const url = new URL(location.toString())
    return url.searchParams.has('state') && !url.searchParams.has('error')
  }

  async startThirdPartyLoginUsingTenant(data: ThirdPartyLoginParams) {
    const params = new URLSearchParams(location.search)
    const cookie = sessionCookie.get()
    if (!cookie || !cookie.tenant) {
      //If no tenant is available we should log out the user
      await this.logout()
      return
    }
    const authUrl = await this.auth.getThirdPartyLoginFromTenant(data, cookie.tenant, {
      from: location.href,
      finalRedirect: params.get('finalRedirect'),
    }
    )
    await redirect(authUrl)
  }

  async completeThirdPartyLogin() {
    const url = new URL(location.toString())
    if (url.searchParams.has('error')) {
      throw new Error(`Error while signing in: ${url.searchParams.get('error_description')}`)
    }
    const { session, data: { from, finalRedirect } } = await this.auth.completeThirdPartyLogin(location.search)
    this.setSession(session)
    history.replaceState(null, '', from || location.toString().replace(/\?.*$/, ''))
    this.sendLoginEventRd(this.current?.getTokenData().email, this.current?.getTokenData().name)
    if (finalRedirect) await redirect(finalRedirect)
  }

  getEmailForLogin() {
    const session = sessionCookie.get()
    return session?.type == 'sso' ? session.email : undefined
  }

  async switchAccount(accountId: string) {
    this.current && await this.auth.switchAccount(accountId, this.current)
    this.setSession(this.current)
  }

  onChange(listener: ChangeListener) {
    this.changeListeners.push(listener)
    return () => {
      const index = this.changeListeners.indexOf(listener)
      if (index != -1) this.changeListeners.splice(index, 1)
    }
  }

  private setSessionCookie(session: Session) {
    const { email, account_type, sub, tenant } = session.getTokenData()
    if (!email || !sub || !tenant) return
    const isFreemium = account_type == 'FREEMIUM'
    if (isFreemium) {
      sessionCookie.set({ type: 'idp', provider: 'external-idp:github', sub, tenant })
    } else {
      sessionCookie.set({ email, type: 'sso', sub, tenant })
    }
  }

  private async sendLoginEventRd(email?: string, name?: string) {
    if (!this.config.rdUrl) return
    if (!email && !name) {
      // eslint-disable-next-line no-console
      console.error('Unable to trigger login hook. No sessionEmail or name identified.')
      return
    }

    const rdObject = {
      event_type: 'CONVERSION',
      event_family: 'CDP',
      payload: {
        email,
        name,
        conversion_identifier: 'login-v1',
      },
    }

    const response = await fetch(this.config.rdUrl, {
      method: 'POST',
      body: JSON.stringify(rdObject),
      headers: {
        'content-type': 'application/json',
      },
    })
    const data = await response.json()

    if (!response.ok) {
      // eslint-disable-next-line no-console
      console.error('Error while sending event to RD Station', data)
    }
  }
}
