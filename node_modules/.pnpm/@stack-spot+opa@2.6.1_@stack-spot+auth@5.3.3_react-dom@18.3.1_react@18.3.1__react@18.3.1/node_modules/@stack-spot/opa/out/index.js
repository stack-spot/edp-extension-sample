'use strict';

const USER_KEY = "@stack-spot/opa:user";
const config = {};
function setup({ url, session, apiMap, verbose }) {
  config.url = url;
  config.session = session;
  config.apiMap = apiMap;
  config.verbose = verbose;
  const prevUserId = localStorage.getItem(USER_KEY);
  const userId = session.getTokenData().account_id_v2 ?? "";
  localStorage.setItem(USER_KEY, userId);
  if (prevUserId !== userId) {
    permissionClient.invalidateCache();
  }
}

function requestAsKey(req) {
  return `${req.path}|${req.api}|${req.method}|${req.body ?? ""}|${getHeadersKey(req.headers)}`;
}
function getHeadersKey(headers) {
  if (!headers)
    return "";
  const keys = Object.keys(headers);
  keys.sort();
  keys.map((k) => `${k}:${headers[k]}`).join(",");
}

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class CompletablePromise {
  constructor() {
    __publicField$3(this, "promise");
    __publicField$3(this, "_resolve");
    __publicField$3(this, "_reject");
    __publicField$3(this, "resolved", false);
    __publicField$3(this, "rejected", false);
    this.promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  resolve(value) {
    if (this._resolve)
      this._resolve(value);
    this.resolved = true;
  }
  reject(reason) {
    if (this._reject)
      this._reject(reason);
    this.rejected = true;
  }
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class PermissionQuery {
  constructor(requests) {
    __publicField$2(this, "requests", []);
    __publicField$2(this, "results");
    __publicField$2(this, "indexMap", []);
    const keyToIndex = /* @__PURE__ */ new Map();
    for (const req of requests) {
      const key = requestAsKey(req);
      let index = keyToIndex.get(key);
      if (index === void 0) {
        index = this.requests.length;
        this.requests.push(req);
        keyToIndex.set(key, index);
      }
      this.indexMap.push(index);
    }
  }
  toJson() {
    return JSON.stringify(this.requests);
  }
  setResults(results) {
    this.results = results;
  }
  /**
   * Gets the result according to the index of the array passed in the constructor of this instance.
   */
  getResult(index) {
    if (!this.results)
      throw new Error("Tried to get the results of a PermissionQuery that has no results yet.");
    return this.results[this.indexMap[index]];
  }
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const DEFER_MS = 200;
class PermissionQueue {
  constructor() {
    __publicField$1(this, "queue", []);
    __publicField$1(this, "deferred", new CompletablePromise());
    __publicField$1(this, "timeout");
    __publicField$1(this, "lock", false);
  }
  async consume() {
    if (this.queue.length === 0)
      return;
    if (this.lock)
      return this.timeout = window.setTimeout(() => this.consume(), DEFER_MS);
    this.lock = true;
    const deferred = this.deferred;
    this.deferred = new CompletablePromise();
    const query = new PermissionQuery(this.queue);
    this.queue = [];
    if (!config.session || !config.url) {
      const error = new Error(
        'Error while validating permissions. Please, be sure to call "setup" with a valid url and session before attempting to verify permissions.'
      );
      this.deferred.reject(error);
      throw error;
    }
    try {
      const response = await config.session.fetch(config.url, {
        method: "POST",
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: query.toJson()
      });
      if (response.ok) {
        const allResults = await response.json();
        query.setResults(allResults);
        deferred.resolve(query);
      } else {
        const message = await response.text();
        deferred.reject(new Error(`Error while checking permissions. Network error ${response.status}.
${message}`));
      }
    } catch (error) {
      deferred.reject(error);
    }
    this.lock = false;
  }
  async add(options) {
    if (this.timeout)
      window.clearTimeout(this.timeout);
    const index = this.queue.length;
    this.queue.push(options);
    this.timeout = window.setTimeout(() => this.consume(), DEFER_MS);
    const query = await this.deferred.promise;
    const result = query.getResult(index);
    if (result.error) {
      console.warn(`Error while checking permission for "${options.method} ${options.api} ${options.path}": ${result.error}`);
    }
    if (config.verbose) {
      console.info(`Permission validated: [${options.api}, ${options.method}, ${options.path}] = ${result.result}`);
    }
    return result.result;
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function processFullPath(path) {
  const addresses = Object.keys(config.apiMap ?? {});
  const address = addresses.find((a) => path.startsWith(a));
  if (!address) {
    throw new Error(
      `Unknown API for URL: ${path}. Please, be sure to inform all APIs in the property "apiMap" of the config for the lib @stack-spot/opa.`
    );
  }
  const api = config.apiMap[address];
  const resourcePath = path.replace(address, "");
  return { api, resourcePath };
}
class PermissionClient {
  constructor() {
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    __publicField(this, "queue", new PermissionQueue());
  }
  async getPermissionForRequest(request) {
    const key = requestAsKey(request);
    const cached = this.cache.get(key);
    if (cached != void 0)
      return cached;
    const result = await this.queue.add(request);
    if (result !== void 0)
      this.cache.set(key, result);
    return result ?? false;
  }
  requestPermission(method, path, body) {
    const { resourcePath, api } = processFullPath(path);
    const serializedBody = typeof body === "object" ? JSON.stringify(body) : `${body}`;
    return this.getPermissionForRequest(
      { api, method, path: resourcePath, ...body ? { body: serializedBody } : {} }
    );
  }
  invalidateCache() {
    this.cache.clear();
  }
}
const permissionClient = new PermissionClient();

function requestPermission(method, path, body) {
  return permissionClient.requestPermission(method, path, body);
}

exports.CompletablePromise = CompletablePromise;
exports.requestPermission = requestPermission;
exports.setup = setup;
//# sourceMappingURL=index.js.map
