/* eslint-disable no-console */

import { exec } from 'child_process'
import { readFile, unlink, writeFile } from 'fs/promises'
import checkbox from '@inquirer/checkbox'
import { Presets, SingleBar } from 'cli-progress'
// @ts-ignore
import list from 'inquirer-interactive-list-prompt'
import apis from '../src/apis.json'

const MAX_ATTEMPTS = 5
const DELAY_MS = 2000
const TARGET_DIR = 'src/api'
const LOG_FILE = '.generate-api.failed.json'
const envs = [
  { name: 'Production', value: 'prd', key: 'p' },
  { name: 'Staging', value: 'stg', key: 's' },
  { name: 'Development', value: 'dev', key: 'd' },
] as const

function delay() {
  return new Promise<void>(resolve => {
    setTimeout(resolve, DELAY_MS)
  })
}

function generateAPICode(name: string, docsUrl: any) {
  return new Promise<string>((resolve, reject) => {
    let output = ''
    const child = exec(
      `pnpm oazapfts ${docsUrl} ${TARGET_DIR}/${name}.ts --optimistic --argumentStyle object`,
      (_, out, err) => output += out || err,
    )
    child.on('error', err => reject(err.message))
    child.on('close', code => code === 0 ? resolve(output) : reject(output))
  })
}

async function generateCodeForAPIs(apiNames: (keyof typeof apis)[], env: 'dev' | 'stg' | 'prd') {
  let progress = 0
  const progressBar = new SingleBar({ clearOnComplete: true, stopOnComplete: true }, Presets.shades_classic)
  progressBar.start(apiNames.length, 0)
  const succeeded: string[] = []
  const failed: string[] = []
  const errors: string[] = []
  await Promise.all(apiNames.map(async (name) => {
    let retries = MAX_ATTEMPTS
    while (retries > 0) {
      try {
        const api = apis[name]
        if ('docs' in api) {
          const docsUrl = `${api.url[env]}${api.docs}`
          await generateAPICode(name, docsUrl)
        }
        retries = 0
        succeeded.push(name)
        progressBar.update(++progress)
      } catch (error: any) {
        retries--
        await delay()
        if (retries === 0) {
          errors.push(error.message || `${error}`)
          failed.push(name)
          progressBar.update(++progress)
        }
      }
    }
  }))
  const succeededStr = succeeded.length ? ` Code generated successfully for ${succeeded.length} APIs.` : ''
  const failedStr = failed.length ? ` Failed to generate code for ${failed.length} APIs. Check the logs below.` : ''
  console.log(`\nFinished!${succeededStr}${failedStr}`)
  if (succeeded.length) {
    console.log('\n> Generated code for:')
    succeeded.forEach(api => console.log(`  - ${api}`))
    await removeLastFailed()
  }
  if (failed.length) {
    console.log('\n> Failed to generate code for:')
    failed.forEach(api => console.log(`  - ${api}`))
    await saveFailed(failed)
  }
  if (errors.length) throw new Error(errors.join('\n\n'))
}

async function getLastFailed(): Promise<(keyof typeof apis)[]> {
  try {
    const raw = await readFile(LOG_FILE, { encoding: 'utf-8' })
    return JSON.parse(raw)
  } catch {
    return []
  }
}

async function removeLastFailed() {
  try {
    await unlink(LOG_FILE)
  // eslint-disable-next-line no-empty
  } catch {}
}

async function saveFailed(failed: string[]) {
  try {
    await writeFile(LOG_FILE, JSON.stringify(failed), { encoding: 'utf-8' })
  // eslint-disable-next-line no-empty
  } catch {}
}

async function start() {
  try {
    const cmdEnvArg = process.argv[2]
    const allAPINames = Object.keys(apis) as (keyof typeof apis)[]
    if ((envs.map(e => e.value) as string[]).includes(cmdEnvArg?.trim() ?? '')) {
      await generateCodeForAPIs(allAPINames, cmdEnvArg as 'prd' | 'stg' | 'dev')
    } else {
      const lastFailed = await getLastFailed()
      const selectedAPIs = await checkbox({
        message: 'Select the APIs you wish to update',
        choices: allAPINames.map(api => ({ name: api, value: api, checked: !lastFailed.length || lastFailed.includes(api) })),
      })
      const env: 'prd' | 'stg' | 'dev' = await list({
        message: 'Select an environment',
        choices: envs,
        default: envs[0].value,
      })
      await generateCodeForAPIs(selectedAPIs, env)
    }
    process.exit(0)
  } catch (error: any) {
    console.error(error.message || `${error}`)
    process.exit(1)
  }
}

start()
