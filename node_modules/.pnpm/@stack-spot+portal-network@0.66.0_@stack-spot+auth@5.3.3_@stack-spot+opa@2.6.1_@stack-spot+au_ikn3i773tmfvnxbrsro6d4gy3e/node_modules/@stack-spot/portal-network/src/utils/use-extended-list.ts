import { useEffect, useRef, useState } from 'react'

type ExtensionMap<T> = Record<string, (item: T) => any>

type Unpromisify<T> = T extends Promise<infer R> ? R : T

type Extension<E extends ExtensionMap<any>> = { [K in keyof E]?: Unpromisify<ReturnType<E[K]>> }

type ItemWithExtensions<T, E extends ExtensionMap<T>> = T & Extension<E>

/**
 * Computes the given extensions for the items in the list passed as parameter. An extension will, most of the times, return a promise,
 * but it can return whatever you'd like.
 * 
 * If the extensions are promises and are still loading, the items won't have the corresponding keys.
 * 
 * Attention: once an extension is calculated for an item, it's never calculated again. An item is identified by the parameter "idProp"
 * (3rd), which is "id" by default.
 * 
 * @example
 * ```
 * const [groups] = accountClient.memberGroups.useInfiniteQuery({ memberId: 'someId' })
 * const extendedGroups = useExtendedList(groups, {
 *   canRemoveMemberFromGroup: group => accountClient.removeMemberFromGroup.isAllowed({ groupId: group.id, memberId: 'someId' }),
 *   title: group => `${group.name} (${group.totalUsers})`,
 * })
 * ```
 * Above, each item in `extendedGroups` will have the properties `canRemoveMemberFromGroup` and `title`, once all permission have been
 * fetched.
 * 
 * @param list the items to compute extensions for.
 * @param extensions an object where the keys are the extension names and the values are functions that return the value of the extension.
 * @param idProp the name of the property that can be used as an id. 'id' by default.
 * @returns an array with 2 items:
 * - [0]: the list with the permission properties.
 * - [1]: true if waiting for a promise, false otherwise.
 */
export function useExtendedList<T, E extends ExtensionMap<T>>(
  list: T[], extensions: E, idProp: keyof T,
): [ItemWithExtensions<T, E>[], boolean]
export function useExtendedList<T extends { id: string }, E extends ExtensionMap<T>>(
  list: T[], extensions: E, idProp?: keyof T,
): [ItemWithExtensions<T, E>[], boolean]
export function useExtendedList<T, E extends ExtensionMap<T>>(
  list: T[], extensions: E, idProp = 'id' as keyof T,
): [ItemWithExtensions<T, E>[], boolean] {
  const [listWithExtensions, setListWithExtensions] = useState(list as ItemWithExtensions<T, E>[])
  const [isLoading, setLoading] = useState(true)
  const extensionMap = useRef(new Map<any, Extension<E>>())
  const listId = list.map(i => i[idProp]).join(';')

  useEffect(() => {
    async function update() {
      setLoading(true)
      const newList = await Promise.all(list.map(async (item) => {
        const itemExtensions: Extension<E> = extensionMap.current.get(item[idProp]) ?? {}
        if (Object.keys(itemExtensions).length === 0) {
          await Promise.all(Object.keys(extensions).map(async (key: keyof E) => {
            try {
              // "await" because it might be a promise
              itemExtensions[key] = await extensions[key](item)
            } catch (error) {
              // eslint-disable-next-line no-console
              console.error(`Failed to compute extension "${String(key)}" for item with id "${item[idProp]}". It will have undefined as its value, which may cause errors ahead. Caused by the error below:`)
              // eslint-disable-next-line no-console
              console.error(error)
            }
          }))
          extensionMap.current.set(item[idProp], itemExtensions)
        }
        return { ...item, ...itemExtensions }
      }))
      setLoading(false)
      setListWithExtensions(newList)
    }
    update()
  }, [listId])

  return [listWithExtensions.length ? listWithExtensions : list as ItemWithExtensions<T, E>[], isLoading]
}
