import { CompletablePromise } from '@stack-spot/opa'
import { StreamCanceledError } from '../error/StreamCanceledError'
import { StreamError } from '../error/StreamError'
import { StreamJsonError } from '../error/StreamJsonError'
import { FetchEventStream } from '../network/types'

type StreamingStatus = 'pending' | 'success' | 'error'
type OnChangeListener<T> = (value: Partial<T>) => void

/**
 * An object represented by a JSON stream. This can be watched as the stream runs.
 */
export class StreamedJson<T> {
  private onChangeListeners: OnChangeListener<T>[] = []
  private error: StreamError | undefined
  private data: Partial<T> = {}
  private fullPromise = new CompletablePromise<T>()
  private abortController: AbortController | undefined

  /**
   * @param response the fetch response.
   * @param minChangeIntervalMS a stream can be too fast. This sets a minimum interval between running the listeners. The default is 50ms.
   */
  constructor(eventsPromise: Promise<FetchEventStream>, abortController: AbortController, minChangeIntervalMS = 50) {
    this.abortController = abortController
    this.run(eventsPromise, minChangeIntervalMS)
  }

  private async run(eventsPromise: Promise<FetchEventStream>, minChangeIntervalMS: number) {
    let lastChangeCall = 0
    try {
      const events = await eventsPromise
      let flushed = true
      for await (const event of events) {
        if (this.error) return
        if (event.data) {
          const json = JSON.parse(event.data)
          StreamedJson.merge(json, this.data)
          if (new Date().getTime() - lastChangeCall >= minChangeIntervalMS) {
            this.onChangeListeners.forEach(l => l(this.data))
            lastChangeCall = new Date().getTime()
            flushed = true
          } else {
            flushed = false
          }
        }
      }
      if (!flushed) this.onChangeListeners.forEach(l => l(this.data))
    } catch (error: any) {
      if (error instanceof DOMException && error.name === 'AbortError') this.fail(new StreamCanceledError())
      if (error instanceof SyntaxError) this.fail(new StreamJsonError())
      else if (error instanceof StreamError) this.fail(error)
      else this.fail(new StreamError(error?.message || `${error}`))
    }
    if (!this.error) this.complete()
  }

  private static merge(source: Record<string, any>, target: Record<string, any>) {
    Object.keys(source).forEach((k) => {
      if (typeof source[k] !== typeof target[k]) target[k] = source[k]
      else if (typeof source[k] === 'string') target[k] += source[k]
      else if (Array.isArray(source[k])) target[k].push(...source[k])
      else if (typeof source[k] === 'number') parseFloat(target[k] + source[k])
      else if (typeof source[k] === 'object') this.merge(source[k], target[k])
      else target[k] = source[k]
    })
  }

  private clear() {
    this.onChangeListeners = []
    this.abortController = undefined
  }

  private fail(error: any) {
    this.error = error
    this.fullPromise.reject(this.error)
    this.clear()
  }

  private complete() {
    this.fullPromise.resolve(this.data as T)
    this.clear()
  }

  /**
   * Returns the full value of the object once the stream finishes.
   */
  getValue(): Promise<T> {
    return this.fullPromise.promise
  }

  /**
   * Returns the streamed object with everything already streamed. This will be the complete object if the stream has finished.
   */
  getPartialValue(): Partial<T> {
    return this.data
  }

  /**
   * Watches the object as it's streamed. This doesn't wait for the value to be complete.
   * 
   * The listener is called whenever the value changes.
   * 
   * @param listener the function to call with the new value.
   * @returns a function that, when called, removes the listener.
   */
  onChange(listener: (value: Partial<T>) => void) {
    if (this.fullPromise.resolved) {
      listener(this.data)
      return () => {}
    }
    this.onChangeListeners.push(listener)
    return () => {
      const index = this.onChangeListeners?.findIndex(l => l === listener)
      if (index !== undefined && index >= 0) this.onChangeListeners?.splice(index, 1)
    }
  }

  getStatus(): StreamingStatus {
    if (this.error) return 'error'
    if (this.fullPromise.resolved) return 'success'
    return 'pending'
  }

  getError() {
    return this.error
  }

  /**
   * If this is a stream and it's not yet finished, calling this function cancels the stream.
   */
  cancel() {
    this.abortController?.abort(new StreamCanceledError())
  }
}
