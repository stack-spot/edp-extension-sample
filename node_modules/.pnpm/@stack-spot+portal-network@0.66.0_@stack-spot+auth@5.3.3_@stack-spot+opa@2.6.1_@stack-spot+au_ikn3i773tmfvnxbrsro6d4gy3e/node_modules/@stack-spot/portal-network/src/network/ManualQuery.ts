/* eslint-disable react-hooks/rules-of-hooks */

import { DefinedUseQueryResult, UseSuspenseQueryResult, useQuery, useSuspenseQuery } from '@tanstack/react-query'
import { StackspotAPIError } from '../error/StackspotAPIError'
import { ManualOperation } from './ManualOperation'
import { queryClient } from './react-query-client'
import { FullOperationConfig, QueryObject, UseQueryObjectOptions } from './types'

export class ManualQuery<
  Variables extends Record<string, any> | void,
  Result
> extends ManualOperation<Variables> implements QueryObject<Variables, Result> {
  constructor(config: FullOperationConfig<Variables extends void ? [AbortSignal] : [AbortSignal, Variables], Result>) {
    super(config)
  }

  protected async makeRequest(variables: Record<string, any> | undefined, signal: AbortSignal) {
    try {
      return await this.config.request(
        ...[signal, variables] as Variables extends void ? [AbortSignal] : [AbortSignal, Variables],
      )
    } catch (error) {
      throw this.config.transformError(error)
    }
  }

  query(...[variables]: Variables extends void ? [] : [variables: Variables]) {
    return queryClient.fetchQuery({
      queryKey: this.getKey(variables as Variables),
      queryFn: ({ signal }) => this.makeRequest(variables, signal),
    })
  }

  #useQueryResult<T extends boolean>(
    suspense: T,
    ...args: Variables extends void
      ? [options?: UseQueryObjectOptions<Result>]
      : [variables: Variables, options?: UseQueryObjectOptions<Result>]
  ) {
    /* `this.config.request` is a function with arity 1 or 2. If it accepts variables, its arity is 2: the 1st parameter is the
    AbortSignal and the 2nd is the variables. If it doesn't accept variables, its arity is one: it accepts only the AbortSignal.
    We can use this information to determine what the type of `args` actually is at runtime. If variables are accepted, than the 1st
    argument is the variables and the 2nd is the query options, otherwise, it has a single argument, which is the query options. */
    const [variables, options] = this.config.request.length === 2 ? args : [undefined, args[0]]
    const use = suspense ? useSuspenseQuery : useQuery
    return use({
      ...options,
      queryKey: this.getKey(variables as Variables),
      queryFn: ({ signal }) => this.makeRequest(variables, signal),
    }, queryClient) as T extends true ? UseSuspenseQueryResult<Result, StackspotAPIError> : DefinedUseQueryResult<Result, StackspotAPIError>
  }

  useQuery(
    ...args: Variables extends void
      ? [options?: UseQueryObjectOptions<Result>]
      : [variables: Variables, options?: UseQueryObjectOptions<Result>]
  ) {
    const result = this.#useQueryResult(false, ...args)
    return result.data
  }

  useStatefulQuery(
    ...args: Variables extends void
      ? [options?: UseQueryObjectOptions<Result>]
      : [variables: Variables, options?: UseQueryObjectOptions<Result>]
  ) {
    const result = this.#useQueryResult(false, ...args)
    return [result.data, result.isPending, result.error as StackspotAPIError | undefined, result] as const
  }

  invalidate(variables?: Partial<Variables>) {
    return queryClient.invalidateQueries({ queryKey: this.getKey(variables) })
  }

  getKey(variables?: Partial<Variables>) {
    return [this.config.apiName, this.config.name, variables]
  }

  cancel(variables?: Partial<Variables>) {
    queryClient.cancelQueries({ queryKey: this.getKey(variables) })
  }
}
