/* eslint-disable react-hooks/rules-of-hooks */

import { type RequestOpts } from '@oazapfts/runtime'
import { UseQueryOptions, UseQueryResult, useQuery } from '@tanstack/react-query'
import { StackspotAPIError } from '../error/StackspotAPIError'
import { queryClient } from './react-query-client'
import { AutoQueryObjectParams, OperationObject } from './types'

export abstract class AutoOperation<Variables> implements OperationObject<Variables> {
  protected fn: ((variables: Variables, opts?: RequestOpts) => Promise<any>) | ((opts?: RequestOpts) => Promise<any>)
  protected apiName: string
  protected onFetchPermission: typeof fetch
  private transformError?: (error: any) => StackspotAPIError

  constructor({ apiName, onFetchPermission, fn, transformError }: AutoQueryObjectParams<Variables, any>) {
    this.fn = fn
    this.onFetchPermission = onFetchPermission
    this.apiName = apiName
    this.transformError = transformError
    if (typeof fn === 'function' && !fn.name) {
      throw new Error("Anonymous functions can't be automatically converted into React queries or mutations.")
    }
  }

  protected async callFn(variables: Partial<Variables> | undefined, signal: AbortSignal | undefined, fetchFn?: typeof fetch) {
    const fn = this.fn as (...args: any[]) => Promise<any>
    try {
      const result = await (
        fn.length === 2
          ? fn(variables ?? {}, fetchFn ? { fetch: fetchFn, signal } : { signal })
          : fn(fetchFn ? { fetch: fetchFn, signal } : { signal })
      )
      return result
    } catch (error) {
      throw this.transformError ? this.transformError(error) : error
    }
  }

  private createPermissionQueryFn(variables: Partial<Variables> | undefined) {
    return () => this.callFn(variables, undefined, this.onFetchPermission)
  }

  isAllowed(...[variables]: Variables extends void ? [] : [variables?: Partial<Variables>]) {
    return queryClient.fetchQuery({
      queryKey: this.getPermissionKey(variables as Variables),
      queryFn: this.createPermissionQueryFn(variables),
    })
  }

  useAllowed(
    ...args: Variables extends void
      ? [options?: Omit<UseQueryOptions, 'queryFn' | 'queryKey'>]
      : [variables?: Partial<Variables>, options?: Omit<UseQueryOptions, 'queryFn' | 'queryKey'>]
  ) {
    /* `this.fn` is a oazapfts function, i.e. it has arity 1 or 2. If it accepts variables, its arity is 2: the 1st parameter is the
    variables and the 2nd is the RequestOpts. If it doesn't accept variables, its arity is one: it accepts only the RequestOpts.
    We can use this information to determine what the type of `args` actually is at runtime. If variables are accepted, than the 1st
    argument is the variables and the 2nd is the query options, otherwise, it has a single argument, which is the query options. */
    const [variables, options] = this.fn.length > 1
      ? args as [Variables, Omit<UseQueryOptions, 'queryFn' | 'queryKey'> | undefined]
      : [undefined, args[0] as Omit<UseQueryOptions, 'queryFn' | 'queryKey'> | undefined]
    const result = useQuery({
      ...options,
      queryKey: this.getPermissionKey(variables as Variables),
      queryFn: this.createPermissionQueryFn(variables),
    }, queryClient) as UseQueryResult<boolean, StackspotAPIError>
    return [result.data, result.isPending, result.error, result] as const
  }

  getPermissionKey(variables?: Partial<Variables>) {
    return [this.apiName, `${this.fn.name}.permission`, variables]
  }
}
