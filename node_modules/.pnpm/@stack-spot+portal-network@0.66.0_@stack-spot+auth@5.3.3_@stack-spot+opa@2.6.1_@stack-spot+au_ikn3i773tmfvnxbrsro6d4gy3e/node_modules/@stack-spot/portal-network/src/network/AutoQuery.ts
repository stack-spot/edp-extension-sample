/* eslint-disable react-hooks/rules-of-hooks */

import { DefinedUseQueryResult, UseSuspenseQueryResult, useQuery, useSuspenseQuery } from '@tanstack/react-query'
import { StackspotAPIError } from '../error/StackspotAPIError'
import { AutoOperation } from './AutoOperation'
import { queryClient } from './react-query-client'
import { AutoQueryObjectParams, QueryObject, UseQueryObjectOptions } from './types'

export class AutoQuery<Variables, Result> extends AutoOperation<Variables> implements QueryObject<Variables, Result> {
  constructor(params: AutoQueryObjectParams<Variables, Result>) {
    super(params)
  }

  query(...[variables]: Variables extends void ? [] : [variables: Variables]) {
    return queryClient.fetchQuery({
      queryKey: this.getKey(variables),
      queryFn: ({ signal }) => this.callFn(variables, signal),
    })
  }

  #useQueryResult<T extends boolean>(
    suspense: T,
    ...args: Variables extends void
      ? [options?: UseQueryObjectOptions<Result>]
      : [variables: Variables, options?: UseQueryObjectOptions<Result>]
  ) {
    /* `this.fn` is a oazapfts function, i.e. it has arity 1 or 2. If it accepts variables, its arity is 2: the 1st parameter is the
    variables and the 2nd is the RequestOpts. If it doesn't accept variables, its arity is one: it accepts only the RequestOpts.
    We can use this information to determine what the type of `args` actually is at runtime. If variables are accepted, than the 1st
    argument is the variables and the 2nd is the query options, otherwise, it has a single argument, which is the query options. */
    const [variables, options] = this.fn.length > 1
      ? args as [Variables, UseQueryObjectOptions<Result> | undefined]
      : [undefined, args[0] as UseQueryObjectOptions<Result> | undefined]
    const use = suspense ? useSuspenseQuery : useQuery
    return use({
      ...options,
      // without this, this lib won't work in React's strict mode, since every request will be immediately aborted (component unmounted).
      gcTime: 60000,
      queryKey: this.getKey(variables),
      queryFn: ({ signal }) => this.callFn(variables, signal),
    }, queryClient) as T extends true ? UseSuspenseQueryResult<Result, StackspotAPIError> : DefinedUseQueryResult<Result, StackspotAPIError>
  }

  useQuery(
    ...args: Variables extends void
      ? [options?: UseQueryObjectOptions<Result>]
      : [variables: Variables, options?: UseQueryObjectOptions<Result>]
  ) {
    const result = this.#useQueryResult(true, ...args)
    return result.data
  }

  useStatefulQuery(
    ...args: Variables extends void
      ? [options?: UseQueryObjectOptions<Result>]
      : [variables: Variables, options?: UseQueryObjectOptions<Result>]
  ) {
    const result = this.#useQueryResult(false, ...args)
    return [result.data, result.isPending, result.error as StackspotAPIError | undefined, result] as const
  }

  invalidate(variables?: Partial<Variables>) {
    return queryClient.invalidateQueries({ queryKey: this.getKey(variables) })
  }

  getKey(variables?: Partial<Variables>)  {
    const key: any[] = [this.apiName, this.fn.name]
    if (variables) key.push(variables)
    return key
  }

  cancel(variables?: Partial<Variables>) {
    queryClient.cancelQueries({ queryKey: this.getKey(variables) })
  }
}
