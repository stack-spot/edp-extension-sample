/* eslint-disable react-hooks/rules-of-hooks */

import { Defaults, HttpError, RequestOpts } from '@oazapfts/runtime'
import { StackspotAPIError } from '../error/StackspotAPIError'
import { AutoInfiniteQuery } from './AutoInfiniteQuery'
import { AutoMutation } from './AutoMutation'
import { AutoQuery } from './AutoQuery'
import { ManualInfiniteQuery } from './ManualInfiniteQuery'
import { ManualMutation } from './ManualMutation'
import { ManualQuery } from './ManualQuery'
import { NetworkClient } from './NetworkClient'
import { Env, HTTPMethod, InfiniteQueryConfig, InfiniteQueryObject, InfiniteQueryOptions, MutationObject, OperationConfig, OperationObject, QueryObject } from './types'

const DUMMY_ULID = '01HSTZ5471CBG4AW9BFJ0VTVG9'
const PERMISSION_ERROR = 'permission-error'
export const DEFAULT_PAGE_SIZE = 20

/**
 * A Network Client that uses oazapfts for making requests and React Query for managing responses.
 */
export abstract class ReactQueryNetworkClient extends NetworkClient {
  /**
   * @param baseURL An object with the keys "dev", "stg" and "prd". The values must be the url for each of these environments.
   * @param defaults the `default` object of the API this client is for (provided by the code generated by oazapfts).
   */
  constructor(baseURL: Record<Env, string>, defaults: Defaults<any>) {
    super(baseURL)
    defaults.baseUrl = ''
    defaults.fetch = (...args) => this.fetch(...args)
  }

  #parseErrorData(error: HttpError) {
    if (typeof error.data === 'string') {
      try {
        return JSON.parse(error.data)
      } catch { /* empty */ }
    }
    return error.data
  }

  #transformError(error: any): StackspotAPIError {
    if (error instanceof StackspotAPIError) return error
    if (!(error instanceof HttpError)) throw new StackspotAPIError({ status: 0, message: error?.message || `${error}`, stack: error.stack })
    const data = this.#parseErrorData(error)
    if (data.type === PERMISSION_ERROR) {
      // eslint-disable-next-line no-console
      console.error('Error while validating permissions:', data.message)
      return new StackspotAPIError({
        status: 500,
        stack: error.stack,
        message: language => language === 'pt'
          ? 'Ocorreu um erro ao validar as permiss√µes.'
          : 'There was an error while validating permissions.',
      })
    }
    return this.buildStackSpotError(error)
  }

  /**
   * Receives an HttpError and returns a StackspotAPIError.
   * @param error the original HttpError created by oazapfts.
   */
  protected abstract buildStackSpotError(error: HttpError): StackspotAPIError

  /**
   * Creates a function that checks the permission for a request generated by an oazapfts function.
   * 
   * This is intended to help creating a manual operation.
   * 
   * @example
   * ```
   * myOperation = this.mutation({
   *   // ...
   *   permission: this.createPermissionFunctionFor(oazapftsFnForMyOperation)
   * })
   * ```
   * @param fn the function generated by oazapfts.
   * @returns a function that receives the variables of `fn` (if any) and returns a promise that resolves to true if the request is allowed
   * and false otherwise.
   */
  protected createPermissionFunctionFor<Args extends [variables: Record<string, any>, opts?: RequestOpts] | [opts?: RequestOpts]>(
    fn: (...args: Args) => Promise<any>,
  ): (...args: Args extends [opts?: RequestOpts] ? [] : [variables?: Partial<Args[0]>]) => Promise<boolean> {
    return (variables?: any) => fn.length === 2
      ? (fn as (variables: Record<string, any>, opts?: RequestOpts) => Promise<any>)(
        variables,
        { fetch: (...args) => this.#onFetchPermission(...args) },
      )
      : (fn as (opts?: RequestOpts) => Promise<any>)({ fetch: (...args) => this.#onFetchPermission(...args) })
  }

  /**
   * Creates a function that runs a oazapfts function with an abort signal.
   * 
   * This is intended to help creating a manual operation.
   * 
   * @example
   * ```
   * myOperation = this.mutation({
   *   // ...
   *   request: this.createRequestFunctionFor(oazapftsFnForMyOperation)
   * })
   * ```
   * @param fn the function generated by oazapfts.
   * @returns a function that receives a signal and the variables of `fn` (if any) and returns the same as `fn`.
   */
  protected createRequestFunctionFor<Args extends [variables: Record<string, any>, opts?: RequestOpts] | [opts?: RequestOpts], Result>(
    fn: (...args: Args) => Promise<Result>,
  ): (...args: Args extends [opts?: RequestOpts] ? [signal: AbortSignal] : [signal: AbortSignal, variables: Args[0]]) => Promise<Result> {
    return (signal, variables?: any) => fn.length === 2
      ? (fn as (variables: Record<string, any>, opts?: RequestOpts) => Promise<Result>)(variables, { signal })
      : (fn as (opts?: RequestOpts) => Promise<Result>)({ signal })
  }

  async #onFetchPermission(input: string | URL | Request, init?: RequestInit | undefined): Promise<Response> {
    const [path, method, body] = input instanceof Request
      ? [input.url, input.method as HTTPMethod, input.body]
      : [`${input}`, (init?.method?.toLowerCase() || 'get') as HTTPMethod, init?.body]
    try {
      /* We allow the dev not to pass any variable when validating a permission. For this reason, oazapfts might generate a path with
      "undefined". If this happens, we must replace the undefined text with a dummy ULID. */
      const fixedPath = path.replace(/\/undefined(\/|$)/g, `/${DUMMY_ULID}$1`)
      const isAllowed = await this.requestPermission(method, fixedPath, body as any)
      return new Response(`${isAllowed}`, { headers: { 'Content-Type': 'application/json' } })
    } catch (error: any) {
      return new Response(JSON.stringify({ type: PERMISSION_ERROR, message: error.message || `${error}` }), { status: 500 })
    }
  }

  /**
   * Builds a query manually by using a configuration object. 
   * @param config the configuration object containing the name, a request function and a permission function.
   */
  protected query<Args extends [AbortSignal, Record<string, any>] | [AbortSignal], Result>(
    config: OperationConfig<Args, Result>,
  ): QueryObject<Args extends [AbortSignal] ? void : Args[1], Result>
  /**
   * Builds a query manually by using a configuration object. 
   * @param config the configuration object containing the name and a request function. 
   */
  protected query<Args extends [AbortSignal, Record<string, any>] | [AbortSignal], Result>(
    config: Omit<OperationConfig<Args, Result>, 'permission'>,
  ): Omit<QueryObject<Args extends [AbortSignal] ? void : Args[1], Result>, 'isAllowed' | 'useAllowed' | 'getPermissionKey'>
  /**
   * Builds a query automatically by using a function generated by oazapfts. 
   * @param fn the oazapfts function.
   */
  protected query<Args extends [opts?: RequestOpts] | [variables: Record<string, any>, opts?: RequestOpts], Result>(
    fn: (...args: Args) => Promise<Result>
  ): Args extends [variables: infer Variables, opts?: RequestOpts] ? QueryObject<Variables, Result> : QueryObject<void, Result>
  protected query(fnOrConfig: any): QueryObject<any, any> {
    return typeof fnOrConfig === 'function'
      ? new AutoQuery(
        {
          apiName: this.constructor.name,
          fn: fnOrConfig,
          onFetchPermission: (...args) => this.#onFetchPermission(...args),
          transformError: error => this.#transformError(error),
        },
      )
      : new ManualQuery({
        ...fnOrConfig,
        apiName: this.constructor.name,
        request: fnOrConfig.request,
        permission: fnOrConfig.permission,
        transformError: error => this.#transformError(error),
      })
  }

  /**
   * Builds a query manually by using a configuration object. 
   * @param config the configuration object containing the name, a request function and a permission function.
   */
  protected infiniteQuery<
    Variables extends Record<string, any>,
    Result,
    PageParamName extends keyof Variables,
    Accumulator extends keyof Result | '',
  >(config: InfiniteQueryConfig<Variables, Result, PageParamName, Accumulator>): InfiniteQueryObject<Variables, Result, Accumulator>
  /**
   * Builds a query manually by using a configuration object. 
   * @param config the configuration object containing the name and a request function. 
   */
  protected infiniteQuery<
    Variables extends Record<string, any>,
    Result,
    PageParamName extends keyof Variables,
    Accumulator extends keyof Result | '',
  >(
    config: Omit<InfiniteQueryConfig<Variables, Result, PageParamName, Accumulator>, 'permission'>,
  ): Omit<InfiniteQueryObject<Variables, Result, Accumulator>, 'isAllowed' | 'useAllowed' | 'getPermissionKey'>
  /**
   * Builds a query automatically by using a function generated by oazapfts. 
   * @param fn the oazapfts function.
   * @param options the configuration for the infinite query.
   */
  protected infiniteQuery<
    Variables extends Record<string, any>,
    Result,
    PageParamName extends keyof Variables,
    Accumulator extends keyof Result,
  >(
    fn: (variables: Variables, opts?: RequestOpts) => Promise<Result>,
    options: Partial<InfiniteQueryOptions<Variables, Result, PageParamName, Accumulator>>,
  ): InfiniteQueryObject<Variables, Result, Accumulator>
  /**
   * Builds a query automatically by using a function generated by oazapfts with the variables `page` and `size`. 
   * @param fn the oazapfts function that returns an array.
   * @param options optional configuration for the infinite query. By default, it will use the variables page and size of the function
   * passed in the first parameter.
   */
  protected infiniteQuery<
    Variables extends { page?: number | string, size?: number | string },
    Result extends any[],
    PageParamName extends keyof Variables = 'page',
    Accumulator extends keyof Result | '' = '',
  >(
    fn: (variables: Variables, opts?: RequestOpts) => Promise<Result>,
    options?: Partial<InfiniteQueryOptions<Variables, Result, PageParamName, Accumulator>>,
  ): InfiniteQueryObject<Variables, Result, Accumulator>
  /**
   * Builds a query automatically by using a function generated by oazapfts in which the variables `pageParamName` is a string 
   * which can be used for dynamic indexing.
   * @param fn the oazapfts function that returns an array.
   * @param options optional configuration for the infinite query. By default, it will use the variables page and size of the function
   * passed in the first parameter.
   */
  protected infiniteQuery<
    Variables extends Record<string, any>,
    Result,
    PageParamName extends string,
    Accumulator extends keyof Result,
  >(
    fn: (variables: Variables, opts?: RequestOpts) => Promise<Result>,
    options: Partial<InfiniteQueryOptions<Variables, Result, PageParamName, Accumulator>>,
  ): InfiniteQueryObject<Variables, Result, Accumulator>
  protected infiniteQuery(
    fnOrConfig: any, options?: Partial<InfiniteQueryOptions<any, any, any, any>>,
  ): InfiniteQueryObject<any, any, any> {
    return typeof fnOrConfig === 'function'
      ? new AutoInfiniteQuery(
        {
          apiName: this.constructor.name,
          fn: fnOrConfig,
          onFetchPermission: (...args) => this.#onFetchPermission(...args),
          transformError: error => this.#transformError(error),
        },
        {
          accumulator: options?.accumulator ?? '',
          pageParamName: options?.pageParamName ?? 'page',
          initialPageParam: options?.initialPageParam ?? 1,
          defaultVariables: options?.defaultVariables ?? { size: DEFAULT_PAGE_SIZE },
          getNextPageParam: options?.getNextPageParam ?? (({ variables, lastPage, lastPageParam }) => {
            const size = variables.size ?? 1
            const isLastPageTheLast = lastPage && (
              (Array.isArray(lastPage) && lastPage.length < size)
              || (options?.accumulator !== undefined && options?.accumulator !== '' && lastPage[options?.accumulator]?.length < size)
            )
            return isLastPageTheLast ? undefined : parseInt(lastPageParam) + 1
          }),
        },
      )
      : new ManualInfiniteQuery({
        ...fnOrConfig,
        apiName: this.constructor.name,
        request: fnOrConfig.request,
        permission: fnOrConfig.permission,
        transformError: error => this.#transformError(error),
      })
  }

  /**
   * Builds a mutation manually by using a configuration object. 
   * @param config the configuration object containing the name, a request function and a permission function.
   */
  protected mutation<Args extends [AbortSignal, Record<string, any>] | [AbortSignal], Result>(
    config: OperationConfig<Args, Result>,
  ): MutationObject<Args extends [AbortSignal] ? void : Args[1], Result>
  /**
   * Builds a mutation manually by using a configuration object. 
   * @param config the configuration object containing the name and a request function. 
   */
  protected mutation<Args extends [AbortSignal, Record<string, any>] | [AbortSignal], Result>(
    config: Omit<OperationConfig<Args, Result>, 'permission'>,
  ): Omit<MutationObject<Args extends [AbortSignal] ? void : Args[1], Result>, keyof OperationObject<any>>
  /**
   * Builds a mutation automatically by using a function generated by oazapfts. 
   * @param fn the oazapfts function.
   */
  protected mutation<Args extends [opts?: RequestOpts] | [variables: Record<string, any>, opts?: RequestOpts], Result>(
    fn: (...args: Args) => Promise<Result>,
  ): Args extends [variables: infer Variables, opts?: RequestOpts] ? MutationObject<Variables, Result> : MutationObject<void, Result>
  protected mutation(fnOrConfig: any): MutationObject<any, any> {
    if (typeof fnOrConfig === 'function') {
      return new AutoMutation(
        {
          apiName: this.constructor.name,
          fn: fnOrConfig,
          onFetchPermission: (...args) => this.#onFetchPermission(...args),
          transformError: error => this.#transformError(error),
        },
      )
    }
    return new ManualMutation({
      ...fnOrConfig,
      apiName: this.constructor.name,
      request: fnOrConfig.request,
      permission: fnOrConfig.permission,
      transformError: error => this.#transformError(error),
    })
  }
}
