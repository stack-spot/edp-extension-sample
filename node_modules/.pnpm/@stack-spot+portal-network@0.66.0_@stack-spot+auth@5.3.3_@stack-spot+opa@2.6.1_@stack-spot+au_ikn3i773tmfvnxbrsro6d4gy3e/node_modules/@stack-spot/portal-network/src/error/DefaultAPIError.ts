import { Dictionary, Language } from '@stack-spot/portal-translate'
import { every, isString } from 'lodash'
import { ErrorResponse, ValidationDetails } from '../api/account'
import { ErrorDetailsProperties, StackspotAPIError } from './StackspotAPIError'
import { baseDictionary } from './dictionary/base'
import { cntFields } from './dictionary/cnt-fields'
import { workspaceFields } from './dictionary/workspace-fields'
import { workspaceDetails } from './dictionary/workspace-details'
import { actionDetails } from './dictionary/action-details'

// these details don't say anything the status already doesn't and we'd better use local translations for them.
const ignoredDescriptions = [
  'internal server error', 'not found', 'gateway timeout', 'temporally unavailable', 'forbidden', 'unauthorized', 'bad request',
]

const fieldDictionary = {
  cnt: cntFields,
  wks: workspaceFields,
}

const detailsDictionary = {
  wks: workspaceDetails,
  actionapi: actionDetails,
}

function getTitle(status: number, raw: ErrorResponse, dictionary: Dictionary, language: Language) {
  if (dictionary[language][raw.code]) return dictionary[language][raw.code]
  if (raw.details && !ignoredDescriptions.includes(raw.details)) return raw.details
  return (baseDictionary as Dictionary)[language][status] || baseDictionary[language].defaultTitle
}

function getValues(detail: ValidationDetails) {
  return detail.values && every(detail.values, isString) ? `\n${detail.values.join('\n')}` : ''
}

function createMessage(status: number, raw: ErrorResponse, dictionary: Dictionary, language?: Language): ErrorDetailsProperties  {
  const title = getTitle(status, raw, dictionary, language || 'en')
  const api = raw.code?.split(/[-_]/)[0]
  const dictDetails = (detailsDictionary[api?.toLowerCase() as keyof typeof detailsDictionary] ?? {})[language || 'en']
  const dictionaryDetails = raw.code && dictDetails ? dictDetails[raw.code] : {}

  if (!raw.validationDetails?.length) return { description : title, ...dictionaryDetails }
  
  const details = raw.validationDetails?.map((detail) => {
    const dict: Record<string, string> = (fieldDictionary[api?.toLowerCase() as keyof typeof fieldDictionary] ?? {})[language || 'en'] ?? {}
    const name = dict[detail.code] || detail.field || 
    (raw.code !== detail.code && dictionary[language || 'en'][detail.code]) || detail.details || ''
    return `${name}${getValues(detail)}`
  })?.filter(d => !!d)

  return { description: details ? `${title}\n${details?.join('\n')}` : title, ...dictionaryDetails }
}

/**
 * This represents the Error thrown by most Stackspot APIs.
 */
export class DefaultAPIError extends StackspotAPIError {
  /**
   * The error object as defined by the Stackspot API. If the response doesn't match the expected format this will be undefined.
   */
  data?: ErrorResponse
  /**
   * The response data, if this matches the expected format expected by a Stackspot Error, it will be the same as `data`.
   */
  raw?: any

  constructor(
    /**
     * The response's data
     */
    rawResponse: any,
    /**
     * The response's status
     */
    status: number,
    /**
     * A dictionary for translating error codes and descriptions.
     */
    dictionary: Dictionary,
    /**
     * The response's headers.
     */
    headers?: Headers,
  ) {
    let parsedResponse
    try {
      parsedResponse = JSON.parse(rawResponse)
    } catch (error) {
      parsedResponse = rawResponse
    }

    super({
      status: status,
      code: parsedResponse.code,
      message: language => createMessage(status, parsedResponse, dictionary, language),
      headers,
    })
    this.raw = parsedResponse
    if (this.raw?.code !== undefined && this.raw?.status !== undefined && this.raw?.details !== undefined) this.data = parsedResponse
  }
}
