import { HttpError, RequestOpts } from '@oazapfts/runtime'
import {
  accountDataIsAvailable,
  addAccountMemberFavorite,
  addResourcesToGroup,
  addRoleToMember,
  associateGroupToServiceCredential,
  bindGroupMembers,
  bindRoleGroups,
  bindRoles,
  bindToGroups, bindToRoles, create, createAccountRole, createGroupMapping, createPartner,
  createPersonalAccessToken,
  createServiceCredential1,
  createUser,
  deactivateFidoCredentials,
  defaults,
  deleteAccountRole,
  deleteGroupMapping,
  deleteMember,
  deleteMemberFavorite,
  deletePartner, deleteResourceFromGroup, deleteRole, deleteSso, deleteV1GroupsByGroupId, disablePersonalAccessTokenGeneration,
  disassociateGroupToServiceCredential, enableFidoCredentials,
  getAccess,
  getAccountMembers1,
  getAccountSso,
  getAllAccountSso,
  getAllGroupMapping,
  getAllMemberFidoCredentials, getFeatures,
  getGroupById,
  getGroupResources,
  getGroups,
  getMemberById,
  getMemberGroups,
  getMemberPreferences,
  getMembers,
  getPartnerAccount, getPartnersSharingAllowed,
  getPersonalClientCredentials,
  getResources,
  getResources1,
  getResourcesAndActionsWithStatus,
  getResourceTypes,
  getRoleGroups,
  getRoleMembers,
  getRoles,
  getRoles1, getRoles2,
  getScmProvider,
  getServiceCredential,
  getServiceCredentialGroups,
  getServiceCredentialPermissions,
  getServiceCredentials,
  isCreatedScmCredentials,
  isCreatedScmCredentials1,
  listAccountMemberFavorites,
  listMemberFavoritesByResource,
  listScmCredentials,
  listScmCredentials1, partialUpdateSso, personalAccessTokenAuthorization,
  removeRoleFromMember,
  resetOtp,
  resetPassword, revokeServiceCredential1, save,
  scmCredentialSave, scmCredentialSave1, scmCredentialUpdate, scmCredentialUpdate1, scmDelete, sendDownloadEmail, ssoAddAttributes,
  ssoConfigure, ssoGetAttributesConfig, ssoParseConfigurationFile, update1,
  updateAccountRole,
  updateGroupMapping,
  updateMemberPreferences,
  updatePartnerAccountAdminData,
  updatePartnerAccountData,
  updateResourceActions,
  updateRoleWithNewActions,
  updateSso,
  updateUser,
  validateNewPartnerData,
  validatePartnerAssociationLimit,
} from '../api/account'
import apis from '../apis.json'
import { DefaultAPIError } from '../error/DefaultAPIError'
import { accountDictionary } from '../error/dictionary/account'
import { StackspotAPIError } from '../error/StackspotAPIError'
import { ReactQueryNetworkClient } from '../network/ReactQueryNetworkClient'
import { CreateSCMRequest, SCMStatus, UpdateSCMRequest } from './types'

class AccountClient extends ReactQueryNetworkClient {
  constructor() {
    super(apis.account.url, defaults)
  }

  protected buildStackSpotError(error: HttpError): StackspotAPIError {
    return new DefaultAPIError(error.data, error.status, accountDictionary, error.headers)
  }

  /**
   * Gets credentials from personal service client (create if not exists one to the logged user).
   */
  generatePersonalClientCredentials = this.mutation(getPersonalClientCredentials)
  /**
   * Creates a Feature Flag
   */
  createFeatureFlag = this.mutation(create)
  /**
   * Returns information if account data (name and slug) are available to be registered
   */
  isAvailable = this.query(accountDataIsAvailable)
  /**
   * Lists all Feature Flags in an Account
   */
  featureFlags = this.query(getFeatures)
  /**
   * Gets Partners with whom it is allowed to share content.
   */
  partners = this.query(getPartnersSharingAllowed)
  /**
   * Gets Partner by account Id
   */
  partner = this.query(getPartnerAccount)
  /**
   * Creates an Account Order for Partner
   */
  createPartner = this.mutation(createPartner)
  /**
   * Updates Partner Account data.
   */
  updatePartner = this.mutation(updatePartnerAccountData)
  /**
   * Updates Partner Account Admin data.
   */
  updatePartnerAdmin = this.mutation(updatePartnerAccountAdminData)
  /**
   * Deletes Partner
   */
  deactivatePartner = this.mutation(deletePartner)
  /**
   * Validates new Partner account data
   */
  validateNewPartnerData = this.mutation(validateNewPartnerData)
  /**
   * Validates the association limit for the partner. Yields `{ isValid: true }` if valid or `{ isValid: false, message: string }`
   * otherwise.
   */
  validatePartnerAssociationLimit = this.query({
    name: 'validatePartnerAssociationLimit',
    request: async (signal) => {
      try {
        await validatePartnerAssociationLimit({ signal })
        return { isValid: true, message: '' }
      } catch (error) {
        if (error instanceof HttpError) {
          const stkError = this.buildStackSpotError(error)
          if (stkError.status === 422 || stkError.code === 'BAD_USER_INPUT') return { isValid: false, message: stkError.translate() }
        }
        throw error
      }
    },
  })
  /**
   * Gets member by id.
   */
  member = this.query(getMemberById)
  /**
   * Gets all members (paginated).
   */
  allMembers = this.infiniteQuery(getAccountMembers1)
  /**
   * Gets member Groups (paginated).
   */
  memberGroups = this.infiniteQuery(getMemberGroups)
  /**
   * Gets member roles (paginated).
   */
  memberRoles = this.infiniteQuery(getRoles1)
  /**
   * Gets member resources.
   */
  memberResources = this.query(getResources1)
  /**
   * Gets All Fido credentials for the given member (paginated).
   */
  fidoCredentials = this.infiniteQuery(getAllMemberFidoCredentials, { accumulator: 'items' })
  /**
   * Creates member on current tenant.
   */
  createMember = this.mutation(createUser)
  /**
   * Updates member on current tenant.
   */
  updateMember = this.mutation(updateUser)
  /**
   * Adds a member to several groups.
   */
  addMemberToGroups = this.mutation(bindToGroups)
  /**
   * Attributes several roles to a member.
   */
  addRolesToMember = this.mutation(bindToRoles)
  /**
   * Removes a role from a member.
   */
  removeRoleFromMember = this.mutation(removeRoleFromMember)
  /**
   * Sends an e-mail to reset the password of the member with the provided e-mail address.
   */
  resetMemberPassword = this.mutation(resetPassword)
  /**
   * Reset member OTP
   */
  resetOtp = this.mutation(resetOtp)
  /**
   * Enables Fido credentials for the given member.
   */
  enableFidoCredentials = this.mutation(enableFidoCredentials)
  /**
   * Disables Fido credentials for the given member.
   */
  disableFidoCredentials = this.mutation(deactivateFidoCredentials)
  /**
   * Gets group by id.
   */
  group = this.query(getGroupById)
  /**
   * Get all groups (paginated).
   */
  allGroups = this.infiniteQuery(getGroups)
  /**
   * Creates a group.
   */
  createGroup = this.mutation(save)
  /**
   * Updates a group.
   */
  updateGroup = this.mutation(update1)
  /**
   * Deletes a group.
   */
  deleteGroup = this.mutation(deleteV1GroupsByGroupId)
  /**
   * Gets all members in a group (paginated).
   */
  groupMembers = this.infiniteQuery(getMembers)
  /**
   * Adds several members to a group
   */
  addMembersToGroup = this.mutation(bindGroupMembers)
  /**
   * Removes a member from a group
   */
  removeMemberFromGroup = this.mutation(deleteMember)
  /**
   * Gets all roles of a group.
   */
  groupRoles = this.infiniteQuery(getRoles2)
  /**
   * Adds several roles to a group.
   */
  addRolesToGroup = this.mutation(bindRoles)
  /**
   * Removes a role from a group.
   */
  removeRoleFromGroup = this.mutation(deleteRole)
  /**
   * Gets all resources of a group (paginated).
   */
  groupResources = this.infiniteQuery(getGroupResources)
  /**
   * Adds several resources to a group.
   */
  addResourcesToGroup = this.mutation(addResourcesToGroup)
  /**
   * Removes a resource from a group.
   */
  removeResourceFromGroup = this.mutation(deleteResourceFromGroup)
  /**
   * Gets all roles in the account (paginated)
   */
  allRoles = this.infiniteQuery(getRoles)
  /**
   * Get a role by id
   */
  role = this.query({
    name: 'account.role',
    request: async (signal, { id }: { id: string }) => {
      const roles = await getRoles({ filterBy: 'id', filterValue: id }, { signal })
      if (!roles.length) throw new StackspotAPIError({ status: 404 })
      return roles[0]
    },
  })
  /**
   * Gets all members with the provided role (paginated)
   */
  roleMembers = this.infiniteQuery(getRoleMembers)
  /**
   * Creates a role
   */
  createRole = this.mutation(createAccountRole)
  /**
   * Updates a role
   */
  updateRole = this.mutation(updateAccountRole)
  /**
   * Deletes a role
   */
  deleteRole = this.mutation(deleteAccountRole)
  /**
   * Adds a role to several members 
   */
  addRoleToMembers = this.mutation(addRoleToMember)
  /**
   * Gets all groups with the provided role (paginated)
   */
  roleGroups = this.infiniteQuery(getRoleGroups)
  /**
   * Adds a role to several groups
   */
  addRoleToGroups = this.mutation(bindRoleGroups)
  /**
   * Get the actions a role is allowed to perform
   */
  rolePermissions = this.infiniteQuery(getResourcesAndActionsWithStatus)
  /**
   * Updates a role with new list of permissions
   */
  updateRolePermissions = this.mutation(updateRoleWithNewActions)
  /**
   * Updates a specific role permission
   */
  updateRolePermission = this.mutation(updateResourceActions)
  /**
   * Gets all resources (paginated)
   */
  allResources = this.infiniteQuery(getResources)
  /**
   * Gets all resource types (paginated)
   */
  allResourceTypes = this.infiniteQuery(getResourceTypes)
  /**
   * Sends an email for downloading the CLI
   */
  sendDownloadCLIEmail = this.mutation(sendDownloadEmail)
  /**
   * Creates an SCM credential (account level).
   */
  createSCMCredential = this.mutation(scmCredentialSave1 as (variables: CreateSCMRequest, opts?: RequestOpts) => Promise<unknown>)
  /**
   * Updates an SCM credential (account level).
   */
  updateSCMCredential = this.mutation(scmCredentialUpdate1 as (variables: UpdateSCMRequest, opts?: RequestOpts) => Promise<unknown>)
  /**
   * Gets all SCM credentials (account level).
   */
  allSCMCredentials = this.query(listScmCredentials1)
  /**
   * Gets the status for the SCM credential.
   * 
   * - If the SCM status is invalid because there's no configuration at the account level, it returns `{ status: 'missing-account' }`.
   * - If the SCM status is invalid because, although the SCM integration is configured, the SCM access is not, it returns
   * `{ status: 'missing-user' }`.
   * - If the SCM status is valid, it returns `{ status: 'valid', mandate: boolean, hasUserConfiguration: boolean }`. `mandate` indicates
   * if the SCM credential is mandatory at the account level for every user. `hasUserConfiguration` indicates if the user currently logged
   * in has an SCM credential configured or not.
   */
  scmCredentialStatus = this.query({
    name: 'account.scmStatus',
    request: async (signal): Promise<SCMStatus> => {
      try {
        const data = await isCreatedScmCredentials1({ signal })
        return { status: 'valid', ...data }
      } catch (error) {
        if (error instanceof HttpError) {
          // 404 means that the scm integration was not configured
          if (error.status === 404) return { status: 'missing-account' }
          // 422 means that the scm integration is configured, but the scm access is not
          if (error.status === 422) return { status: 'missing-user' }
        }
        throw error
      }
    },
  })
  /**
   * Enables Personal Access Token (PAT) generation.
   */
  enablePATGeneration = this.mutation(createPersonalAccessToken)
  /**
   * Disables Personal Access Token (PAT) generation.
   */
  disablePATGeneration = this.mutation(disablePersonalAccessTokenGeneration)
  /**
   * Verifies if Personal Access Token (PAT) generation is enabled.
   */
  patGenerationEnabled = this.query({
    name: 'account.patEnabled',
    request: async (signal) => {
      try {
        await personalAccessTokenAuthorization({ signal })
        return true
      } catch (error) {
        if (error instanceof HttpError && error.status === 404) return false
        throw error
      }
    },
  })
  /**
   * Verifies if the current user has an SCM credential configured.
   */
  userHasSCMCredential = this.query({
    name: 'account.userHasSCMCredential',
    request: async (signal) => {
      try {
        await isCreatedScmCredentials({ signal })
        return true
      } catch {
        return false
      }
    },
  })
  /**
   * Creates an SCM credential for the user currently logged in.
   */
  createUserSCMCredential = this.mutation(scmCredentialSave)
  /**
   * Updates an SCM credential for the user currently logged in.
   */
  updateUserSCMCredential = this.mutation(scmCredentialUpdate)
  /**
   * Gets all SCM credentials for the user currently logged in.
   */
  allUserSCMCredentials = this.query(listScmCredentials)
  /**
   * Gets the SCM provider.
   */
  scmProvider = this.query(getScmProvider)
  /**
   * Deletes the SCM credentials for the user currently logged in.
   */
  deleteSCMCredentials = this.mutation(scmDelete)
  /**
   * Gets all service credentials (paginated).
   */
  allServiceCredentials = this.infiniteQuery(getServiceCredentials)
  /**
   * Gets a service credential by id.
   */
  serviceCredential = this.query(getServiceCredential)
  /**
   * Gets all the permissions linked to a service credential.
   */
  serviceCredentialPermissions = this.query(getServiceCredentialPermissions)
  /**
   * Gets all groups linked to a service credential.
   */
  serviceCredentialGroups = this.query(getServiceCredentialGroups)
  /**
   * Creates a service credential.
   */
  createServiceCredential = this.mutation(createServiceCredential1)
  /**
   * Adds a service credential to several groups.
   */
  addServiceCredentialToGroups = this.mutation(associateGroupToServiceCredential)
  /**
   * Removes a service credential from a group.
   */
  removeServiceCredentialFromGroup = this.mutation(disassociateGroupToServiceCredential)
  /**
   * Revokes a service credential.
   */
  revokeServiceCredential = this.mutation(revokeServiceCredential1)
  /**
   * Creates a group mapping within an SSO.
   */
  createSSOGroupMapping = this.mutation(createGroupMapping)
  /**
   * Deletes a group mapping from an SSO.
   */
  deleteSSOGroupMapping = this.mutation(deleteGroupMapping)
  /**
   * Updates a group mapping within an SSO.
   */
  updateSSOGroupMapping = this.mutation(updateGroupMapping)
  /**
   * Get All SSO Group Mappings (paginated).
   */
  allSSOGroupMappings = this.infiniteQuery(getAllGroupMapping, { accumulator: 'items' })
  /**
   * Parses a file with a configuration for an SSO. The protocol can be either SAML or OPENID.
   */
  parseSSOConfig = this.mutation(ssoParseConfigurationFile)
  /**
   * Creates an SSO. The protocol can be either SAML or OPENID.
   */
  setupSSO = this.mutation(ssoConfigure)
  /**
   * Gets all SSOs.
   */
  allSSO = this.query(getAllAccountSso)
  /**
   * Updates an SSO. The payload will replace everything in the current configuration (won't be merged). Use `patchSSO` for merging.
   */
  updateSSO = this.mutation(updateSso)
  /**
   * Patches an SSO with a partial configuration change.
   */
  patchSSO = this.mutation(partialUpdateSso)
  /**
   * Gets an SSO by id.
   */
  sso = this.query(getAccountSso)
  /**
   * Deletes an SSO.
   */
  deleteSSO = this.mutation(deleteSso)
  /**
   * Gets the attributes of an SSO.
   */
  ssoAttributes = this.query(ssoGetAttributesConfig)
  /**
   * Updates the attributes in a SSO.
   */
  updateSSOAttributes = this.mutation(ssoAddAttributes)

  /**
   * Gets the preferences of a member.
   */
  preferences = this.query(getMemberPreferences)

  /**
   * Updates the preferences of a member.
   */
  updatePreferences = this.mutation(updateMemberPreferences)

  /**
   * Get account member favorite resources
 */
  getAccountMemberFavoriteResources = this.query(listAccountMemberFavorites)
  /**
   * Add account member favorite resource
 */
  addAccountMemberFavoriteResource = this.mutation(addAccountMemberFavorite)
  /**
   * Get member favorite resources by type
 */
  getMemberFavoriteResourcesByType = this.query(listMemberFavoritesByResource)
  /**
   * Remove resource from member favorites
 */
  removeResourceFromMemberFavorites = this.mutation(deleteMemberFavorite)
  /**
   * Validate permission access
   */
  validatePermissionAccess = this.query({
    name: 'account.getAccess',
    request: async (signal, variables: Parameters<typeof getAccess>[0]) => {
      try {
        await getAccess(variables, { signal })
        return true
      } catch {
        return false
      }
    },
    permission: this.createPermissionFunctionFor(getAccess),
  })
}

export const accountClient = new AccountClient()
