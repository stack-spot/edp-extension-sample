import { HttpError } from '@oazapfts/runtime'
import { CompletablePromise } from '@stack-spot/opa'
import { cloneDeep } from 'lodash'
import { defaults, EventProcessingResponse, Event as EventType, sendEvents } from '../api/eventBus'
import apis from '../apis.json'
import { DefaultAPIError } from '../error/DefaultAPIError'
import { baseDictionary } from '../error/dictionary/base'
import { StackspotAPIError } from '../error/StackspotAPIError'
import { NetworkClient } from '../network/NetworkClient'

export const EVENTS_STORAGE_IDENTIFIER = 'eventsError'
const DEFER_MS = 5000
class EventBusClient extends NetworkClient {
  private queue: EventType[] = []
  private deferred = new CompletablePromise<EventProcessingResponse>()
  private timeout: number | undefined
  private lock = false

  constructor() {
    super(apis.eventBus.url)
    defaults.baseUrl = ''
    defaults.fetch = (...args) => this.fetch(...args)
  }

  protected buildStackSpotError(error: HttpError): StackspotAPIError {
    return new DefaultAPIError(error.data, error.status, baseDictionary, error.headers)
  }
  
  private async consume() {
    if (this.queue.length === 0) return
    if (this.lock) return this.timeout = window.setTimeout(() => this.consume(), DEFER_MS)

    this.lock = true
    const deferred = this.deferred
    this.deferred = new CompletablePromise()
    const sendingQueue = cloneDeep(this.queue)
    this.queue = []

    const storageEvents = JSON.parse(localStorage.getItem(EVENTS_STORAGE_IDENTIFIER) || '[]')

    const bodyData = {
      events: sendingQueue.concat(storageEvents),
    }

    try {
      const allResults: EventProcessingResponse = await sendEvents({ sendEventsRequest: bodyData })

      if (allResults.errorCount === 0) {
        localStorage.removeItem(EVENTS_STORAGE_IDENTIFIER)
      }
      deferred.resolve(allResults)

    } catch (error: any) {
      if (error instanceof HttpError) {
        deferred.reject(new Error(`Error while sending events. Network error ${error.status}.\n}`))
      }
      throw error
    }
  }

  private async add(event: EventType) {
    if (this.timeout) window.clearTimeout(this.timeout)
    const index = this.queue.length
    this.queue.push(event)
    this.timeout = window.setTimeout(() => this.consume(), DEFER_MS)
    const response = await this.deferred.promise
    const result = response.results[index]
    if ('errorCode' in result) {
      throw result
    }
    return result
  }

  /**
   * Sends an event
   */
  sendEvent = async (event: EventType) => {
    await this.add(event)
  }
}

export const eventBusClient = new EventBusClient()
