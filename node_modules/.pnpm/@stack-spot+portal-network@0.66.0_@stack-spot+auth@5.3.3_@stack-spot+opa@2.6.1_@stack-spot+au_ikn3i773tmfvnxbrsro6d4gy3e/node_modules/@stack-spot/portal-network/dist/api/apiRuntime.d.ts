/**
 * Runtime Manager API
 * v1.0.0
 * DO NOT MODIFY - This file has been generated using oazapfts.
 * See https://www.npmjs.com/package/oazapfts
 */
import * as Oazapfts from "@oazapfts/runtime";
export declare const defaults: Oazapfts.Defaults<Oazapfts.CustomHeaders>;
export declare const servers: {
    generatedServerUrl: string;
};
export type TaskDataS3BackendResponse = {
    bucket: string;
    region: string;
    key: string;
};
export type TaskIacDataResponsePlugin = {
    pluginAppliedAlias: string;
    name: string;
    inputs: {
        [key: string]: object;
    };
};
export type TaskIacDataResponseConnector = {
    connector: string;
    alias: string;
    "type": string;
    pluginName: string;
    attributes: {
        [key: string]: object;
    };
    writeToFile: boolean;
};
export type TaskIacDataResponse = {
    schemaVersion: string;
    runId: string;
    runTaskId: string;
    realm: string;
    iacBackend: TaskDataS3BackendResponse;
    workspaceName: string;
    plugin: TaskIacDataResponsePlugin;
    connectors: TaskIacDataResponseConnector[];
    metadata?: {
        [key: string]: object;
    };
    runEnvironment: string[];
};
export type ValidationDetails = {
    code: string;
    field?: string;
    details?: string;
    values?: string[];
};
export type ErrorResponse = {
    code: "RTM_ACCESS_TOKEN_NOT_RECEIVED_FROM_IDM" | "RTM_EVENTS_NOT_SENT" | "RTM_BAD_REQUEST_ERROR" | "RTM_MANDATORY_PARAM_NOT_INFORMED" | "RTM_MANDATORY_ATTR_NOT_INFORMED" | "RTM_ATTR_INVALID" | "RTM_ATTR_INVALID_FORMAT" | "RTM_ATTR_INVALID_EVALUATED_FROM_VALIDATIONS_LENGTH" | "RTM_ATTR_INVALID_EVALUATED_FROM_VALIDATIONS_EMAIL" | "RTM_ATTR_INVALID_EVALUATED_FROM_VALIDATIONS_PATTERN" | "RTM_UNABLE_TO_PARSE_REQUEST" | "RTM_CANNOT_DESTROY" | "RTM_ALREADY_DESTROYED" | "RTM_CONNECTION_INTERFACE_IN_USE" | "RTM_CANNOT_IDENTIFY_USER" | "RTM_TASK_TYPE_NOT_CORRECT" | "RTM_GENERIC_BUSINESS_ERROR" | "RTM_TASK_NOT_READY_TO_RUN" | "RTM_TASK_NOT_RUNNING" | "RTM_DEPLOYMENT_WITHOUT_INFRA_OR_APP_ID" | "RTM_CREATING_CONN_INTERFACE_ERROR" | "RTM_CREATING_CONN_INTERFACE_MISSING_ATTRIBUTES" | "RTM_IMPERSONATE_TOKEN_ERROR" | "RTM_UNEXPECTED_RUNTIME_ENVIRONMENT_CONFIG" | "RTM_RUN_WITH_NO_TASKS_ERROR" | "RTM_TASK_TYPE_NOT_SUPPORTED" | "RTM_SELF_HOSTED_BACKEND_NOT_CONFIGURED" | "RTM_DEPENDENCIES_HAS_CYCLE" | "RTM_UNAVAILABLE_DESTROY_PROCESS" | "RTM_DEPLOYMENT_WITH_INFRA_AND_APP" | "RTM_DEPLOYMENT_JUST_ONE_RUN_NOT_FINISHED" | "RTM_GENERIC_CONFLICT_ERROR" | "RTM_DEPLOYMENT_APP_ALREADY_RUNNING_CONFLICT_ERROR" | "RTM_DEPLOYMENT_INFRA_ALREADY_RUNNING_CONFLICT_ERROR" | "RTM_DEPLOYMENT_TAG_ALREADY_EXISTS" | "RTM_NOT_FOUND" | "RTM_PROVIDER_NOT_FOUND" | "RTM_STATE_NOT_FOUND" | "RTM_ENVIRONMENT_NOT_FOUND_ERROR" | "RTM_DEPLOYMENT_NOT_FOUND_ERROR" | "RTM_PLUGIN_DEPLOYMENT_NOT_FOUND_ERROR" | "RTM_WORKSPACE_NOT_FOUND" | "RTM_APPLICATION_NOT_FOUND" | "RTM_INFRA_LINK_NOT_FOUND" | "RTM_RUN_NOT_FOUND" | "RTM_RUN_TASK_NOT_FOUND" | "RTM_CONNECTION_INTERFACE_NOT_FOUND" | "RTM_PLUGIN_MANIFESTO_NOT_FOUND" | "RTM_PLUGIN_DATA_NOT_FOUND" | "RTM_DEPLOYMENT_TAG_NOT_FOUND" | "RTM_RUN_WITH_TOO_MANY_PLUGINS" | "RTM_TOO_MANY_RUNS" | "RTM_FORBIDDEN" | "RTM_MISSING_ACCOUNT" | "RTM_MISSING_AUTHENTICATION" | "RTM_WORKSPACE_API_FORBIDDEN" | "RTM_WORKSPACE_API_UNHANDLED_ERROR" | "RTM_WORKSPACE_API_UNPROCESSABLE_ENTITY" | "RTM_WORKSPACE_API_INTERNAL_ERROR" | "RTM_WORKSPACE_API_BAD_GATEWAY" | "RTM_CONTENT_API_FORBIDDEN" | "RTM_CONTENT_API_UNHANDLED_ERROR" | "RTM_CONTENT_API_INTERNAL_ERROR" | "RTM_CLOUD_SERVICES_API_FORBIDDEN" | "RTM_CLOUD_SERVICES_API_UNHANDLED_ERROR" | "RTM_CLOUD_SERVICES_FAILED_TO_RETRIEVE_EXTERNAL_ID" | "RTM_CLOUD_SERVICES_API_INTERNAL_ERROR" | "RTM_GENERIC_INTEGRATION_ERROR" | "RTM_ACCOUNT_API_PAT_NOT_FOUND_ERROR" | "RTM_ACCOUNT_API_FORBIDDEN" | "RTM_ACCOUNT_API_UNHANDLED_ERROR" | "RTM_ACCOUNT_API_INTERNAL_ERROR" | "RTM_S3_UNHANDLED_ERROR" | "RTM_INTERNAL_SERVER_ERROR" | "RTM_CREATING_CONN_INTERFACE_WORKER_ERROR" | "RTM_SECURITY_KEY_ALREADY_REGISTERED_IN_BLOCK_LIST" | "RTM_SECURITY_BLOCK_LIST_ERROR" | "RTM_RUN_TYPE_NOT_CORRECT" | "RTM_IAC_PATH_NOT_PRESENT";
    status: number;
    details: string;
    validationDetails?: ValidationDetails[];
};
export type RunSelfHostedTaskIacCompletedRequest = {
    /** The schema version */
    schemaVersion: string;
    /** The Run ULID */
    runId: string;
    /** The Task ULID */
    runTaskId: string;
    /** Whether this task completed successfully or not */
    status: "SUCCESS" | "INTERNAL_ERROR";
    /** The error message, if it exists */
    messageError?: string;
    /** Metadata */
    metadata?: {
        [key: string]: object;
    };
};
export type TaskDestroyDataResponse = {
    schemaVersion: string;
    runId: string;
    runTaskId: string;
    iacBackend: TaskDataS3BackendResponse;
    tfBackend: TaskDataS3BackendResponse;
    metadata?: {
        [key: string]: object;
    };
    runEnvironment: string[];
};
export type RunSelfHostedTaskDestroyCompletedRequest = {
    /** The schema version */
    schemaVersion: string;
    /** The Run ULID */
    runId: string;
    /** The Task ULID */
    runTaskId: string;
    /** Whether this task completed successfully or not */
    status: "SUCCESS" | "INTERNAL_ERROR" | "FAILED";
    /** The error message, if it exists */
    messageError?: string;
    /** The deploy output, to be used to generate the connection interfaces */
    output?: {
        [key: string]: object;
    };
    /** Metadata */
    metadata?: {
        [key: string]: object;
    };
    /** partialResources */
    partialResources?: string[];
};
export type TaskDeployDataResponse = {
    schemaVersion: string;
    runId: string;
    runTaskId: string;
    iacBackend: TaskDataS3BackendResponse;
    tfBackend: TaskDataS3BackendResponse;
    metadata?: {
        [key: string]: object;
    };
    runEnvironment: string[];
};
export type RunSelfHostedTaskDeployCompletedRequest = {
    /** The schema version */
    schemaVersion: string;
    /** The Run ULID */
    runId: string;
    /** The Task ULID */
    runTaskId: string;
    /** Whether this task completed successfully or not */
    status: "SUCCESS" | "INTERNAL_ERROR" | "FAILED";
    /** The error message, if it exists */
    messageError?: string;
    /** The deploy output, to be used to generate the connection interfaces */
    output?: {
        [key: string]: object;
    };
    /** Metadata */
    metadata?: {
        [key: string]: object;
    };
    partialResources?: string[];
};
export type ConfigTerraform = {
    /** name of the bucket to save state files */
    bucket: string;
    /** name of the region of the bucket */
    region: string;
};
export type Config = {
    tfstate: ConfigTerraform;
    iac: ConfigTerraform;
};
export type RunSelfHostedRollbackRequest = {
    /** Application Id */
    appId?: string;
    /** Shared Infra Id */
    infraId?: string;
    /** Environment Id */
    envId: string;
    /** Current version tag to rollback */
    tag: string;
    config: Config;
    /** Url of pipeline currently running */
    pipelineUrl: string;
};
export type RunSelfHostedTaskResponse = {
    order: number;
    runTaskId: string;
    taskType: string;
    pluginAppliedAlias: string;
};
export type RunSelfHostedResponse = {
    runId: string;
    runType: string;
    tasks: RunSelfHostedTaskResponse[];
};
export type RunSelfHostedDestroyRequest = {
    /** Application Id */
    appId?: string;
    /** Shared Infra Id */
    infraId?: string;
    /** Workspace Id */
    workspaceId: string;
    /** Environment Id */
    envId: string;
    config: Config;
    /** Url of pipeline currently running */
    pipelineUrl: string;
};
export type ManifestoMetadata = {
    /** Name */
    name: string;
    isTest?: string;
};
export type Connection = {
    /** Required connector name */
    selected: string;
    /** Required connector type */
    "type": string;
    /** Required connector label reference */
    alias: string;
};
export type ManifestoConnection = {
    requires?: Connection[];
    generates?: Connection[];
};
export type Link = {
    /** Required link name */
    name: string;
    /** Required link url */
    url: string;
    /** Required link type */
    "type": string;
    /** Link picture path */
    picture: string;
};
export type ManifestoLink = {
    generates?: Link[];
};
export type AppliedPlugin = {
    /** Plugin Alias */
    alias: string;
    /** Plugin Name */
    name: string;
    /** Plugin Version Id */
    pluginVersionId: string;
    /** Stack Version Id */
    stackVersionId: string;
    /** Plugin Type */
    "type": string;
    inputs: {
        [key: string]: object;
    };
    connections: ManifestoConnection;
    links?: ManifestoLink;
};
export type ManifestoSpec = {
    /** Application Or Infra Id ( */
    id: string;
    /** Repository */
    repository?: string;
    appliedPlugins: AppliedPlugin[];
};
export type Manifesto = {
    /** Schema Version */
    schemaVersion: string;
    /** Manifesto Kind */
    kind: string;
    metadata: ManifestoMetadata;
    spec: ManifestoSpec;
};
export type RunSelfHostedDeployRequest = {
    /** Environment Id */
    envId: string;
    /** Workspace Id */
    workspaceId: string;
    /** Version tag that will be generated by the deploy run if successful */
    versionTag: string;
    /** Run Configuration */
    runConfig?: {
        [key: string]: object;
    };
    manifesto: Manifesto;
    /** Whether this application exposes an API or not */
    isApi?: boolean;
    /** Path (in the repository) of the API contract file in open api format */
    apiContractPath?: string;
    config: Config;
    /** Url of pipeline currently running */
    pipelineUrl: string;
};
export type RunDestroyRequest = {
    /** Application Id */
    appId?: string;
    /** Shared Infra Id */
    infraId?: string;
    /** Workspace Id */
    workspaceId: string;
    /** Environment Id */
    envId: string;
};
export type RunCreatedResponse = {
    runId: string;
};
export type WorkerResponse = {
    allowed: boolean;
    reason?: string;
};
export type RunRollbackRequest = {
    /** Application Id */
    appId?: string;
    /** Shared Infra Id */
    infraId?: string;
    /** Environment Id */
    envId: string;
    /** Current version tag to rollback */
    tag: string;
};
export type RunDeployRequest = {
    /** Environment Id */
    envId: string;
    /** Workspace Id */
    workspaceId: string;
    /** Version tag that will be generated by the deploy run if successful */
    versionTag: string;
    /** Run Configuration */
    runConfig?: {
        [key: string]: object;
    };
    manifesto: Manifesto;
    /** Whether this application exposes an API or not */
    isApi?: boolean;
    /** Path (in the repository) of the API contract file in open api format */
    apiContractPath?: string;
};
export type Unit = object;
export type FinishWorkerIacSchema = {
    schemaVersion: string;
    runTaskId: string;
    runId?: string;
    status: "SUCCESS" | "INTERNAL_ERROR";
    messageError: string;
    metadata?: {
        [key: string]: object;
    };
};
export type FinishWorkerDestroySchema = {
    schemaVersion: string;
    runTaskId: string;
    runId?: string;
    status: "SUCCESS" | "INTERNAL_ERROR" | "FAILED";
    messageError: string;
    tfstatePath?: string;
    metadata?: {
        [key: string]: object;
    };
    partialResources?: string[];
};
export type FinishWorkerDeploySchema = {
    schemaVersion: string;
    runTaskId: string;
    runId?: string;
    status: "SUCCESS" | "INTERNAL_ERROR" | "FAILED";
    messageError: string;
    metadata?: {
        [key: string]: object;
    };
    output?: {
        [key: string]: object;
    };
    partialResources?: string[];
};
export type TagResponse = {
    name: string;
    createdAt: string;
    head: boolean;
};
export type EnvironmentResponse = {
    name?: string;
};
export type RunTaskResponse = {
    id?: string;
    "type": "IAC" | "DEPLOY" | "DESTROY" | "IAC_SELF_HOSTED" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED";
    status: "PENDING" | "READY_TO_RUN" | "RUNNING" | "SUCCEEDED" | "FAILED" | "INTERNAL_ERROR" | "EXTERNAL_ERROR" | "ABORTED";
    errorDetails?: string;
    logs?: string;
};
export type RunPluginResponse = {
    pluginAppliedAlias: string;
    tasks: RunTaskResponse[];
};
export type RunResponse = {
    runId: string;
    appId?: string;
    infraId?: string;
    envId: string;
    deploymentId?: string;
    "type": "DEPLOY" | "DESTROY" | "ROLLBACK" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "ROLLBACK_SELF_HOSTED";
    status: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
    createdAt: string;
    updatedAt?: string;
    appliedPlugins?: RunPluginResponse[];
};
export type RunLightResponse = {
    runId: string;
    appId?: string;
    infraId?: string;
    envId: string;
    deploymentId?: string;
    author?: string;
    "type": "DEPLOY" | "DESTROY" | "ROLLBACK" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "ROLLBACK_SELF_HOSTED";
    status: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
    createdAt: string;
    updatedAt?: string;
};
export type ConnectionInterfaceResponse = {
    name: string;
    "type": string;
    outputs: {
        [key: string]: object;
    };
};
export type PluginDeploymentResponse = {
    pluginAppliedAlias: string;
    pluginVersionId: string;
    stackVersionId: string;
    inputs: {
        [key: string]: object;
    };
    connectors: ConnectionInterfaceResponse[];
};
export type DeploymentResponse = {
    deploymentId: string;
    appId?: string;
    infraId?: string;
    envId: string;
    head: boolean;
    tag?: string;
    createdAt?: string;
    plugins: PluginDeploymentResponse[];
};
export type DeploymentStatusModel = {
    status: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
};
export type DiffPluginResponse = {
    appManifesto: {
        [key: string]: object;
    };
};
export type Pageable = {
    page?: number;
    size?: number;
    sort?: string[];
};
export type SortObject = {
    unsorted?: boolean;
    sorted?: boolean;
    empty?: boolean;
};
export type PageableObject = {
    paged?: boolean;
    unpaged?: boolean;
    pageNumber?: number;
    pageSize?: number;
    offset?: number;
    sort?: SortObject;
};
export type AdminRunTaskResponse = {
    id?: string;
    "type": "IAC" | "DEPLOY" | "DESTROY" | "IAC_SELF_HOSTED" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED";
    status: "PENDING" | "READY_TO_RUN" | "RUNNING" | "SUCCEEDED" | "FAILED" | "INTERNAL_ERROR" | "EXTERNAL_ERROR" | "ABORTED";
    errorDetails?: string;
    logs?: string;
    iac?: string;
};
export type AdminRunPluginResponse = {
    pluginAppliedAlias: string;
    tasks: AdminRunTaskResponse[];
};
export type AdminRunResponse = {
    runId: string;
    appId?: string;
    infraId?: string;
    envId: string;
    deploymentId?: string;
    manifesto: {
        [key: string]: object;
    };
    "type": "DEPLOY" | "DESTROY" | "ROLLBACK" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "ROLLBACK_SELF_HOSTED";
    status: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
    createdAt: string;
    updatedAt?: string;
    appliedPlugins?: AdminRunPluginResponse[];
};
export type PageAdminRunResponse = {
    totalPages?: number;
    totalElements?: number;
    pageable?: PageableObject;
    numberOfElements?: number;
    size?: number;
    content?: AdminRunResponse[];
    "number"?: number;
    sort?: SortObject;
    first?: boolean;
    last?: boolean;
    empty?: boolean;
};
export type SelfHostedConfigModel = {
    terraformBucket: string;
    terraformRegion: string;
    iacBucket: string;
    iacRegion: string;
};
export type AdminRunTaskDetailResponse = {
    runTaskId: string;
    runId: string;
    deploymentId: string;
    userRef?: string;
    workspaceId: string;
    workspaceName: string;
    accountId: string;
    envId: string;
    appId?: string;
    infraId?: string;
    realm: string;
    pluginAppliedAlias: string;
    pluginManifesto: {
        [key: string]: object;
    };
    pluginFQDN: string;
    runTaskType: "IAC" | "DEPLOY" | "DESTROY" | "IAC_SELF_HOSTED" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED";
    runTasksStatus: "PENDING" | "READY_TO_RUN" | "RUNNING" | "SUCCEEDED" | "FAILED" | "INTERNAL_ERROR" | "EXTERNAL_ERROR" | "ABORTED";
    errorDetails?: string;
    iacPath?: string;
    workerUrl?: string;
    runTaskData: {
        [key: string]: object;
    };
    requiredRunTasks: string[];
    order: number;
    selfHostedConfig?: SelfHostedConfigModel;
    exception?: string;
    iacDownloadUrl?: string;
    logsDownloadUrl?: string;
};
/**
 * Endpoint to get the necessary data to perform an IAC Task
 */
export declare function getIacTask({ taskId }: {
    taskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TaskIacDataResponse>;
/**
 * Endpoint to inform the completion of an IAC Task
 */
export declare function putIacTaskResponse({ taskId, runSelfHostedTaskIacCompletedRequest }: {
    taskId: string;
    runSelfHostedTaskIacCompletedRequest: RunSelfHostedTaskIacCompletedRequest;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to get the necessary data to perform an Destroy Task
 */
export declare function getDestroyTask({ taskId }: {
    taskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TaskDestroyDataResponse>;
/**
 * Endpoint to inform the completion of a Destroy Task
 */
export declare function putDestroyTaskResponse({ taskId, runSelfHostedTaskDestroyCompletedRequest }: {
    taskId: string;
    runSelfHostedTaskDestroyCompletedRequest: RunSelfHostedTaskDestroyCompletedRequest;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to get the necessary data to perform a Deploy Task
 */
export declare function getDeployTask({ taskId }: {
    taskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TaskDeployDataResponse>;
/**
 * Endpoint to inform the completion of a Deploy Task
 */
export declare function putDeployTaskResponse({ taskId, runSelfHostedTaskDeployCompletedRequest }: {
    taskId: string;
    runSelfHostedTaskDeployCompletedRequest: RunSelfHostedTaskDeployCompletedRequest;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to get the necessary data to perform an IAC Task
 */
export declare function getIacTask1({ taskId }: {
    taskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TaskIacDataResponse>;
/**
 * Endpoint to inform the completion of an IAC Task
 */
export declare function putIacTaskResponse1({ taskId, runSelfHostedTaskIacCompletedRequest }: {
    taskId: string;
    runSelfHostedTaskIacCompletedRequest: RunSelfHostedTaskIacCompletedRequest;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to get the necessary data to perform an Destroy Task
 */
export declare function getDestroyTask1({ taskId }: {
    taskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TaskDestroyDataResponse>;
/**
 * Endpoint to inform the completion of a Destroy Task
 */
export declare function putDestroyTaskResponse1({ taskId, runSelfHostedTaskDestroyCompletedRequest }: {
    taskId: string;
    runSelfHostedTaskDestroyCompletedRequest: RunSelfHostedTaskDestroyCompletedRequest;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to get the necessary data to perform a Deploy Task
 */
export declare function getDeployTask1({ taskId }: {
    taskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TaskDeployDataResponse>;
/**
 * Endpoint to inform the completion of a Deploy Task
 */
export declare function putDeployTaskResponse1({ taskId, runSelfHostedTaskDeployCompletedRequest }: {
    taskId: string;
    runSelfHostedTaskDeployCompletedRequest: RunSelfHostedTaskDeployCompletedRequest;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to run Infra Rollback
 */
export declare function runRollbackInfra({ runSelfHostedRollbackRequest }: {
    runSelfHostedRollbackRequest: RunSelfHostedRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run App Rollback
 */
export declare function runRollbackApp({ runSelfHostedRollbackRequest }: {
    runSelfHostedRollbackRequest: RunSelfHostedRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run Destroy SelfHosted
 */
export declare function runDestroyInfra({ runSelfHostedDestroyRequest }: {
    runSelfHostedDestroyRequest: RunSelfHostedDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Destroy SelfHosted
 */
export declare function runDestroyApp({ runSelfHostedDestroyRequest }: {
    runSelfHostedDestroyRequest: RunSelfHostedDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Infra Deploy
 */
export declare function runDeployInfra({ runSelfHostedDeployRequest }: {
    runSelfHostedDeployRequest: RunSelfHostedDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run App Deploy
 */
export declare function runDeployApp({ runSelfHostedDeployRequest }: {
    runSelfHostedDeployRequest: RunSelfHostedDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run Infra Deploy
 */
export declare function runDestroyInfra1({ runDestroyRequest }: {
    runDestroyRequest: RunDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to run App Deploy
 */
export declare function runDestroyApp1({ runDestroyRequest }: {
    runDestroyRequest: RunDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to identify the worker that got this tasks to process
 */
export declare function getRunTaskById({ taskId, workerUrl }: {
    taskId: string;
    workerUrl: string;
}, opts?: Oazapfts.RequestOpts): Promise<WorkerResponse>;
/**
 * Endpoint to run Infra Rollback
 */
export declare function runRollbackInfra1({ runSelfHostedRollbackRequest }: {
    runSelfHostedRollbackRequest: RunSelfHostedRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run App Rollback
 */
export declare function runRollbackApp1({ runSelfHostedRollbackRequest }: {
    runSelfHostedRollbackRequest: RunSelfHostedRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run Destroy SelfHosted
 */
export declare function runDestroyInfra2({ runSelfHostedDestroyRequest }: {
    runSelfHostedDestroyRequest: RunSelfHostedDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Destroy SelfHosted
 */
export declare function runDestroyApp2({ runSelfHostedDestroyRequest }: {
    runSelfHostedDestroyRequest: RunSelfHostedDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Infra Deploy
 */
export declare function runDeployInfra1({ runSelfHostedDeployRequest }: {
    runSelfHostedDeployRequest: RunSelfHostedDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run App Deploy
 */
export declare function runDeployApp1({ runSelfHostedDeployRequest }: {
    runSelfHostedDeployRequest: RunSelfHostedDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run Infra Rollback
 */
export declare function runRollbackInfra2({ runRollbackRequest }: {
    runRollbackRequest: RunRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to run App Rollback
 */
export declare function runRollbackApp2({ runRollbackRequest }: {
    runRollbackRequest: RunRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to run Destroy
 */
export declare function runDestroyInfra3({ runDestroyRequest }: {
    runDestroyRequest: RunDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Destroy
 */
export declare function runDestroyApp3({ runDestroyRequest }: {
    runDestroyRequest: RunDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Infra Deploy
 */
export declare function runDeployInfra2({ runDeployRequest }: {
    runDeployRequest: RunDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to run App Deploy
 */
export declare function runDeployApp2({ runDeployRequest }: {
    runDeployRequest: RunDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to cancel a run that's currently running
 */
export declare function cancelAppRunByRunId({ runId, force }: {
    runId: string;
    force?: boolean;
}, opts?: Oazapfts.RequestOpts): Promise<object>;
/**
 * Simulate a response from deploy worker
 */
export declare function simulateIacWorkerResponse({ finishWorkerIacSchema }: {
    finishWorkerIacSchema: FinishWorkerIacSchema;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Endpoint to cancel a run that's currently running
 */
export declare function simulateIacWorkerResponseForAllTasks({ runId }: {
    runId: string;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Simulate a response from deploy worker
 */
export declare function simulateDestroyWorkerResponse({ finishWorkerDestroySchema }: {
    finishWorkerDestroySchema: FinishWorkerDestroySchema;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Simulate a response from deploy worker
 */
export declare function simulateDeployWorkerResponse({ finishWorkerDeploySchema }: {
    finishWorkerDeploySchema: FinishWorkerDeploySchema;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Endpoint to force to resend all "ready to run" tasks by runId
 */
export declare function resendTasks({ runId }: {
    runId: string;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Endpoint to force status RUNTIME_ERROR to a run by runId
 */
export declare function setRunAsFailed({ runId }: {
    runId: string;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Endpoint to block a StackSpot Workspace to perform Runtime operations
 */
export declare function blockWorkspace({ workspaceId }: {
    workspaceId: string;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to block a StackSpot Account to perform Runtime operations
 */
export declare function blockAccount({ accountId }: {
    accountId: string;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to get tag data
 */
export declare function getTagsByInfraIdAndEnvId({ infraId, envId }: {
    infraId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TagResponse[]>;
/**
 * Endpoint to get tag data
 */
export declare function getTagsByAppIdAndEnvId({ appId, envId }: {
    appId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TagResponse[]>;
/**
 * Endpoint to get environment
 */
export declare function getAllEnvironmentConfiguration(opts?: Oazapfts.RequestOpts): Promise<EnvironmentResponse[]>;
/**
 * Endpoint to get run data by runId
 */
export declare function getRunById({ runId }: {
    runId: string;
}, opts?: Oazapfts.RequestOpts): Promise<RunResponse>;
/**
 * Endpoint to get runs data by infraId and envId, sorted by createdAt descending
 */
export declare function getRunsByInfraIdAndEnvId({ size, page, infraId, envId, status }: {
    size?: number;
    page?: number;
    infraId: string;
    envId: string;
    status?: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
}, opts?: Oazapfts.RequestOpts): Promise<RunLightResponse[]>;
/**
 * Endpoint to get runs data by appId and envId, sorted by createdAt descending
 */
export declare function getRunsByAppIdAndEnvId({ size, page, appId, envId, status }: {
    size?: number;
    page?: number;
    appId: string;
    envId: string;
    status?: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
}, opts?: Oazapfts.RequestOpts): Promise<RunLightResponse[]>;
/**
 * Endpoint to get deployment data by deploymentId
 */
export declare function getDeploymentById({ deploymentId }: {
    deploymentId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse>;
/**
 * Endpoint to get deployment data by infraId and envId, sorted by creation date descending
 */
export declare function getDeploymentByInfraIdAndEnvId({ size, page, infraId, envId }: {
    size?: number;
    page?: number;
    infraId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse[]>;
/**
 * Endpoint to get deployment head data by appId and envId
 */
export declare function getDeploymentHeadByInfraIdAndEnvId({ infraId, envId }: {
    infraId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse>;
/**
 * Endpoint to get last deployment status
 */
export declare function getDeploymentStatus({ appId, envId }: {
    appId?: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentStatusModel>;
/**
 * Endpoint to get last deployment status
 */
export declare function getDeploymentStatus1({ infraId, envId }: {
    infraId?: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentStatusModel>;
export declare function getDiffByInfra({ infraId, envId }: {
    infraId?: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DiffPluginResponse>;
export declare function getDiffByApp({ appId, envId }: {
    appId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DiffPluginResponse>;
/**
 * Endpoint to get deployment data by appId and envId, sorted by creation date descending
 */
export declare function getDeploymentByAppIdAndEnvId({ size, page, appId, envId }: {
    size?: number;
    page?: number;
    appId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse[]>;
/**
 * Endpoint to get deployment head data by appId and envId
 */
export declare function getDeploymentHeadByAppIdAndEnvId({ appId, envId }: {
    appId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse>;
/**
 * Get task with workspaceName, appId or InfraId that have status RUNNING
 */
export declare function getAdminRunStatusRunningDetails({ workspaceName, pageable }: {
    workspaceName: string;
    pageable: Pageable;
}, opts?: Oazapfts.RequestOpts): Promise<PageAdminRunResponse>;
/**
 * Get task with workspaceName, appId or InfraId that have status RUNNING
 */
export declare function getAdminRunStatusRunningDetails1({ infraId, pageable }: {
    infraId?: string;
    pageable: Pageable;
}, opts?: Oazapfts.RequestOpts): Promise<PageAdminRunResponse>;
/**
 * Get task with workspaceName, appId or InfraId that have status RUNNING
 */
export declare function getAdminRunStatusRunningDetails2({ appId, pageable }: {
    appId?: string;
    pageable: Pageable;
}, opts?: Oazapfts.RequestOpts): Promise<PageAdminRunResponse>;
/**
 * Get task details from run task id
 */
export declare function getAdminRunTaskDetails({ runTaskId }: {
    runTaskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<AdminRunTaskDetailResponse>;
/**
 * Get a run from run or run task id
 */
export declare function getAdminRun({ runId, runTaskId }: {
    runId?: string;
    runTaskId?: string;
}, opts?: Oazapfts.RequestOpts): Promise<AdminRunResponse>;
//# sourceMappingURL=apiRuntime.d.ts.map