import { every, isString } from 'lodash';
import { StackspotAPIError } from './StackspotAPIError.js';
import { baseDictionary } from './dictionary/base.js';
import { cntFields } from './dictionary/cnt-fields.js';
import { workspaceFields } from './dictionary/workspace-fields.js';
import { workspaceDetails } from './dictionary/workspace-details.js';
import { actionDetails } from './dictionary/action-details.js';
// these details don't say anything the status already doesn't and we'd better use local translations for them.
const ignoredDescriptions = [
    'internal server error', 'not found', 'gateway timeout', 'temporally unavailable', 'forbidden', 'unauthorized', 'bad request',
];
const fieldDictionary = {
    cnt: cntFields,
    wks: workspaceFields,
};
const detailsDictionary = {
    wks: workspaceDetails,
    actionapi: actionDetails,
};
function getTitle(status, raw, dictionary, language) {
    if (dictionary[language][raw.code])
        return dictionary[language][raw.code];
    if (raw.details && !ignoredDescriptions.includes(raw.details))
        return raw.details;
    return baseDictionary[language][status] || baseDictionary[language].defaultTitle;
}
function getValues(detail) {
    return detail.values && every(detail.values, isString) ? `\n${detail.values.join('\n')}` : '';
}
function createMessage(status, raw, dictionary, language) {
    const title = getTitle(status, raw, dictionary, language || 'en');
    const api = raw.code?.split(/[-_]/)[0];
    const dictDetails = (detailsDictionary[api?.toLowerCase()] ?? {})[language || 'en'];
    const dictionaryDetails = raw.code && dictDetails ? dictDetails[raw.code] : {};
    if (!raw.validationDetails?.length)
        return { description: title, ...dictionaryDetails };
    const details = raw.validationDetails?.map((detail) => {
        const dict = (fieldDictionary[api?.toLowerCase()] ?? {})[language || 'en'] ?? {};
        const name = dict[detail.code] || detail.field ||
            (raw.code !== detail.code && dictionary[language || 'en'][detail.code]) || detail.details || '';
        return `${name}${getValues(detail)}`;
    })?.filter(d => !!d);
    return { description: details ? `${title}\n${details?.join('\n')}` : title, ...dictionaryDetails };
}
/**
 * This represents the Error thrown by most Stackspot APIs.
 */
export class DefaultAPIError extends StackspotAPIError {
    constructor(
    /**
     * The response's data
     */
    rawResponse, 
    /**
     * The response's status
     */
    status, 
    /**
     * A dictionary for translating error codes and descriptions.
     */
    dictionary, 
    /**
     * The response's headers.
     */
    headers) {
        let parsedResponse;
        try {
            parsedResponse = JSON.parse(rawResponse);
        }
        catch (error) {
            parsedResponse = rawResponse;
        }
        super({
            status: status,
            code: parsedResponse.code,
            message: language => createMessage(status, parsedResponse, dictionary, language),
            headers,
        });
        /**
         * The error object as defined by the Stackspot API. If the response doesn't match the expected format this will be undefined.
         */
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The response data, if this matches the expected format expected by a Stackspot Error, it will be the same as `data`.
         */
        Object.defineProperty(this, "raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.raw = parsedResponse;
        if (this.raw?.code !== undefined && this.raw?.status !== undefined && this.raw?.details !== undefined)
            this.data = parsedResponse;
    }
}
//# sourceMappingURL=DefaultAPIError.js.map