import { StreamError } from '../error/StreamError.js';
import { FetchEventStream } from '../network/types.js';
type StreamingStatus = 'pending' | 'success' | 'error';
/**
 * An object represented by a JSON stream. This can be watched as the stream runs.
 */
export declare class StreamedJson<T> {
    private onChangeListeners;
    private error;
    private data;
    private fullPromise;
    private abortController;
    /**
     * @param response the fetch response.
     * @param minChangeIntervalMS a stream can be too fast. This sets a minimum interval between running the listeners. The default is 50ms.
     */
    constructor(eventsPromise: Promise<FetchEventStream>, abortController: AbortController, minChangeIntervalMS?: number);
    private run;
    private static merge;
    private clear;
    private fail;
    private complete;
    /**
     * Returns the full value of the object once the stream finishes.
     */
    getValue(): Promise<T>;
    /**
     * Returns the streamed object with everything already streamed. This will be the complete object if the stream has finished.
     */
    getPartialValue(): Partial<T>;
    /**
     * Watches the object as it's streamed. This doesn't wait for the value to be complete.
     *
     * The listener is called whenever the value changes.
     *
     * @param listener the function to call with the new value.
     * @returns a function that, when called, removes the listener.
     */
    onChange(listener: (value: Partial<T>) => void): () => void;
    getStatus(): StreamingStatus;
    getError(): StreamError | undefined;
    /**
     * If this is a stream and it's not yet finished, calling this function cancels the stream.
     */
    cancel(): void;
}
export {};
//# sourceMappingURL=StreamedJson.d.ts.map