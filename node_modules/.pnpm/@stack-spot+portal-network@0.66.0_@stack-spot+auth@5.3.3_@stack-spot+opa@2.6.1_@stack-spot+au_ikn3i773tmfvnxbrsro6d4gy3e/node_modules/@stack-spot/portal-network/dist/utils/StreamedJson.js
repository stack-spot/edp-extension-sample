import { CompletablePromise } from '@stack-spot/opa';
import { StreamCanceledError } from '../error/StreamCanceledError.js';
import { StreamError } from '../error/StreamError.js';
import { StreamJsonError } from '../error/StreamJsonError.js';
/**
 * An object represented by a JSON stream. This can be watched as the stream runs.
 */
export class StreamedJson {
    /**
     * @param response the fetch response.
     * @param minChangeIntervalMS a stream can be too fast. This sets a minimum interval between running the listeners. The default is 50ms.
     */
    constructor(eventsPromise, abortController, minChangeIntervalMS = 50) {
        Object.defineProperty(this, "onChangeListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "fullPromise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new CompletablePromise()
        });
        Object.defineProperty(this, "abortController", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abortController = abortController;
        this.run(eventsPromise, minChangeIntervalMS);
    }
    async run(eventsPromise, minChangeIntervalMS) {
        let lastChangeCall = 0;
        try {
            const events = await eventsPromise;
            let flushed = true;
            for await (const event of events) {
                if (this.error)
                    return;
                if (event.data) {
                    const json = JSON.parse(event.data);
                    StreamedJson.merge(json, this.data);
                    if (new Date().getTime() - lastChangeCall >= minChangeIntervalMS) {
                        this.onChangeListeners.forEach(l => l(this.data));
                        lastChangeCall = new Date().getTime();
                        flushed = true;
                    }
                    else {
                        flushed = false;
                    }
                }
            }
            if (!flushed)
                this.onChangeListeners.forEach(l => l(this.data));
        }
        catch (error) {
            if (error instanceof DOMException && error.name === 'AbortError')
                this.fail(new StreamCanceledError());
            if (error instanceof SyntaxError)
                this.fail(new StreamJsonError());
            else if (error instanceof StreamError)
                this.fail(error);
            else
                this.fail(new StreamError(error?.message || `${error}`));
        }
        if (!this.error)
            this.complete();
    }
    static merge(source, target) {
        Object.keys(source).forEach((k) => {
            if (typeof source[k] !== typeof target[k])
                target[k] = source[k];
            else if (typeof source[k] === 'string')
                target[k] += source[k];
            else if (Array.isArray(source[k]))
                target[k].push(...source[k]);
            else if (typeof source[k] === 'number')
                parseFloat(target[k] + source[k]);
            else if (typeof source[k] === 'object')
                this.merge(source[k], target[k]);
            else
                target[k] = source[k];
        });
    }
    clear() {
        this.onChangeListeners = [];
        this.abortController = undefined;
    }
    fail(error) {
        this.error = error;
        this.fullPromise.reject(this.error);
        this.clear();
    }
    complete() {
        this.fullPromise.resolve(this.data);
        this.clear();
    }
    /**
     * Returns the full value of the object once the stream finishes.
     */
    getValue() {
        return this.fullPromise.promise;
    }
    /**
     * Returns the streamed object with everything already streamed. This will be the complete object if the stream has finished.
     */
    getPartialValue() {
        return this.data;
    }
    /**
     * Watches the object as it's streamed. This doesn't wait for the value to be complete.
     *
     * The listener is called whenever the value changes.
     *
     * @param listener the function to call with the new value.
     * @returns a function that, when called, removes the listener.
     */
    onChange(listener) {
        if (this.fullPromise.resolved) {
            listener(this.data);
            return () => { };
        }
        this.onChangeListeners.push(listener);
        return () => {
            const index = this.onChangeListeners?.findIndex(l => l === listener);
            if (index !== undefined && index >= 0)
                this.onChangeListeners?.splice(index, 1);
        };
    }
    getStatus() {
        if (this.error)
            return 'error';
        if (this.fullPromise.resolved)
            return 'success';
        return 'pending';
    }
    getError() {
        return this.error;
    }
    /**
     * If this is a stream and it's not yet finished, calling this function cancels the stream.
     */
    cancel() {
        this.abortController?.abort(new StreamCanceledError());
    }
}
//# sourceMappingURL=StreamedJson.js.map