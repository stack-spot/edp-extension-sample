import { HttpError } from '@oazapfts/runtime';
import { CompletablePromise } from '@stack-spot/opa';
import { cloneDeep } from 'lodash';
import { defaults, sendEvents } from '../api/eventBus.js';
import apis from '../apis.json';
import { DefaultAPIError } from '../error/DefaultAPIError.js';
import { baseDictionary } from '../error/dictionary/base.js';
import { NetworkClient } from '../network/NetworkClient.js';
export const EVENTS_STORAGE_IDENTIFIER = 'eventsError';
const DEFER_MS = 5000;
class EventBusClient extends NetworkClient {
    constructor() {
        super(apis.eventBus.url);
        Object.defineProperty(this, "queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "deferred", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new CompletablePromise()
        });
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * Sends an event
         */
        Object.defineProperty(this, "sendEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (event) => {
                await this.add(event);
            }
        });
        defaults.baseUrl = '';
        defaults.fetch = (...args) => this.fetch(...args);
    }
    buildStackSpotError(error) {
        return new DefaultAPIError(error.data, error.status, baseDictionary, error.headers);
    }
    async consume() {
        if (this.queue.length === 0)
            return;
        if (this.lock)
            return this.timeout = window.setTimeout(() => this.consume(), DEFER_MS);
        this.lock = true;
        const deferred = this.deferred;
        this.deferred = new CompletablePromise();
        const sendingQueue = cloneDeep(this.queue);
        this.queue = [];
        const storageEvents = JSON.parse(localStorage.getItem(EVENTS_STORAGE_IDENTIFIER) || '[]');
        const bodyData = {
            events: sendingQueue.concat(storageEvents),
        };
        try {
            const allResults = await sendEvents({ sendEventsRequest: bodyData });
            if (allResults.errorCount === 0) {
                localStorage.removeItem(EVENTS_STORAGE_IDENTIFIER);
            }
            deferred.resolve(allResults);
        }
        catch (error) {
            if (error instanceof HttpError) {
                deferred.reject(new Error(`Error while sending events. Network error ${error.status}.\n}`));
            }
            throw error;
        }
    }
    async add(event) {
        if (this.timeout)
            window.clearTimeout(this.timeout);
        const index = this.queue.length;
        this.queue.push(event);
        this.timeout = window.setTimeout(() => this.consume(), DEFER_MS);
        const response = await this.deferred.promise;
        const result = response.results[index];
        if ('errorCode' in result) {
            throw result;
        }
        return result;
    }
}
export const eventBusClient = new EventBusClient();
//# sourceMappingURL=event-bus.js.map