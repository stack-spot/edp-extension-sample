/* eslint-disable react-hooks/rules-of-hooks */
import { useInfiniteQuery, useSuspenseInfiniteQuery } from '@tanstack/react-query';
import { get, set } from 'lodash';
import { ManualQuery } from './ManualQuery.js';
import { queryClient } from './react-query-client.js';
export class ManualInfiniteQuery extends ManualQuery {
    constructor(config) {
        super(config);
    }
    getConfig() {
        return this.config;
    }
    createInfiniteQueryFn(variables) {
        return ({ pageParam, signal }) => {
            const paginatedVariables = {
                ...variables,
            };
            set(paginatedVariables, this.getConfig().pageParamName, pageParam ?? get(variables, this.getConfig().pageParamName));
            return this.makeRequest(paginatedVariables, signal);
        };
    }
    getListFromData(data) {
        return data?.pages.map(page => this.getConfig().accumulator ? page[this.getConfig().accumulator] : page).flat();
    }
    useInfiniteQueryResult(suspense, variables = {}, options) {
        variables = { ...variables, ...this.getConfig().defaultVariables };
        const use = suspense ? useSuspenseInfiniteQuery : useInfiniteQuery;
        return use({
            ...options,
            queryKey: ['infinite', ...this.getKey(variables)],
            queryFn: this.createInfiniteQueryFn(variables),
            initialPageParam: this.getConfig().initialPageParam,
            getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => this.getConfig().getNextPageParam({ variables, lastPage, allPages, lastPageParam, allPageParams }),
        }, queryClient);
    }
    useInfiniteQuery(variables, options) {
        const result = this.useInfiniteQueryResult(true, variables, options);
        return [
            this.getListFromData(result.data),
            result,
        ];
    }
    useStatefulInfiniteQuery(variables, options) {
        const result = this.useInfiniteQueryResult(false, variables, options);
        return [
            this.getListFromData(result.data),
            result.isPending,
            result.error,
            result,
        ];
    }
    async invalidate(variables) {
        await Promise.all([
            super.invalidate(variables),
            queryClient.invalidateQueries({ queryKey: ['infinite', ...this.getKey(variables)] }),
        ]);
    }
}
//# sourceMappingURL=ManualInfiniteQuery.js.map