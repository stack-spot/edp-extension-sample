/* eslint-disable react-hooks/rules-of-hooks */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ReactQueryNetworkClient_instances, _ReactQueryNetworkClient_parseErrorData, _ReactQueryNetworkClient_transformError, _ReactQueryNetworkClient_onFetchPermission;
import { HttpError } from '@oazapfts/runtime';
import { StackspotAPIError } from '../error/StackspotAPIError.js';
import { AutoInfiniteQuery } from './AutoInfiniteQuery.js';
import { AutoMutation } from './AutoMutation.js';
import { AutoQuery } from './AutoQuery.js';
import { ManualInfiniteQuery } from './ManualInfiniteQuery.js';
import { ManualMutation } from './ManualMutation.js';
import { ManualQuery } from './ManualQuery.js';
import { NetworkClient } from './NetworkClient.js';
const DUMMY_ULID = '01HSTZ5471CBG4AW9BFJ0VTVG9';
const PERMISSION_ERROR = 'permission-error';
export const DEFAULT_PAGE_SIZE = 20;
/**
 * A Network Client that uses oazapfts for making requests and React Query for managing responses.
 */
export class ReactQueryNetworkClient extends NetworkClient {
    /**
     * @param baseURL An object with the keys "dev", "stg" and "prd". The values must be the url for each of these environments.
     * @param defaults the `default` object of the API this client is for (provided by the code generated by oazapfts).
     */
    constructor(baseURL, defaults) {
        super(baseURL);
        _ReactQueryNetworkClient_instances.add(this);
        defaults.baseUrl = '';
        defaults.fetch = (...args) => this.fetch(...args);
    }
    /**
     * Creates a function that checks the permission for a request generated by an oazapfts function.
     *
     * This is intended to help creating a manual operation.
     *
     * @example
     * ```
     * myOperation = this.mutation({
     *   // ...
     *   permission: this.createPermissionFunctionFor(oazapftsFnForMyOperation)
     * })
     * ```
     * @param fn the function generated by oazapfts.
     * @returns a function that receives the variables of `fn` (if any) and returns a promise that resolves to true if the request is allowed
     * and false otherwise.
     */
    createPermissionFunctionFor(fn) {
        return (variables) => fn.length === 2
            ? fn(variables, { fetch: (...args) => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_onFetchPermission).call(this, ...args) })
            : fn({ fetch: (...args) => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_onFetchPermission).call(this, ...args) });
    }
    /**
     * Creates a function that runs a oazapfts function with an abort signal.
     *
     * This is intended to help creating a manual operation.
     *
     * @example
     * ```
     * myOperation = this.mutation({
     *   // ...
     *   request: this.createRequestFunctionFor(oazapftsFnForMyOperation)
     * })
     * ```
     * @param fn the function generated by oazapfts.
     * @returns a function that receives a signal and the variables of `fn` (if any) and returns the same as `fn`.
     */
    createRequestFunctionFor(fn) {
        return (signal, variables) => fn.length === 2
            ? fn(variables, { signal })
            : fn({ signal });
    }
    query(fnOrConfig) {
        return typeof fnOrConfig === 'function'
            ? new AutoQuery({
                apiName: this.constructor.name,
                fn: fnOrConfig,
                onFetchPermission: (...args) => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_onFetchPermission).call(this, ...args),
                transformError: error => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_transformError).call(this, error),
            })
            : new ManualQuery({
                ...fnOrConfig,
                apiName: this.constructor.name,
                request: fnOrConfig.request,
                permission: fnOrConfig.permission,
                transformError: error => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_transformError).call(this, error),
            });
    }
    infiniteQuery(fnOrConfig, options) {
        return typeof fnOrConfig === 'function'
            ? new AutoInfiniteQuery({
                apiName: this.constructor.name,
                fn: fnOrConfig,
                onFetchPermission: (...args) => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_onFetchPermission).call(this, ...args),
                transformError: error => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_transformError).call(this, error),
            }, {
                accumulator: options?.accumulator ?? '',
                pageParamName: options?.pageParamName ?? 'page',
                initialPageParam: options?.initialPageParam ?? 1,
                defaultVariables: options?.defaultVariables ?? { size: DEFAULT_PAGE_SIZE },
                getNextPageParam: options?.getNextPageParam ?? (({ variables, lastPage, lastPageParam }) => {
                    const size = variables.size ?? 1;
                    const isLastPageTheLast = lastPage && ((Array.isArray(lastPage) && lastPage.length < size)
                        || (options?.accumulator !== undefined && options?.accumulator !== '' && lastPage[options?.accumulator]?.length < size));
                    return isLastPageTheLast ? undefined : parseInt(lastPageParam) + 1;
                }),
            })
            : new ManualInfiniteQuery({
                ...fnOrConfig,
                apiName: this.constructor.name,
                request: fnOrConfig.request,
                permission: fnOrConfig.permission,
                transformError: error => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_transformError).call(this, error),
            });
    }
    mutation(fnOrConfig) {
        if (typeof fnOrConfig === 'function') {
            return new AutoMutation({
                apiName: this.constructor.name,
                fn: fnOrConfig,
                onFetchPermission: (...args) => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_onFetchPermission).call(this, ...args),
                transformError: error => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_transformError).call(this, error),
            });
        }
        return new ManualMutation({
            ...fnOrConfig,
            apiName: this.constructor.name,
            request: fnOrConfig.request,
            permission: fnOrConfig.permission,
            transformError: error => __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_transformError).call(this, error),
        });
    }
}
_ReactQueryNetworkClient_instances = new WeakSet(), _ReactQueryNetworkClient_parseErrorData = function _ReactQueryNetworkClient_parseErrorData(error) {
    if (typeof error.data === 'string') {
        try {
            return JSON.parse(error.data);
        }
        catch { /* empty */ }
    }
    return error.data;
}, _ReactQueryNetworkClient_transformError = function _ReactQueryNetworkClient_transformError(error) {
    if (error instanceof StackspotAPIError)
        return error;
    if (!(error instanceof HttpError))
        throw new StackspotAPIError({ status: 0, message: error?.message || `${error}`, stack: error.stack });
    const data = __classPrivateFieldGet(this, _ReactQueryNetworkClient_instances, "m", _ReactQueryNetworkClient_parseErrorData).call(this, error);
    if (data.type === PERMISSION_ERROR) {
        // eslint-disable-next-line no-console
        console.error('Error while validating permissions:', data.message);
        return new StackspotAPIError({
            status: 500,
            stack: error.stack,
            message: language => language === 'pt'
                ? 'Ocorreu um erro ao validar as permiss√µes.'
                : 'There was an error while validating permissions.',
        });
    }
    return this.buildStackSpotError(error);
}, _ReactQueryNetworkClient_onFetchPermission = async function _ReactQueryNetworkClient_onFetchPermission(input, init) {
    const [path, method, body] = input instanceof Request
        ? [input.url, input.method, input.body]
        : [`${input}`, (init?.method?.toLowerCase() || 'get'), init?.body];
    try {
        /* We allow the dev not to pass any variable when validating a permission. For this reason, oazapfts might generate a path with
        "undefined". If this happens, we must replace the undefined text with a dummy ULID. */
        const fixedPath = path.replace(/\/undefined(\/|$)/g, `/${DUMMY_ULID}$1`);
        const isAllowed = await this.requestPermission(method, fixedPath, body);
        return new Response(`${isAllowed}`, { headers: { 'Content-Type': 'application/json' } });
    }
    catch (error) {
        return new Response(JSON.stringify({ type: PERMISSION_ERROR, message: error.message || `${error}` }), { status: 500 });
    }
};
//# sourceMappingURL=ReactQueryNetworkClient.js.map