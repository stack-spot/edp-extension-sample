import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Divider, Flex, IconBox, Text } from '@citric/core';
import { ChevronRight, ChevronUpFill, Cog, Collapse, Expand, Support } from '@citric/icons';
import { useKeyboardControls } from '@stack-spot/portal-components';
import { useAnchorTag } from '@stack-spot/portal-components/anchor';
import { listToClass } from '@stack-spot/portal-theme';
import { interpolate, useTranslate } from '@stack-spot/portal-translate';
import { useCallback, useEffect, useMemo, useState } from 'react';
import { elementIds, getLayoutElements } from '../../elements.js';
import { StarFillWithGradient } from '../../svg/StarFillWithGradient.js';
import { isLessThan30Days } from '../Rate/hook.js';
import { MenuContent } from './MenuContent.js';
import { MenuSectionGroup } from './MenuSectionGroup.js';
/**
 * Amount of time to wait before hiding the menu overlay once the mouse leaves its area.
 */
const HIDE_OVERLAY_DELAY_MS = 400;
const MENU_OVERLAY_ID = 'menuContentOverlay';
/**
 * Pointer to the latest "hideOverlay" task. This allows the operation to be cancelled.
 */
let hideOverlayTask;
/**
 * Accessibility. Makes the menu overlay accessible through the keyboard.
 */
let attachKeyboardListenersForOverlay;
/**
 * Accessibility. Makes the menu overlay invisible to the keyboard.
 */
let detachKeyboardListenersForOverlay;
/**
 * Hides the menu overlay after HIDE_OVERLAY_DELAY_MS. This operation may be canceled.
 *
 * This gives the user some time to move the mouse outside the overlay for while before it disappears. If the user moves the mouse out of
 * the overlay and, before HIDE_OVERLAY_DELAY_MS, moves the mouse back, we want the overlay to keep showing.
 */
function hideOverlay() {
    if (hideOverlayTask !== undefined)
        return;
    hideOverlayTask = window.setTimeout(hideOverlayImmediately, HIDE_OVERLAY_DELAY_MS);
}
/**
 * Accessibility. Returns the accessibility button of the section with the preview (overlay) currently active.
 */
function getAccessibilityButtonOfSectionWithActiveOverlay() {
    return document.getElementById(elementIds.menuSections)?.querySelector('button[aria-expanded="true"]');
}
/**
 * Hides the menu overlay without waiting for anything. This is not cancellable.
 */
export function hideOverlayImmediately() {
    detachKeyboardListenersForOverlay?.();
    const overlay = document.getElementById(MENU_OVERLAY_ID);
    overlay?.setAttribute('inert', '');
    overlay?.setAttribute('aria-hidden', '');
    overlay?.classList.remove('visible');
    getAccessibilityButtonOfSectionWithActiveOverlay()?.setAttribute('aria-expanded', 'false');
}
/**
 * If `hideOverlay` was called and not fulfilled yet, this cancels the task, preventing the overlay from closing.
 */
function cancelHideOverlayTask() {
    if (hideOverlayTask === undefined)
        return;
    clearTimeout(hideOverlayTask);
    hideOverlayTask = undefined;
}
/**
 * Shows the menu overlay.
 */
function showOverlay() {
    cancelHideOverlayTask();
    const overlay = document.getElementById(MENU_OVERLAY_ID);
    overlay?.removeAttribute('inert');
    overlay?.removeAttribute('aria-hidden');
    overlay?.classList.add('visible');
    attachKeyboardListenersForOverlay?.();
}
/**
 * Checks if the menu content (2nd menu list from left to right) is visible or not.
 * The menu content is visible if:
 * 1. The menu is not compact (the button at the end of the section list compacts/expands the menu);
 * 2. If the current section has any menu content.
 */
function isMenuContentVisible() {
    return !!document.getElementById('layout')?.classList?.contains('menu-content-visible');
}
/**
 * A section in the the menu-sections.
 *
 * A section in the menu is responsible for rendering the section icon, label, accessibility button and controlling the menu overlay.
 * @param props React props for the component {@link MenuSection} & { id, setCurrentOverlay }. Id identifies the current section and
 * setCurrentOverlay controls the overlay (preview) content.
 */
const Section = ({ icon, label, href, target, onClick, active, content, customContent, setCurrentOverlay, hasContent, id, }) => {
    const Link = useAnchorTag();
    const contentToRender = typeof content === 'function' ? content() : content;
    const t = useTranslate(dictionary);
    function shouldShowOverlay() {
        /* The overlay should appear if:
         * 1. The menu is compacted showing only the icons
         * 2. The section has some content to render OR:
         * 3. The section is active and there is a contextual menu for the active page.
         */
        const { layout } = getLayoutElements();
        const isCompactedOnlyIcons = layout?.classList.contains('menu-compact');
        return isCompactedOnlyIcons && (!!contentToRender || !!customContent || (hasContent && active));
    }
    function prepareShowOverlay(event) {
        if (!shouldShowOverlay())
            return;
        const anchorElement = event.target;
        const accessibilityButton = anchorElement?.parentElement?.querySelector('button');
        accessibilityButton?.setAttribute('aria-expanded', 'true');
        setCurrentOverlay(id);
        showOverlay();
    }
    function click() {
        if (onClick)
            onClick();
        hideOverlayImmediately();
    }
    const labelText = typeof label === 'string' ? label : label.id;
    return (_jsxs(_Fragment, { children: [_jsx(Link, { href: href, target: target, onClick: click, onMouseEnter: prepareShowOverlay, onMouseLeave: () => shouldShowOverlay() && hideOverlay(), title: labelText, "aria-label": labelText, onKeyDown: onClick ? e => e.key === 'Enter' && onClick() : undefined, ...(active ? { 'aria-current': 'page' } : undefined), ...(!href ? { 'tabIndex': 0 } : undefined), children: _jsxs(Flex, { alignItems: "center", justifyContent: "center", flexWrap: "nowrap", px: 3, children: [_jsx(IconBox, { children: icon }), typeof label === 'string' ? _jsx(Text, { appearance: "microtext1", className: "section-label", ml: 3, children: label }) : label.element] }) }), shouldShowOverlay() &&
                _jsx(IconBox, { size: "sm", className: "section-submenu-icon", as: "button", "aria-label": interpolate(t.menuOptions, label), "aria-controls": MENU_OVERLAY_ID, "aria-expanded": false, onKeyDown: (event) => {
                        if (event.key === 'Enter') {
                            prepareShowOverlay(event);
                        }
                    }, children: _jsx(ChevronRight, {}) })] }));
};
/**
 * Renders the overlay content.
 * @param props the content of the overlay, can be either customized (react component), a config object or a function that creates the
 * config object.
 * @returns the content
 */
const OverlayRenderer = ({ content, customContent }) => {
    if (customContent) {
        return _jsx("div", { id: "custom-selectable-item", children: customContent });
    }
    const data = typeof content === 'function' ? content() : content;
    return _jsx(MenuContent, { ...data });
};
/**
 * Renders a menu-sections interface.
 *
 * Considering the Stackspot UI, this is the "menu sections", not the "menu content", i.e. it's the first menu from left to right, the
 * one with the icons and section names: the main menu.
 *
 * Attention: each section in the menu is identified by its index. To avoid errors, the array passed to this component must never change.
 * To control whether or not to show an item, use the property `hidden`, instead of adding/removing it to the array. Example of error:
 * start the section menu with 5 items, remove the 5th item and add another item. The previous 5th item and the new 5th items are different,
 * but since we identify the item by its index, the two different sections will be rendered as if they were the same, causing a react hook
 * call order problem.
 *
 * @param props the props for the component {@link MenuProps}.
 */
export const MenuSections = ({ sections = [], ...props }) => {
    const Link = useAnchorTag();
    const t = useTranslate(dictionary);
    // this is a mock state only used to force an update on the component.
    const [_, setUpdate] = useState(0);
    const [isMenuCollapsed, setIsMenuCollapsed] = useState(false);
    const toggleMenu = useCallback((hasContent) => {
        const layout = document.getElementById('layout');
        if (!layout)
            return;
        if (layout.classList.contains('menu-compact')) {
            layout.classList.remove('menu-compact');
            setIsMenuCollapsed(false);
        }
        else {
            layout.classList.add('menu-compact');
            setIsMenuCollapsed(true);
        }
        if (hasContent) {
            if (layout.classList.contains('menu-content-visible')) {
                layout.classList.remove('menu-content-visible');
            }
            else {
                layout.classList.add('menu-content-visible');
            }
        }
        setUpdate(current => current + 1);
    }, []);
    // the current overlay showing, when the user hovers the section icon. This is the index of the item in the sections array.
    const [currentOverlay, setCurrentOverlay] = useState();
    const sectionItemsOverlay = useMemo(() => sections.flatMap((s) => 'children' in s ? s.children?.map((c) => c) : s), [sections]);
    const sectionItems = useMemo(() => sections.reduce((result, s, i) => s.hidden
        ? result
        : [
            ...result,
            _jsx("li", { role: "menuitem", title: s.label, className: `section-submenu no-indentation ${s.className || ''} ${s.active ? 'active' : undefined}`, children: 'children' in s ?
                    _jsx(CollapsibleSection, { listItems: sectionItemsOverlay, isMenuCollapsed: isMenuCollapsed, ...s, setCurrentOverlay: setCurrentOverlay })
                    :
                        _jsx(Section, { id: sectionItemsOverlay.findIndex((sio) => sio?.label === s.label), ...s, setCurrentOverlay: setCurrentOverlay, hasContent: !!props.content || !!props.customContent }, i) }, s.label),
        ], []), [sections, isMenuCollapsed]);
    function onPressEscape() {
        getAccessibilityButtonOfSectionWithActiveOverlay()?.focus();
        hideOverlayImmediately();
    }
    const { keyboardControlledElement: overlayRef, attachKeyboardListeners, detachKeyboardListeners } = useKeyboardControls({
        onPressEscape,
        querySelectors: 'li a.action, #custom-selectable-item button, #custom-selectable-item input',
    });
    // this only works because we have a single section menu in the site. This workaround was created since the keyboard controls were
    // transformed into a hook. This is not ideal and it would be a good idea to rewrite this code without the need for this.
    attachKeyboardListenersForOverlay = attachKeyboardListeners;
    detachKeyboardListenersForOverlay = detachKeyboardListeners;
    /* This function renders the section preview in the overlay in normal circumstances. If the menu is hidden and the section is active,
    instead of rendering the section preview, it will render the actual menu content, which would be invisible otherwise.
    Below, the key is of extreme importance. It ensures React will consider every section content to be an entirely different
    component. Without this, React would see the content changing every time a new section is hovered. Since the content might be a
    hook, this would cause some serious problems. */
    function renderMenuOverlay() {
        if (currentOverlay === undefined)
            return null;
        const shouldRenderMenuContentInstead = !isMenuContentVisible() && sectionItemsOverlay[currentOverlay]?.active &&
            (!!props.content || !!props.customContent);
        return shouldRenderMenuContentInstead
            ? _jsx(OverlayRenderer, { content: props.content, customContent: props.customContent }, 'contentKey' in props ? props.contentKey : undefined)
            : _jsx(OverlayRenderer, { content: sectionItemsOverlay[currentOverlay]?.content, customContent: sectionItemsOverlay[currentOverlay]?.customContent }, currentOverlay);
    }
    return (_jsxs(_Fragment, { children: [_jsx(MenuSectionGroup, { className: "open root no-indentation", children: sectionItems }), _jsxs(Flex, { mb: 7, alignItems: "center", children: [_jsx(RateAndContactUsItem, { ...props }), _jsxs("button", { role: "menuitem", className: "toggle sections-footer", onClick: () => toggleMenu(!!props.content || !!props.customContent), title: t.toggle, children: [_jsxs(IconBox, { children: [_jsx(Expand, { className: "expand" }), _jsx(Collapse, { className: "collapse" })] }), _jsx(Text, { appearance: "microtext1", ml: 8, className: "collapse", colorScheme: "light.contrastText", children: t.hide })] }), (props.settings?.show) &&
                        _jsxs(Link, { href: props.settings?.href, onClick: props.settings?.onClick, className: "sections-footer toggle", ...(props.settings.active ? { 'aria-current': 'page' } : undefined), children: [_jsx(IconBox, { "aria-label": t.settingsIcon, children: _jsx(Cog, {}) }), _jsx(Text, { appearance: "microtext1", ml: 8, className: "collapse", children: t.settings })] })] }), _jsx("div", { id: MENU_OVERLAY_ID, onMouseEnter: showOverlay, onMouseLeave: hideOverlay, ref: overlayRef, children: renderMenuOverlay() })] }));
};
const RateAndContactUsItem = ({ ...props }) => {
    const t = useTranslate(dictionary);
    const alreadyAnswered = localStorage.getItem('RATED_US_IN');
    const hasAnsweredLess30Days = alreadyAnswered ? isLessThan30Days(new Date(+alreadyAnswered), new Date(Date.now())) : false;
    const Link = useAnchorTag();
    //This effect is only used to remove from local storage unused keys from 
    //previous rate us and contact us versions. We do not want to fill the users storage
    //with things that are not used anymore.
    useEffect(() => {
        localStorage.removeItem('CONTACT_POPOVER');
        localStorage.removeItem('RATE_POPOVER');
        localStorage.removeItem('viewNpsItem');
    }, []);
    return _jsxs(_Fragment, { children: [(props.rateUs?.show && !hasAnsweredLess30Days) &&
                _jsxs("button", { role: "menuitem", className: "toggle sections-footer", onClick: props.rateUs?.onClick, ...(props.rateUs.active ? { 'aria-current': 'page' } : undefined), children: [_jsx(IconBox, { "aria-label": t.rateUsIcon, sx: { paddingTop: '2px' }, children: _jsx(StarFillWithGradient, { id: "svg-icon", className: "gradient-svg rotate-icon" }) }), _jsx(Text, { appearance: "microtext1", ml: 8, sx: { marginTop: '3px' }, className: "collapse gradient grow-shrink", colorScheme: "light.contrastText", children: t.rateUs })] }), (props.contactUs?.show) &&
                _jsxs(Link, { href: props.contactUs?.href, className: "toggle sections-footer", onClick: props.contactUs?.onClick, ...(props.contactUs.active ? { 'aria-current': 'page' } : undefined), target: props.contactUs?.target, children: [_jsx(IconBox, { "aria-label": t.contactIcon, children: _jsx(Support, {}) }), _jsx(Text, { appearance: "microtext1", ml: 8, sx: { marginTop: '3px' }, className: "collapse", colorScheme: "light.contrastText", children: t.contactUs })] })] });
};
/**
 * A menu item that is actually a subgroup and can be collapsed/expanded.
 * @param props the props for the component {@link MenuSectionGroup} & { root: boolean }.
 */
const CollapsibleSection = ({ label, open: initialValue, children, icon, setCurrentOverlay, listItems, isMenuCollapsed = true }) => {
    const [open, setOpen] = useState(initialValue || false);
    const menuGroupId = `menuGroup${label}`;
    const items = useMemo(() => children?.filter(i => !i.hidden).map((c) => (_jsx("li", { role: "menuitem", title: c.label, className: `section-submenu ${c.className} ${c.active ? 'active' : ''}`, children: _jsx(Section, { id: listItems?.findIndex((item) => item?.label === c.label), ...c, hasContent: false, setCurrentOverlay: setCurrentOverlay }, c.label) }, c.label))), [children]);
    return (_jsxs(_Fragment, { children: [isMenuCollapsed ? _jsx(Divider, {}) :
                _jsx("a", { onClick: () => setOpen(!open), onKeyDown: e => e.key === 'Enter' && setOpen(!open), className: listToClass(['item-row']), tabIndex: 0, "aria-controls": menuGroupId, "aria-expanded": open, children: _jsxs(Flex, { alignItems: "center", px: 6, style: { width: '100%' }, children: [icon, _jsx(Text, { appearance: "microtext1", className: "section-label", ml: 3, colorScheme: "light.contrastText", children: label }), _jsx(IconBox, { style: { marginLeft: 'auto' }, children: _jsx(ChevronUpFill, { className: listToClass(['chevron', open ? 'open' : '']) }) })] }) }), _jsx(MenuSectionGroup, { id: menuGroupId, className: `${isMenuCollapsed || open ? 'open' : ''} root no-indentation`, "aria-hidden": !open, children: items })] }));
};
const dictionary = {
    en: {
        toggle: 'Show or hide the menu',
        menuOptions: 'View $0 menu options',
        settings: 'Settings',
        settingsIcon: 'Settings icon',
        hide: 'Hide',
        contactUs: 'Support',
        contactIcon: 'Contact icon',
        rateUs: 'Rate us',
        rateUsIcon: 'Rate us icon',
    },
    pt: {
        toggle: 'Visualizar ou esconder o menu',
        menuOptions: 'Visualizar opções do menu $0',
        settings: 'Configurações',
        settingsIcon: 'Ícone de configurações',
        hide: 'Esconder',
        contactUs: 'Suporte',
        contactIcon: 'Ícone de contato',
        rateUs: 'Avalie-nos',
        rateUsIcon: 'Avalie-nos icon',
    },
};
//# sourceMappingURL=MenuSections.js.map