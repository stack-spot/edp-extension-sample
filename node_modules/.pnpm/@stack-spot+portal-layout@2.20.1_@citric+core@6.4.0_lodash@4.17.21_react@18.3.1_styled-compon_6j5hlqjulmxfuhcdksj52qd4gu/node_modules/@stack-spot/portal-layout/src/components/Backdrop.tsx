import { delay } from '@stack-spot/portal-components'
import { listToClass } from '@stack-spot/portal-theme'
import { useEffect, useMemo, useRef, useState } from 'react'
import { createPortal } from 'react-dom'
import { getLayoutElements } from '../elements'
import { overlay } from '../LayoutOverlayManager'
import { CustomModalSize, RightPanelSize } from '../types'
import { valueOfLayoutVar } from '../utils'

export interface BackdropProps {
  children: React.ReactNode,
  visible: boolean,
  /**
   * A function to run when the backdrop is closed. Since the backdrop is a controlled element, this should be used to set the state
   * of `visible` to false.
   */
  onClose: () => void,
  style?: React.CSSProperties,
  /**
   * Makes this backdrop act as a modal or a right panel.
   * - `actAs = 'modal'` adds the className 'modal-box' to the backdrop, making it behave like a modal with medium size.
   * - `actAs = 'right-panel'` adds the className 'right-panel-box' to the backdrop, making it behave like a right-panel with medium size.
   * - `actAs = { type: T, size: S }` adds the className 'modal-box' or 'right-panel-box' to the backdrop, depending on the value of `T`.
   * The size will depend on the value of `S`.
   */
  actAs?: 'modal' | 'right-panel' | { type: 'modal', size: CustomModalSize } | { type: 'right-panel', size: RightPanelSize },
  /**
   * A persistent backdrop is always rendered, despite the value of `visible`. It still appears or disappears according to `visible`, but
   * it never leaves the DOM.
   * 
   * This can help preserving complex animations.
   * 
   * Attention: if you have many complex backdrops with persistent = true, it may affect performance. 
   * 
   * @default false
   */
  persistent?: boolean,
  /**
   * This doesn't change the animation of the backdrop! Use this property if `persistent` is false and the backdrop's content is animated
   * in a different time than `--modal-animation-duration` (layout css variable).
   * 
   * This lets you preserve the animations on your content when `persistent` is false.
   */
  animationMS?: number,
  className?: string,
}

/**
 * The backdrop is a component for creating a Modal content. This can have any shape or form, it's free to accept any kind of content, and,
 * by default, it has no animations attached to it (with the exception of the backdrop's animation, which is a fade-in-out).
 * 
 * In general, to create modal and side-panels, you should use `overlay.showModal`, `overlay.showCustomModal`, `overlay.showRightPanel` and
 * `overlay.showCustomRightPanel`.
 * 
 * Use this when:
 * 1. Your content is neither a modal, nor a right panel, but it needs a backdrop. Meaning, it can't be animated like a modal, but still
 * needs to show a backdrop.
 * 2. Your content is a modal or a right panel, but it needs to update according to an external state. The ideal scenario is to have the
 * modal content completely independent of the external state, but sometimes, we do need to interact with an external state and calling
 * `overlay.show*` multiple times is not ideal.
 * 
 * Attention: if you open a modal/right panel through this component, you should not use the methods `overlay.close*` or `overlay.is*Open`
 * to manage it.
 * 
 * @example
 * Check the example below for rendering a medium-sized modal. Equivalent to `overlay.showModal`. Remember that calling `overlay.showModal`
 * is always preferable. Use this only if you fall into the second case explained above.
 * ```
 * <Backdrop visible={isOpen} onClose={() => setOpen(false)} actAs="modal">
 *   <OverlayContent type="modal" onClose={() => setOpen(false)} title="Title">
 *     <p>Hello World!</p>
 *   </OverlayContent>
 * </Backdrop>
 * ```
 * @param props the component props {@link BackdropProps}.
 */
export const Backdrop = ({ children, visible = false, onClose, className, actAs, persistent, animationMS = 0, style }: BackdropProps) => {
  const ref = useRef<HTMLDivElement>(null)
  const [shouldRender, setShouldRender] = useState(!!persistent)
  const renderDelay = useMemo(() => Math.max(parseFloat(valueOfLayoutVar('--modal-animation-duration')), animationMS) * 1000, [])
  const backdropType = typeof actAs === 'string' ? actAs : actAs?.type
  const backdropSize = typeof actAs === 'string' ? 'medium' : actAs?.size
  const classes = listToClass([
    className,
    backdropType === 'modal' && 'modal-box',
    backdropType === 'right-panel' && 'right-panel-box',
    backdropSize,
  ])

  useEffect(() => {
    (async () => {
      if (visible) {
        setShouldRender(true)
        // arbitrary delay to make sure the content is rendered before actually showing it.
        await delay(10)
        overlay.showBackdrop(ref.current)
      }
      else {
        overlay.closeBackdrop(ref.current)
        await delay(renderDelay)
        setShouldRender(false)
      }
    })()
  }, [visible])

  const backdropContent = (
    <div ref={ref} data-custom-backdrop-visibility={visible} className={classes} style={style}>
      {children}
      {/* This button allows the OverlayManager to programmatically close any custom backdrop by calling their respective onClose prop. */}
      <button data-custom-backdrop-close onClick={onClose} style={{ display: 'none' }}>Close</button>
    </div>
  )
  
  const backdrop = getLayoutElements().backdrop
  return backdrop && (shouldRender || persistent) ? createPortal(backdropContent, backdrop) : null
}
