import { CitronNavigator } from './CitronNavigator.js';
import { splitPath } from './utils.js';
/**
 * A Route of the Citron Navigator. The root route, i.e. the route that has no parent will be the Navigation Tree.
 *
 * Routes are equal if they have the same key. To test route equality, use `routeA.equals(routeB)`, do not use same-value-zero equality
 * (`routeA === routeB`).
 *
 * Every property of this class not prefixed with "$" is a child route.
 */
export class Route {
    constructor(key, path, parent, paramMetadata) {
        /**
         * A unique key that identifies this route.
         *
         * This will be in the format "a.b.c", where each name separated by "." is the name of a route in the navigation tree, "a" is the root
         * node's name and "c" is this route's name.
         */
        Object.defineProperty(this, "$key", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The path to this route. Variables are represented as `{variable_name}`.
         */
        Object.defineProperty(this, "$path", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The Route that is the parent of this route in the navigation tree.
         */
        Object.defineProperty(this, "$parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The parameters this route can have and their types.
         */
        Object.defineProperty(this, "$paramMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.$key = key;
        this.$path = path;
        this.$parent = parent;
        this.$paramMetadata = paramMetadata;
    }
    /**
     * Navigates to this route using the browser's history API. This can be either a page change or just a modification to a route parameter.
     *
     * To control whether to use history.pushState or history.replaceState, pass "replace" in the options parameter.
     *
     * By default, whenever the current route is the same as the route we're navigating to, `history.replaceState` is used. Otherwise,
     * `history.pushState` is.
     *
     * The parameters provided are merged with the parameters of the current URL. To avoid merging unwanted search parameters, pass the option
     * `mergeSearchParameters: false`.
     * @param params the parameters for the route.
     * @param options optional. The options for this navigation.
     */
    $go(params, options) {
        const replace = options?.replace ?? this.$isActive();
        const operation = replace ? 'replaceState' : 'pushState';
        history[operation]({}, '', this.$link(params, { mergeSearchParameters: options?.mergeSearchParameters ?? true }));
        if (!options?.preventDefault)
            CitronNavigator.instance?.updateRoute();
    }
    setSearchParam(searchParams, key, value) {
        if (value === undefined || value === null || value === '')
            return;
        const type = this.$paramMetadata[key];
        if (type.endsWith('[]') && Array.isArray(value))
            return value.forEach(v => searchParams.append(key, v));
        searchParams.set(key, type === 'object' ? JSON.stringify(value) : value);
    }
    /**
     * Creates a link (relative url) to this route.
     *
     * When creating a link, the provided search parameters are not merged with the current search parameters. To allow than to merge, pass
     * `mergeSearchParameters: true` in the options (2nd parameter).
     * @param params the parameters for the route.
     * @param options optional. The options for creating the link.
     * @returns the relative url to this route.
     */
    $link(params, options) {
        const parameters = { ...CitronNavigator.instance?.currentParams, ...params };
        const urlParams = [];
        const path = this.$path.replace(/\/\*$/, '').replace(/\{(\w+)\}/g, (_, match) => {
            urlParams.push(match);
            const type = this.$paramMetadata[match];
            const value = parameters[match];
            let serialized = `${value}`;
            if (type.endsWith('[]') && Array.isArray(value)) {
                serialized = value.map(item => typeof item === 'string' ? item.replace(/-/g, '\\-') : item).join('-');
            }
            else if (type === 'object')
                serialized = JSON.stringify(value);
            return encodeURIComponent(serialized);
        });
        const url = new URL(CitronNavigator.instance?.useHash ? location.pathname : path, location.origin);
        if (CitronNavigator.instance?.useHash)
            url.hash = `#${path}`;
        const newSearchParams = (options?.mergeSearchParameters ? parameters : params) ?? {};
        Object.keys(this.$paramMetadata).forEach(key => !urlParams.includes(key) && this.setSearchParam(url.searchParams, key, newSearchParams[key]));
        return `${url.pathname}${url.hash}${url.search}`;
    }
    /**
     * Checks if the key passed as parameter corresponds to this route.
     * @param key the key to compare.
     * @returns true if the key is the same as this route's key. False otherwise.
     */
    $is(key) {
        return this.$key === key;
    }
    /**
     * Checks if the route passed as parameter is equivalent to the this route.
     * @param route the route to compare.
     * @returns true if it's  equivalent, false otherwise.
     */
    $equals(route) {
        return this.$key === route.$key;
    }
    /**
     * Checks if the key passed as parameter corresponds to this route or a sub-route of this route.
     *
     * Attention: this will only check the format of the key. It won't verify if the route actually exists.
     *
     * @param key the key to compare.
     * @returns true if the key is a sub-route (or equal). False otherwise.
     */
    $containsSubroute(key) {
        return this.$key === key || key.startsWith(`${this.$key}.`);
    }
    /**
     * Checks if this route corresponds to the key passed as parameter or any sub-route of the key.
     *
     * @param key the key to compare.
     * @returns true if this is a sub-route of the key (or equal). False otherwise.
     */
    $isSubrouteOf(key) {
        return this.$key === key || this.$key.startsWith(`${key}.`);
    }
    /**
     * Checks how the path passed as parameter matches this route.
     *
     * Attention: this won't verify if the path corresponds to an actual route. It will make a decision only based in the path's format.
     *
     * @param path the path to test this route against
     * @returns
     * - `no-match` if this route and the path passed as parameter are not related.
     * - `exact` if the path passed as parameter corresponds to this route; wildcards will always match as exact.
     * - `subroute` if the path passed as parameter corresponds to a sub-route (descendent) of this route.
     * - `super-route` if the path passed as parameter corresponds to a super-route (ascendent) of this route.
     */
    $match(path) {
        const thatPathParts = splitPath(path);
        const thisPathParts = splitPath(this.$path.replace(/\/\*$/, ''));
        const min = Math.min(thisPathParts.length, thatPathParts.length);
        for (let i = 0; i < min; i++) {
            const isUrlParam = !!thisPathParts[i].match(/\{\w+\}/);
            if (!isUrlParam && thatPathParts[i] !== thisPathParts[i])
                return 'no-match';
        }
        const isWildcard = this.$path.endsWith('/*');
        if (!isWildcard && thisPathParts.length < thatPathParts.length)
            return 'subroute';
        if (thisPathParts.length > thatPathParts.length)
            return 'super-route';
        return 'exact';
    }
    /**
     * Checks if this route is currently active.
     * @returns true if this route is the currently active, false otherwise.
     */
    $isActive() {
        const path = CitronNavigator.instance?.getPath();
        return path !== undefined && this.$match(path) === 'exact';
    }
    /**
     * Checks if this route or any of its sub-route is currently active.
     * @returns true if this route or any of its sub-routes is the currently active, false otherwise.
     */
    $isSubrouteActive() {
        const path = CitronNavigator.instance?.getPath();
        if (!path)
            return false;
        const match = this.$match(path);
        return path !== undefined && (match === 'subroute' || match === 'exact');
    }
    /**
     * Returns the branch that starts at the root node and ends in this route.
     * @returns an array of routes where the first is the root node and the last is this route.
     */
    $getBranch() {
        const branch = [this];
        while (branch[branch.length - 1].$parent) {
            branch.push(branch[branch.length - 1].$parent);
        }
        return branch.reverse();
    }
}
//# sourceMappingURL=Route.js.map