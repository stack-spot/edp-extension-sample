import { Route } from './Route.js';
import { NavigationError, NavigationSetupError } from './errors.js';
import { removeElementFromArray, splitPath } from './utils.js';
/**
 * Singleton. This is the application's navigator (Citron Navigator).
 *
 * To create a CitronNavigator instance, call `CitronNavigator.create`. If there's not yet an instance, it will create one, otherwise, it
 * will return the existing instance.
 *
 * To access the current instance, use `CitronNavigator.instance`, which will be undefined if no instance has been created yet.
 */
export class CitronNavigator {
    constructor(root, useHash = true) {
        Object.defineProperty(this, "root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "notFoundListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "routeChangeListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "asyncRouteChangeListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "currentRoute", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "currentParams", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "useHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.root = root;
        this.useHash = useHash;
        window.addEventListener('popstate', () => this.updateRoute());
        this.updateRoute();
    }
    /**
     * Creates a navigator if none has been created yet. Otherwise, returns the current navigator.
     * @param root the navigation tree.
     * @param useHash whether or not to use hash-based urls (domain/#/path). The default is true.
     * @returns the navigator
     */
    static create(root, useHash = true) {
        // @ts-ignore: should be read-only for external code only
        CitronNavigator.instance ?? (CitronNavigator.instance = new CitronNavigator(root, useHash));
        return CitronNavigator.instance;
    }
    /**
     * Copies every child route of `source` to `target` if the child route of `source` doesn't exist in `target`.
     *
     * If a child of `source` exists in `target`, but it's path includes a wildcard (/*), we recursively copy its children to the same route
     * in `target`.
     * @param source the route to have its children copied.
     * @param target the route to copy the children to.
     */
    copy(source, target) {
        Object.keys(source).forEach((key) => {
            const k = key;
            if (!k.startsWith('$') && source[k] instanceof Route) {
                if (!(k in target)) {
                    source[k].$parent = target;
                    target[k] = source[k];
                }
                else if (source[k].$path.endsWith('/*')) {
                    this.copy(source[k], target[k]);
                }
            }
        });
    }
    /**
     * Updates the navigation tree by merging a node with another.
     *
     * This is used by modular navigation. A module can load more routes into the tree.
     * @param route the node to be merged into the tree.
     * @param keyToReplace the key of the node to be merged.
     */
    updateNavigationTree(route, keyToReplace) {
        let oldRoute = this.root;
        const reminderKey = keyToReplace.replace(new RegExp(`^${this.root.$key}\\.?`), '');
        const keyParts = reminderKey.split('.');
        if (reminderKey)
            keyParts.forEach(key => oldRoute = oldRoute?.[key]);
        if (!oldRoute) {
            throw new NavigationSetupError(`Navigation error: cannot update navigation tree at route with key "${keyToReplace}" because the key doesn't exist.`);
        }
        if (oldRoute === this.root) {
            this.root = route;
        }
        else {
            route.$parent = oldRoute.$parent;
            oldRoute.$parent[keyParts[keyParts.length - 1]] = route;
        }
        // validation: check for route clashes
        const oldPaths = Object.keys(oldRoute).reduce((result, key) => {
            if (key.startsWith('$'))
                return result;
            const value = oldRoute[key];
            return !(value instanceof Route) || value.$path.endsWith('/*') ? result : [...result, value.$path];
        }, []);
        Object.keys(route).forEach((key) => {
            const value = route[key];
            if (key.startsWith('$') || !(value instanceof Route))
                return;
            if (oldPaths.includes(value.$path)) {
                throw new NavigationSetupError(`Error while merging modular route with key "${keyToReplace}". Path "${value.$path}" is already defined in parent. Only paths with wildcard can be replaced.`);
            }
            if (key in oldRoute && oldRoute[key] instanceof Route && !oldRoute[key].$path.endsWith('/*')) {
                throw new NavigationSetupError(`Error while merging modular route, key "${keyToReplace}" is already defined in parent with a non-wildcard path.`);
            }
        });
        this.copy(oldRoute, route);
        this.updateRoute();
    }
    /**
     * Gets the path of the provided url (considering hash-based paths).
     *
     * Examples:
     * - "https://www.stackspot.com/pt/ai-assistente" (useHash = false): "pt/ai-assistente".
     * - "https://www.stackspot.com/#/pt/ai-assistente" (useHash = true): "pt/ai-assistente".
     *
     * @param url the url to extract the path from. The current url (window.location) is used if none is provided.
     * @returns the path part of the url.
     */
    getPath(url = new URL(location.toString())) {
        return this.useHash ? url.hash.replace(/^\/?#\/?/, '').replace(/\?.*/, '') : url.pathname.replace(/^\//, '');
    }
    /**
     * Updates the current route according to the current URL.
     */
    async updateRoute() {
        const route = this.findRouteByPath(this.root, this.getPath());
        if (route)
            await this.handleRouteChange(route);
        else
            this.handleNotFound();
    }
    childrenOf(route) {
        return Object.keys(route).reduce((result, key) => {
            if (!key.startsWith('$'))
                result.push(route[key]);
            return result;
        }, []);
    }
    findRouteByPath(route, path, lastMatch) {
        switch (route.$match(path)) {
            case 'exact':
                return route.$path.endsWith('*')
                    ? this.childrenOf(route).reduce((result, child) => result ?? this.findRouteByPath(child, path, route), undefined) ?? route
                    : route;
            case 'subroute':
                return this.childrenOf(route).reduce((result, child) => result ?? this.findRouteByPath(child, path, lastMatch), undefined) ?? (route.$path.endsWith('*') ? route : lastMatch);
        }
    }
    async handleRouteChange(route) {
        this.currentRoute = route;
        const url = new URL(location.toString());
        this.currentParams = { ...this.extractQueryParams(url), ...this.extractUrlParams(url) };
        await Promise.all(this.asyncRouteChangeListeners.map(l => l(route, this.currentParams)));
        this.routeChangeListeners.forEach(l => l(route, this.currentParams));
    }
    handleNotFound() {
        const path = this.getPath();
        // eslint-disable-next-line no-console
        console.error(new NavigationError(`route not registered (${path})`).message);
        this.notFoundListeners.forEach(l => l(path));
    }
    paramTypeError(key, value, type, routeKey, interpretingAs = 'a raw string') {
        return new NavigationError(`error while deserializing parameter "${key}" of route "${routeKey}". The value ("${value}") is not a valid ${type}. Citron Navigator will interpret it as ${interpretingAs}, which may cause issues ahead.`).message;
    }
    deserializeNumber(key, value) {
        const deserialized = parseFloat(value);
        // eslint-disable-next-line no-console
        if (isNaN(deserialized))
            console.error(this.paramTypeError(key, value, 'number', this.currentRoute?.$key ?? 'unknown', 'NaN'));
        return deserialized;
    }
    deserializeBoolean(key, value) {
        if (value === 'true' || value === '')
            return true;
        if (value === 'false')
            return false;
        // eslint-disable-next-line no-console
        console.error(this.paramTypeError(key, value, 'boolean', this.currentRoute?.$key ?? 'unknown', 'true'));
        return true;
    }
    deserializeParameter(key, values) {
        const value = values[0];
        if (!this.currentRoute)
            return value;
        const type = this.currentRoute.$paramMetadata[key];
        switch (type) {
            case 'string': return value;
            case 'number': return this.deserializeNumber(key, value);
            case 'boolean': return this.deserializeBoolean(key, value);
            case 'string[]': return values;
            case 'number[]': return values.map(v => this.deserializeNumber(key, v));
            case 'boolean[]': return values.map(v => this.deserializeBoolean(key, v));
            case 'object':
                try {
                    return JSON.parse(value);
                }
                catch {
                    // eslint-disable-next-line no-console
                    console.error(this.paramTypeError(key, value, type, this.currentRoute.$key));
                    return value;
                }
        }
    }
    extractQueryParams(url) {
        const params = this.useHash ? new URLSearchParams(url.hash.replace(/[^?]*\??/, '')) : url.searchParams;
        const result = {};
        params.forEach((_, name) => {
            if (name in result)
                return;
            result[name] = this.deserializeParameter(name, params.getAll(name));
        });
        return result;
    }
    extractUrlParams(url) {
        const result = {};
        const routeParts = splitPath(this.currentRoute?.$path);
        const urlParts = splitPath(this.getPath(url));
        const paramMetadata = this.currentRoute?.$paramMetadata ?? {};
        routeParts.forEach((value, index) => {
            const [, key] = value.match(/\{(\w+)\}/) ?? [];
            const paramStringValue = decodeURIComponent(urlParts[index]);
            /* if the parameter is supposed to be an array, get all of its values by splitting the string by "-" (considering "\" as a escape
            character). */
            const paramArrayValue = paramMetadata[key]?.endsWith('[]')
                ? paramStringValue.split(/(?<!\\)-/).map(item => item.replace(/\\-/g, '-'))
                : [paramStringValue];
            if (key)
                result[key] = this.deserializeParameter(key, paramArrayValue);
        });
        return result;
    }
    addRouteChangeListener(listener, isAsync) {
        const list = isAsync ? this.asyncRouteChangeListeners : this.routeChangeListeners;
        list.push(listener);
        if (this.currentRoute)
            listener(this.currentRoute, this.currentParams);
        return () => {
            removeElementFromArray(list, listener);
        };
    }
    /**
     * Adds a listener for changes to the route.
     *
     * If you need a listener that runs asynchronously, consider using `onRouteChangeAsync`.
     * @param listener a function called when the route changes.
     * @returns a function that, when called, removes the listener.
     */
    onRouteChange(listener) {
        return this.addRouteChangeListener(listener, false);
    }
    /**
     * Adds a listener for changes to the route. This listener can be async (return a promise).
     *
     * Asynchronous listeners are run before every synchronous listener. Synchronous listeners are only run once all async listeners finish
     * running.
     * @param listener a function called when the route changes.
     * @returns a function that, when called, removes the listener.
     */
    onRouteChangeAsync(listener) {
        return this.addRouteChangeListener(listener, true);
    }
    /**
     * Adds a listener that runs when a navigation is performed to a route that doesn't exist.
     *
     * @param listener a function called when the route is not found.
     * @returns a function that, when called, removes the listener.
     */
    onNotFound(listener) {
        this.notFoundListeners.push(listener);
        return () => {
            removeElementFromArray(this.notFoundListeners, listener);
        };
    }
}
//# sourceMappingURL=CitronNavigator.js.map