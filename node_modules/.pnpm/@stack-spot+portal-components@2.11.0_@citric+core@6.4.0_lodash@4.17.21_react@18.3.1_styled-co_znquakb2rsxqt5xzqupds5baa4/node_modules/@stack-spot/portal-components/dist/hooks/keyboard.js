import { useCallback, useEffect, useRef } from 'react';
/**
 * Creates listeners for controlling a Menu UI through the keyboard.
 * - Arrow down: next element in the iterator returned by the query selectors. First element, if the current element is the last.
 * - Arrow up: previous element in the iterator returned by the query selectors. Last element, if the current element is the first.
 * - Tab: same as Arrow down, but has a different behavior if the element is the last (see onPressLastTab).
 * - Esc: determined by onPressEscape.
 * @param props {@link Options}.
 * @returns an object with the element controlled by the keyboard (useRef); a function to attach the keyboard events and a function to
 * detach the keyboard events.
 */
export function useKeyboardControls(
/**
 * Options for the keyboard controls.
 */
{ querySelectors, onPressEscape, onPressLastTab = onPressEscape, onPressArrowLeft, onPressArrowRight, disableTabBehavior, ref, }, 
/**
 * Calls `attachKeyboardListeners` (mount) and `detachKeyboardListeners` (unmount) whenever the deps passed as parameter changes.
 *
 * If deps are undefined, this component doesn't automatically add these listeners and you have to use the functions returned in the
 * result.
 */
deps) {
    const localRef = useRef(null);
    const keyboardControlledElement = ref ?? localRef;
    const listeners = useRef({});
    listeners.current = { onPressEscape, onPressLastTab };
    const keyboardControls = useCallback((event) => {
        const eventKey = event.key;
        const target = event?.target;
        function getSelectableAnchors() {
            return keyboardControlledElement.current?.querySelectorAll(querySelectors) ?? [];
        }
        function handleArrows(key = eventKey) {
            const anchors = getSelectableAnchors();
            let i = 0;
            while (i < anchors.length && document.activeElement !== anchors[i])
                i++;
            const next = key === 'ArrowDown' ? (anchors[i + 1] ?? anchors[0]) : (anchors[i - 1] ?? anchors[anchors.length - 1]);
            next?.focus?.();
        }
        const handlers = {
            Escape: () => {
                listeners.current.onPressEscape?.();
                event.stopPropagation();
                event.preventDefault();
            },
            Enter: () => {
                target?.click();
            },
            Tab: () => {
                if (disableTabBehavior)
                    return;
                const anchors = getSelectableAnchors();
                if (document.activeElement === anchors[anchors.length - 1])
                    listeners.current.onPressLastTab?.();
                else
                    handleArrows('ArrowDown');
                event.preventDefault();
            },
            ArrowUp: handleArrows,
            ArrowDown: handleArrows,
            ArrowLeft: onPressArrowLeft,
            ArrowRight: onPressArrowRight,
        };
        handlers[eventKey]?.();
    }, []);
    const attachKeyboardListeners = useCallback(() => {
        const element = ref?.current ?? document;
        element.addEventListener('keydown', keyboardControls);
    }, []);
    const detachKeyboardListeners = useCallback(() => {
        const element = ref?.current ?? document;
        element.removeEventListener('keydown', keyboardControls);
    }, []);
    useEffect(() => {
        if (!deps)
            return;
        attachKeyboardListeners();
        return detachKeyboardListeners;
    }, deps);
    return { keyboardControlledElement, attachKeyboardListeners, detachKeyboardListeners };
}
//# sourceMappingURL=keyboard.js.map