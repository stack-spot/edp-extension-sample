import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { IconBox } from '@citric/core';
import { ChevronDown } from '@citric/icons';
import { LoadingCircular } from '@citric/ui';
import { listToClass } from '@stack-spot/portal-theme';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { delay } from '../../../utils/promise.js';
import { SelectBox } from './styled.js';
import { parseLabel } from './utils.js';
function getOptionAsValue(option, renderer) {
    let result;
    if (typeof renderer === 'function')
        result = option ? renderer(option) : undefined;
    else if (typeof renderer === 'string')
        result = option[renderer];
    return result ? result : `${option ?? ''}`;
}
function getOptionAsLabel(option, renderer) {
    let result;
    if (typeof renderer === 'function')
        result = option ? renderer(option) : undefined;
    else if (typeof renderer === 'string')
        result = option[renderer];
    return result ? result : parseLabel(`${option ?? ''}`);
}
const FakeOption = ({ value, label, onChange }) => (_jsx("li", { className: "option", onClick: () => onChange({ target: { value } }), children: label }));
/**
 * Renders a Select component using the Citric Design System.
 *
 * The styled version of the select component is rendered on top of the default select from the browser. Visual users will use the Citric
 * version of a Select, but blind users, who interacts with the keyboard, will use the default browser select instead, which is already
 * highly optimized for accessibility.
 *
 * The CustomSelect lets you customize how each option and the selected value are rendered. To do so, use the prop `renderLabel` and
 * `emptyOption`.
 *
 * If you don't need fully customized labels, check the more simple components: `DetailedSelect` and `Select`.
 *
 * The CustomSelect expects a {@link GenericAccessibleLabel} to create labels.
 *
 * Tips:
 * - This is a controlled field. You can't use it any other way. If you're using it with react-hook-form, you need to wrap it under the
 * component `<Controller>` from the same library.
 * - `value` is required and must be of the same type of an item of the array of options. `value` is only optional if `emptyOption` is
 * provided, in this case, an empty option is rendered and the value is undefined when it's selected.
 * - A consequence of the previous rule is that you can't have an empty selection if you don't set a value for `emptyOption`. This
 * component must work exactly like the browser's `select`, so this behavior is intended.
 * - If `renderLabel` or `renderValue` are not provided, this will use the `toString` method of the object.
 *
 * @example
 * options as an object array
 * ```
 * const options = ['option 1', 'option 2', 'option 3']
 *
 * function renderCustomLabel(option: string) {
 *   return {
 *     // this is how the option will be rendered in the list
 *     option: (
 *       <div style={{ display: flex, flexDirection: 'row', gap: '5px' }}>
 *         <img src="/my-image.png" width="40px" height="40px" />
 *         <p>An option called {option}</p>
 *       </div>
 *     ),
 *     // this is how the option will be rendered inside the input, when it's the value currently selected.
 *     selected: <p>{option}</p>,
 *     // this a string representation of the option: used for accessibility. This should contain the same information as `option`.
 *     text: `An option called ${option}`,
 *   )
 * }
 *
 * const MyComponent = {
 *   const [value, setValue] = useState(options[0])
 *   return <CustomSelect options={options} value={value} onChange={setValue} renderLabel={renderCustomLabel} />
 * }
 * ```
 * @example
 * options as an object array
 * ```
 * const options = [{ id: 1, name: 'John', age: 34 }, { id: 2, name: 'Marcia', age: 28 }, { id: 3, name: 'Angeline', age: 58 }]
 *
 * function renderCustomLabel(option: (typeof options)[number]) {
 *   return {
 *     // this is how the option will be rendered in the list
 *     option: (
 *       <div style={{ display: flex, flexDirection: 'row', gap: '5px' }}>
 *         <img src="/my-image.png" width="40px" height="40px" />
 *         <p>{option.name}, aged {option.age}</p>
 *       </div>
 *     ),
 *     // this is how the option will be rendered inside the input, when it's the value currently selected.
 *     selected: <p>{option}</p>,
 *     // this a string representation of the option: used for accessibility. This should contain the same information as `option`.
 *     text: `${option.name}, aged ${option.age}`,
 *   )
 * }
 *
 * const MyComponent = {
 *   const [value, setValue] = useState(options[0])
 *   // below, renderValue could be `o => o.id`
 *   return <CustomSelect options={options} value={value} onChange={setValue} renderValue="id" renderLabel={renderCustomLabel} />
 * }
 * ```
 * @param props the component props: {@link CustomSelectProps}.
 */
export function CustomSelect({ onChange, options, value, emptyOption, renderLabel, renderValue, maxItems = 6, onFocus, onBlur, style, className, isLoading, disabled, height = '42px', ...props }) {
    const [open, setOpen] = useState(false);
    const [focused, setFocused] = useState(false);
    const fakeSelectRef = useRef(null);
    const listHeight = useRef(0);
    const isDisabled = disabled || isLoading;
    const isMeasuring = useRef(false);
    const onChangeOption = useCallback((event) => {
        const value = options?.find(o => getOptionAsValue(o, renderValue) === event.target.value);
        onChange(value);
        setOpen(false);
    }, [options]);
    const onClickOutside = useCallback((event) => {
        if (fakeSelectRef.current && !fakeSelectRef.current.contains(event.target))
            setOpen(false);
    }, []);
    const [htmlOptions, fakeOptions] = useMemo(() => (options ?? []).reduce(([opts, fake], o) => {
        const id = getOptionAsValue(o, renderValue);
        const label = getOptionAsLabel(o, renderLabel);
        return [
            [...opts, _jsx("option", { value: id, selected: value === id, children: label.text }, id)],
            [...fake, _jsx(FakeOption, { value: id, label: label.option, onChange: onChangeOption }, id)],
        ];
    }, [[], []]), [options, value]);
    function getCurrentValue() {
        return value === undefined ? '' : getOptionAsValue(value, renderValue);
    }
    function getCurrentLabel() {
        return value === undefined ? emptyOption : getOptionAsLabel(value, renderLabel);
    }
    useEffect(() => {
        const detach = () => document.removeEventListener('mousedown', onClickOutside);
        if (open)
            document.addEventListener('mousedown', onClickOutside);
        else
            detach();
        return detach;
    }, [open]);
    useEffect(() => {
        async function measure() {
            // semaphore for controlling concurrence
            if (isMeasuring.current)
                return;
            isMeasuring.current = true;
            const list = fakeSelectRef.current?.querySelector('.options');
            if (!list)
                return;
            list.setAttribute('inert', '');
            list.setAttribute('style', 'height: auto');
            await delay(0);
            listHeight.current = list.clientHeight;
            await delay(0);
            list.setAttribute('style', `height: ${open ? listHeight.current : 0}`);
            list.removeAttribute('inert');
            isMeasuring.current = false;
        }
        measure();
    }, [options, fakeSelectRef.current]);
    // replicates the original select effect of the browser to select the first option. This is necessary because we use the default
    // select element for accessibility, the behavior must not differ.
    useEffect(() => {
        if (!value && !emptyOption && options?.length) {
            onChange(options[0]);
        }
    }, [options]);
    return (_jsxs(SelectBox, { style: style, className: className, "$maxItems": maxItems, "$inputHeight": height, children: [_jsxs("select", { ...props, value: getCurrentValue(), onChange: onChangeOption, onFocus: (ev) => {
                    setFocused(true);
                    onFocus?.(ev);
                }, onBlur: (ev) => {
                    setFocused(false);
                    onBlur?.(ev);
                }, disabled: isDisabled, "aria-busy": isLoading, children: [emptyOption === undefined ? null : _jsx("option", { value: "", selected: !value, children: emptyOption.text }), htmlOptions] }), _jsxs("div", { ref: fakeSelectRef, className: listToClass(['fake-select', open && 'open', focused && 'focused', isDisabled && 'disabled']), "aria-hidden": true, children: [_jsxs("div", { className: "current-value", onClick: isDisabled ? undefined : () => setOpen(!open), children: [getCurrentLabel()?.selected || getCurrentLabel()?.option || _jsx("div", {}), isLoading ? _jsx(LoadingCircular, { size: "sm" }) : _jsx(IconBox, { className: "arrow", children: _jsx(ChevronDown, {}) })] }), _jsxs("ul", { className: "options", style: { height: open ? listHeight.current : 0 }, children: [emptyOption === undefined ? null : _jsx(FakeOption, { value: "", label: emptyOption.option, onChange: onChangeOption }), fakeOptions] })] })] }));
}
//# sourceMappingURL=CustomSelect.js.map