import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Box, Flex } from '@citric/core';
import { listToClass } from '@stack-spot/portal-theme';
import { last } from 'lodash';
import { useMemo } from 'react';
import { styled } from 'styled-components';
import { InfiniteScroll } from '../InfiniteScroll.js';
import { TimelineSection } from '../TimelineSection.js';
import { NotificationItem } from './NotificationItem.js';
import { NotificationPlaceholder } from './NotificationPlaceholder.js';
const StyledBox = styled(Box) `
  width: 100%;
  position: relative;
  transition: opacity 0.3s;

  > div:first-child{
    width: 100%;
  }

  &.loading {
    opacity: 0.6;
    .loading-mask {
      pointer-events: auto;
    }
  }

  .loading-mask {
    opacity: 0;
    position: absolute;
    pointer-events: none;
    top: 0;
    right: 0;
    left: 0;
    bottom: 0;
    cursor: progress;
  }

  .placeholder.compact {
    & > div {
      padding-block: 0;
      gap: 15px;
      & > div {
        text-align: center;
        h4 {
          margin-bottom: 10px;
        }
        p {
          margin: 0;
        }
      }
    }
  }
`;
// this assumes the data from the backend is ordered by date (trigger_at)
function groupNotificationsByDate(notifications) {
    const groups = [];
    for (const n of notifications) {
        let currentGroup = last(groups);
        const date = new Date(n.trigger_at);
        const year = date.getFullYear();
        const month = date.getMonth();
        const day = date.getDate();
        if (!currentGroup || currentGroup.day !== day || currentGroup.month !== month || currentGroup.year !== year) {
            currentGroup = { year, month, day, items: [] };
            groups.push(currentGroup);
        }
        currentGroup.items.push(n);
    }
    return groups;
}
export const NotificationList = ({ items, compact = false, onCommit, onClickAction, infiniteScroll, loading, showEmptySearch, style, className }) => {
    const groups = useMemo(() => compact ? [{ day: 0, month: 0, year: 0, items }] : groupNotificationsByDate(items), [compact, items]);
    const renderNotifications = (notifications, key) => (_jsx(Flex, { sx: { gap: '4px' }, flexDirection: "column", children: notifications?.map((item) => (_jsx(NotificationItem, { notification: item, isSummary: compact, onCommit: () => onCommit(item.id), onClickAction: () => onClickAction?.(item.id) }, item.id))) }, key));
    return infiniteScroll?.scrollableTarget !== null && (_jsxs(StyledBox, { style: style, className: listToClass([className, loading && 'loading']), children: [items.length ? (_jsx(InfiniteScroll, { dataLength: items.length || 0, next: infiniteScroll?.loadMore ?? (() => { }), hasMore: infiniteScroll?.hasMore ?? false, 
                // @ts-ignore: the library is wrongly typed and abandoned, meaning, it will never be fixed. The source code clearly accepts
                // HTMLElements as scrollable targets:
                // https://github.com/ankeetmaini/react-infinite-scroll-component/blob/master/src/index.tsx#L168 
                scrollableTarget: infiniteScroll?.scrollableTarget, children: _jsx(Flex, { sx: { gap: '24px' }, flexDirection: "column", children: groups.map((group) => compact
                        ? renderNotifications(group.items, 'compact')
                        : (_jsx(TimelineSection, { month: group.month, day: group.day, children: renderNotifications(group.items) }, `${group.day}-${group.month}-${group.year}`))) }) })) : _jsx(NotificationPlaceholder, { isSearch: showEmptySearch, className: listToClass(['placeholder', compact && 'compact']), titleAs: "p" }), _jsx("div", { className: "loading-mask" })] }));
};
//# sourceMappingURL=NotificationList.js.map