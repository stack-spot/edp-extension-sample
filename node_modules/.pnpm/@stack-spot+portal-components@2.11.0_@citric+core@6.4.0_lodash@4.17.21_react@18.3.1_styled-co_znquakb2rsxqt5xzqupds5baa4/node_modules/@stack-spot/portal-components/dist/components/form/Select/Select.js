import { jsx as _jsx } from "react/jsx-runtime";
import { useCallback } from 'react';
import { CustomSelect } from './CustomSelect.js';
import { parseLabel } from './utils.js';
function getOptionAsLabel(option, renderer) {
    let result;
    if (typeof renderer === 'function')
        result = option ? renderer(option) : undefined;
    else if (typeof renderer === 'string')
        result = option[renderer];
    return parseLabel(result ?? `${option ?? ''}`);
}
/**
 * Renders a Select component using the Citric Design System.
 *
 * The styled version of the select component is rendered on top of the default select from the browser. Visual users will use the Citric
 * version of a Select, but blind users, who interacts with the keyboard, will use the default browser select instead, which is already
 * highly optimized for accessibility.
 *
 * The Select component renders each option as a string. To use more customizable labels, check the `DetailedSelect` and `CustomSelect`
 * components.
 *
 * The Select component expects plain strings to create labels.
 *
 * Tips:
 * - This is a controlled field. You can't use it any other way. If you're using it with react-hook-form, you need to wrap it under the
 * component `<Controller>` from the same library.
 * - `value` is required and must be of the same type of an item of the array of options. `value` is only optional if `emptyOption` is
 * provided, in this case, an empty option is rendered and the value is undefined when it's selected.
 * - A consequence of the previous rule is that you can't have an empty selection if you don't set a value for `emptyOption`. This
 * component must work exactly like the browser's `select`, so this behavior is intended.
 * - If `renderLabel` or `renderValue` are not provided, this will use the `toString` method of the object.
 *
 * @example
 * options as a string array
 * ```
 * const options = ['option 1', 'option 2', 'option 3']
 *
 * const MyComponent = {
 *   const [value, setValue] = useState(options[0])
 *   return <Select options={options} value={value} onChange={setValue} />
 * }
 * ```
 * @example
 * options as an object array
 * ```
 * const options = [{ id: 1, name: 'John', age: 34 }, { id: 2, name: 'Marcia', age: 28 }, { id: 3, name: 'Angeline', age: 58 }]
 *
 * const MyComponent = {
 *   const [value, setValue] = useState(options[0])
 *   // below, renderValue could be `o => o.id` and renderLabel `o => o.name`.
 *   return <Select options={options} value={value} onChange={setValue} renderValue="id" renderLabel="name" />
 * }
 * ```
 * @param props the component props: {@link CustomSelectProps}.
 */
export function Select({ renderLabel, emptyOption, ...props }) {
    const renderLabelRef = useCallback((option) => getOptionAsLabel(option, renderLabel), []);
    // @ts-ignore the following usage is correct, Typescript is getting confused because it doesn't know if `emptyOption` is undefined or not.
    return _jsx(CustomSelect, { renderLabel: renderLabelRef, emptyOption: emptyOption ? parseLabel(emptyOption) : undefined, ...props });
}
//# sourceMappingURL=Select.js.map