/**
 * Important for accessibility.
 *
 * Makes it so we focus the next focusable element in the DOM hierarchy, disregarding the element passed as parameter and its children.
 *
 * If there's no next focusable element, the first focusable element of the page will be focused. If the page doesn't contain any focusable
 * element, nothing happens.
 *
 * @param current the reference element to focus the next. If not provided, will be the currently active element.
 */
export declare function focusNextIgnoringChildren(current?: HTMLElement | null): void;
export type TagPriority = 'a' | 'button' | 'input' | 'textarea' | 'select' | 'other';
export type TagPriorityElement = TagPriority | TagPriority[];
interface FocusOptions {
    /**
     * Instead of focusing the first element overall, focus the first according to this list of priorities.
     *
     * 'other' means elements that are normally not focusable, but have positive tabIndex values.
     */
    priority?: TagPriorityElement[];
    /**
     * Ignores any element that matches this query selector.
     */
    ignore?: string;
}
/**
 * Focus the first focusable child of the element provided. If the element has no focusable child, nothing happens.
 *
 * A priority list can be passed in the second parameter, as an option. If it's provided, it will focus the first element according to the
 * list.
 *
 * An ignore query selector can also be passed in the options parameter. If the first focusable element matches the query selector, the
 * next element is focused instead.
 *
 * @example
 * Suppose the children of element are: h1, button, p, input, select.
 * 1. We don't pass a priority list. The focused element will be the button.
 * 2. Our priority list is ['button']. The focused element will be the button.
 * 3. Our priority list is ['input', 'button']. The focused element will be the input.
 * 4. Our priority list is ['select', 'input']. The focused element will be the select.
 * 5. Our priority list is [['select', 'input'], 'button']. The focused element will be the input.
 *
 * @param element the element to search a child to focus.
 * @param options optional.
 */
export declare function focusFirstChild(element: HTMLElement | Document | null | undefined, { priority, ignore }?: FocusOptions): void;
/**
 * Checks if an element can receive focus.
 *
 * Elements can receive focus only if:
 * - they exist;
 * - they're visible;
 * - they're not disabled;
 * - they are a focusable tag name or have a positive tab index;
 * - they don't have a negative tab index.
 * @param element the element to check.
 * @returns true if the element is focusable, false otherwise.
 */
export declare function isFocusable(element?: Element | null): boolean;
/**
 * Focus the element passed as parameter if it can receive focus. Otherwise, decides on another element to focus based on the HTML tree
 * and accessibility attributes.
 *
 * Decision making:
 * - If the element is focusable, focus it.
 * - If the element is not focusable, check if it has an id and if another element controls it (aria-controls).
 * - If the element is controlled by another, try to focus the controller, based in this same algorithm.
 * - Otherwise, try to focus its parent.
 *
 * If no focusable element is found. Nothing happens.
 * @param element the element to focus.
 */
export declare function focusAccessibleElement(element?: Element | null): void;
export {};
//# sourceMappingURL=accessibility.d.ts.map