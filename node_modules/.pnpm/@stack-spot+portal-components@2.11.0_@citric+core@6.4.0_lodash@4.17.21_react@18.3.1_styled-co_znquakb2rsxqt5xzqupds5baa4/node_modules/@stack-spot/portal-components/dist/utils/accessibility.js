/**
 * Important for accessibility.
 *
 * Makes it so we focus the next focusable element in the DOM hierarchy, disregarding the element passed as parameter and its children.
 *
 * If there's no next focusable element, the first focusable element of the page will be focused. If the page doesn't contain any focusable
 * element, nothing happens.
 *
 * @param current the reference element to focus the next. If not provided, will be the currently active element.
 */
export function focusNextIgnoringChildren(current) {
    current = current ?? document.activeElement;
    while (current && !current.nextElementSibling) {
        current = current?.parentElement;
    }
    current = current?.nextElementSibling;
    while (current && current.tabIndex < 0) {
        current = (current.children.length ? current.firstChild : current.nextElementSibling);
    }
    if (current)
        current?.focus?.();
    else
        focusFirstChild(document);
}
const selectors = {
    a: 'a[href]:not(:disabled)',
    button: 'button:not(:disabled)',
    input: 'input:not(:disabled):not([type="hidden"])',
    select: 'textarea:not(:disabled)',
    textarea: 'select:not(:disabled)',
    other: '[tabindex]:not([tabindex="-1"])',
};
/**
 * Focus the first focusable child of the element provided. If the element has no focusable child, nothing happens.
 *
 * A priority list can be passed in the second parameter, as an option. If it's provided, it will focus the first element according to the
 * list.
 *
 * An ignore query selector can also be passed in the options parameter. If the first focusable element matches the query selector, the
 * next element is focused instead.
 *
 * @example
 * Suppose the children of element are: h1, button, p, input, select.
 * 1. We don't pass a priority list. The focused element will be the button.
 * 2. Our priority list is ['button']. The focused element will be the button.
 * 3. Our priority list is ['input', 'button']. The focused element will be the input.
 * 4. Our priority list is ['select', 'input']. The focused element will be the select.
 * 5. Our priority list is [['select', 'input'], 'button']. The focused element will be the input.
 *
 * @param element the element to search a child to focus.
 * @param options optional.
 */
export function focusFirstChild(element, { priority = [], ignore } = {}) {
    const allFocusableTags = ['a', 'button', 'input', 'other', 'select', 'textarea'];
    const focusableList = [
        element?.querySelectorAll(allFocusableTags.map(t => selectors[t]).join(', ')),
    ];
    for (const p of priority) {
        const tags = Array.isArray(p) ? p : [p];
        const querySelectors = tags.map(t => selectors[t]);
        focusableList.unshift(element?.querySelectorAll(querySelectors.join(', ')));
    }
    for (const focusable of focusableList ?? []) {
        for (const f of focusable ?? []) {
            if (!ignore || !f.matches(ignore)) {
                const styles = window.getComputedStyle(f);
                if (styles.display != 'none' && styles.visibility != 'hidden')
                    return f.focus();
            }
        }
    }
}
/**
 * Checks if an element can receive focus.
 *
 * Elements can receive focus only if:
 * - they exist;
 * - they're visible;
 * - they're not disabled;
 * - they are a focusable tag name or have a positive tab index;
 * - they don't have a negative tab index.
 * @param element the element to check.
 * @returns true if the element is focusable, false otherwise.
 */
export function isFocusable(element) {
    if (!element)
        return false;
    // is disabled: return false
    if (element.ariaDisabled || element.getAttribute('disabled') !== null)
        return false;
    // is invisible: return false
    if (!element.checkVisibility({ checkOpacity: true, checkVisibilityCSS: true }))
        return false;
    // has tab index: return false if negative, true otherwise
    const tabIndexStr = element.getAttribute('tabindex');
    const tabIndex = tabIndexStr ? parseInt(tabIndexStr) : undefined;
    if (tabIndex !== undefined)
        return tabIndex >= 0;
    // check the tag name
    return ['a', 'button', 'input', 'iframe', 'select', 'textarea'].includes(element.tagName.toLowerCase() ?? '');
}
/**
 * Focus the element passed as parameter if it can receive focus. Otherwise, decides on another element to focus based on the HTML tree
 * and accessibility attributes.
 *
 * Decision making:
 * - If the element is focusable, focus it.
 * - If the element is not focusable, check if it has an id and if another element controls it (aria-controls).
 * - If the element is controlled by another, try to focus the controller, based in this same algorithm.
 * - Otherwise, try to focus its parent.
 *
 * If no focusable element is found. Nothing happens.
 * @param element the element to focus.
 */
export function focusAccessibleElement(element) {
    let elementToFocus = element;
    while (elementToFocus && !isFocusable(elementToFocus)) {
        const controlledBy = elementToFocus.id ? document.querySelector(`[aria-controls=${elementToFocus.id}]`) : undefined;
        elementToFocus = (controlledBy ?? elementToFocus.parentElement);
    }
    elementToFocus?.focus?.();
}
//# sourceMappingURL=accessibility.js.map