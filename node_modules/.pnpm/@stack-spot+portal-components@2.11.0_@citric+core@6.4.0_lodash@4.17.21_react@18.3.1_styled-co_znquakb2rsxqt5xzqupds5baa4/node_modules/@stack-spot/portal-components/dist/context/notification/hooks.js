import { useLanguage } from '@stack-spot/portal-translate';
import { useCallback, useRef, useState } from 'react';
import { useManualRender } from '../../hooks/manual-render.js';
import { useEffectOnce } from '../../hooks/use-effect-once.js';
import { useNotificationController } from './context.js';
export function useNotificationList(initialFilters = {}) {
    const { repaint } = useManualRender();
    const [status, setStatus] = useState('startup');
    const error = useRef();
    const controller = useNotificationController();
    const [filters, setFilters] = useState(initialFilters);
    const list = useRef();
    useEffectOnce(() => {
        async function start() {
            list.current = controller.createLazyNotificationList(initialFilters);
            list.current.subscribe(repaint);
            try {
                await list.current?.loadMore();
                setStatus('idle');
            }
            catch (e) {
                setStatus('error');
                error.current = e;
            }
        }
        start();
        return () => {
            if (list.current)
                controller.destroyLazyNotificationList(list.current.id);
        };
    });
    const applyFilters = useCallback(async (newFilters) => {
        if (!list.current)
            return;
        setStatus('loading');
        // since we're inside a useCallback, we don't have direct access to the current value of "filters". The only way we can access this
        // value is from the function "setFilters". But "setFilters" run async. For this reason, we wait the function to run and retrieve the
        // current value before continuing, hence the use of the await and promise below.
        const { next, prev } = await new Promise((resolve) => {
            setFilters((filters) => {
                const prev = filters;
                const next = { ...filters, ...newFilters };
                resolve({ prev, next });
                return next;
            });
        });
        try {
            await list.current.applyFilters(next);
            setStatus('idle');
            error.current = undefined;
        }
        catch (e) {
            setFilters(prev);
            if (error.current) {
                error.current = e;
                setStatus('error');
            }
            else {
                setStatus('idle');
            }
        }
    }, []);
    return {
        status,
        items: list.current?.items ?? [],
        hasMore: list.current?.hasMore() ?? false,
        loadMore: () => list.current?.loadMore(),
        refresh: () => applyFilters(filters),
        applyFilters,
        filters,
        error: error.current,
    };
}
export function useGetNotificationTitleAndDescription({ content }) {
    const language = useLanguage();
    const { title, description } = content?.[language] || content?.en || {};
    return {
        title,
        description: description?.replace(/^\s*/gm, '').replace(/^#+\s*/gm, '\n'),
    };
}
export function useUnreadNotifications() {
    const [hasUnreadNotifications, setUnreadNotifications] = useState(false);
    const controller = useNotificationController();
    useEffectOnce(() => {
        const unsubscribe = controller.onUnreadNotificationChange(setUnreadNotifications);
        controller.checkUnread();
        return unsubscribe;
    });
    return hasUnreadNotifications;
}
//# sourceMappingURL=hooks.js.map