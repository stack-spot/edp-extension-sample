var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LazyNotificationList_instances, _LazyNotificationList_loadMore;
import { pull, uniqBy } from 'lodash';
export class LazyNotificationList {
    constructor({ id, load, filters = {} }) {
        _LazyNotificationList_instances.add(this);
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "items", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "page", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: -1
        });
        Object.defineProperty(this, "total", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "filters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "load", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "currentFetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.id = id;
        this.load = load;
        this.filters = filters;
    }
    notify() {
        const hasMore = this.hasMore();
        this.listeners.forEach(l => l(this.items, hasMore));
    }
    async applyFilters(filters) {
        try {
            await this.currentFetch;
        }
        catch {
            /* empty: this error will be treated by the function who actually triggered `currentFetch`. We just need to make sure we wait until
            it ends before making new requests. */
        }
        const prevPage = this.page;
        const prevFilters = this.filters;
        this.filters = filters;
        this.page = -1;
        try {
            this.currentFetch = __classPrivateFieldGet(this, _LazyNotificationList_instances, "m", _LazyNotificationList_loadMore).call(this, true);
            await this.currentFetch;
        }
        catch (error) {
            this.filters = prevFilters;
            this.page = prevPage;
            throw error;
        }
    }
    loadMore() {
        this.currentFetch ??= __classPrivateFieldGet(this, _LazyNotificationList_instances, "m", _LazyNotificationList_loadMore).call(this);
        return this.currentFetch;
    }
    hasMore() {
        return this.items.length < this.total;
    }
    subscribe(listener) {
        this.listeners.push(listener);
        return () => {
            pull(this.listeners, listener);
        };
    }
    update(readStatusMap) {
        this.items.forEach(i => i.committed = readStatusMap.get(i.id) ?? i.committed);
        if (this.filters.committed !== undefined) {
            this.items = this.items.filter(i => i.committed === this.filters.committed);
            // if the filtered list has one item or less, we update the list with the backend so it can show more items.
            // we can't use loadMore in this case because the page 2 would now skip some items. We'd need the backend to implement a cursor
            // interface.
            if (this.items.length <= 1)
                this.applyFilters(this.filters);
        }
        this.notify();
    }
    mute() {
        this.listeners = [];
    }
}
_LazyNotificationList_instances = new WeakSet(), _LazyNotificationList_loadMore = async function _LazyNotificationList_loadMore(reset = false) {
    try {
        const result = await this.load({ ...this.filters, page: this.page + 1 });
        if (reset) {
            this.items = [];
            this.total = 0;
        }
        // we can't have items with the same id: this can happen if new notifications have been created after the first page was loaded.
        this.items = uniqBy([...this.items, ...result.items], 'id');
        // we can't keep loading more if we already loaded every item or if the API returned an empty list.
        this.total = result.items.length ? (this.total || result.total) : this.items.length;
        this.page++;
        this.notify();
    }
    finally {
        this.currentFetch = undefined;
    }
};
//# sourceMappingURL=LazyNotificationList.js.map