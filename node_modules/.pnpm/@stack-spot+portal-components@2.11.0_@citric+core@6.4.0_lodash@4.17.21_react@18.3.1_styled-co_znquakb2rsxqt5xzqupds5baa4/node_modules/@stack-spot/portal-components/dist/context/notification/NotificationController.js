import { pull } from 'lodash';
import { LazyNotificationList } from './LazyNotificationList.js';
const DEFAULT_POLLING_MS = 120000;
export class NotificationController {
    constructor(config) {
        Object.defineProperty(this, "lazyLists", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "readStatusMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "nextId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "unreadNotification", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "lastUnreadVerification", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pollingTimeoutId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unreadNotificationListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.config = config;
        config.pollingMS ??= DEFAULT_POLLING_MS;
        config.notificationsPath ??= '/notifications';
    }
    hasUnreadNotificationInMemory() {
        for (const [, read] of this.readStatusMap) {
            if (!read.valueOf())
                return true;
        }
        return false;
    }
    setUnreadNotification(value) {
        this.unreadNotification = value;
        if (!value) {
            this.pollingTimeoutId = window.setTimeout(() => this.checkUnread(), this.config.pollingMS);
        }
        this.unreadNotificationListeners.forEach(l => l(value));
    }
    createLazyNotificationList(filters) {
        const list = new LazyNotificationList({
            id: this.nextId++,
            filters,
            load: async (options) => {
                const result = await this.config.load(options);
                result.items.forEach((i) => {
                    this.readStatusMap.set(i.id, i.committed);
                    // updating the unread indicator, since it might be stale
                    if (!i.committed)
                        this.setUnreadNotification(true);
                });
                this.lazyLists.forEach(l => l !== list && list.update(this.readStatusMap));
                return result;
            },
        });
        this.lazyLists.set(list.id, list);
        return list;
    }
    destroyLazyNotificationList(id) {
        this.lazyLists.get(id)?.mute();
        this.lazyLists.delete(id);
    }
    async checkUnread() {
        window.clearInterval(this.pollingTimeoutId);
        this.setUnreadNotification(await this.config.checkForUnreadNotificationsSince(this.lastUnreadVerification));
        this.lastUnreadVerification = new Date();
    }
    async markAsCommitted(notificationId) {
        if (this.readStatusMap.get(notificationId))
            return;
        this.readStatusMap.set(notificationId, true);
        this.lazyLists.forEach(l => l.update(this.readStatusMap));
        try {
            await this.config.markAsCommitted(notificationId);
            // update the notification indicator: this is an inconsistency, we should actually ask the API, but since it's an expensive
            // operation in the backend, we won't, instead, we'll only check the notifications we have loaded in memory.
            if (!this.hasUnreadNotificationInMemory())
                this.setUnreadNotification(false);
        }
        catch {
            this.readStatusMap.set(notificationId, false);
            this.lazyLists.forEach(l => l.update(this.readStatusMap));
        }
    }
    onUnreadNotificationChange(listener) {
        this.unreadNotificationListeners.push(listener);
        return () => {
            pull(this.unreadNotificationListeners, listener);
        };
    }
    hasUnreadNotification() {
        return this.unreadNotification;
    }
    reset() {
        this.lazyLists.clear();
        this.readStatusMap.clear();
        this.lastUnreadVerification = undefined;
        this.unreadNotification = false;
    }
    mute() {
        this.unreadNotificationListeners = [];
    }
}
//# sourceMappingURL=NotificationController.js.map