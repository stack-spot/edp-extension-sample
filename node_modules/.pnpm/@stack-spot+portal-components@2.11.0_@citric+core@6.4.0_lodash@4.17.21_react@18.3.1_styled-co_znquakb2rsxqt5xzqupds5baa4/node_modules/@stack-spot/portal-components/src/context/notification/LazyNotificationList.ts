import { pull, uniqBy } from 'lodash'
import { GetTenantNotificationsResponse, ResponseModelGetTenantNotificationsResponse } from '../../notifications'
import { LazyNotificationListener, LoadNotificationsFilters, LoadNotificationsOptions } from './types'

interface ConstructorParams {
  id: number,
  load: (options: LoadNotificationsOptions) => Promise<ResponseModelGetTenantNotificationsResponse>,
  filters?: LoadNotificationsFilters,
}

export class LazyNotificationList {
  readonly id: number
  items: GetTenantNotificationsResponse[] = []
  private page = -1
  private total = 0
  private filters: LoadNotificationsFilters
  private readonly load: (options: LoadNotificationsOptions) => Promise<ResponseModelGetTenantNotificationsResponse>
  private listeners: LazyNotificationListener[] = []
  private currentFetch: Promise<void> | undefined

  constructor({ id, load, filters = {} }: ConstructorParams) {
    this.id = id
    this.load = load
    this.filters = filters
  }

  private notify() {
    const hasMore = this.hasMore()
    this.listeners.forEach(l => l(this.items, hasMore))
  }

  async #loadMore(reset = false): Promise<void> {
    try {
      const result = await this.load({ ...this.filters, page: this.page + 1 })
      if (reset) {
        this.items = []
        this.total = 0
      }
      // we can't have items with the same id: this can happen if new notifications have been created after the first page was loaded.
      this.items = uniqBy([...this.items, ...result.items], 'id')
      // we can't keep loading more if we already loaded every item or if the API returned an empty list.
      this.total = result.items.length ? (this.total || result.total) : this.items.length
      this.page++
      this.notify()
    } finally {
      this.currentFetch = undefined
    }
  }

  async applyFilters(filters: LoadNotificationsFilters) {
    try {
      await this.currentFetch
    } catch {
      /* empty: this error will be treated by the function who actually triggered `currentFetch`. We just need to make sure we wait until 
      it ends before making new requests. */
    }
    const prevPage = this.page
    const prevFilters = this.filters
    this.filters = filters
    this.page = -1
    try {
      
      this.currentFetch = this.#loadMore(true)
      await this.currentFetch
    } catch (error) {
      this.filters = prevFilters
      this.page = prevPage
      throw error
    }
  }

  loadMore() {
    this.currentFetch ??= this.#loadMore()
    return this.currentFetch
  }

  hasMore() {
    return this.items.length < this.total
  }

  subscribe(listener: LazyNotificationListener) {
    this.listeners.push(listener)
    return () => {
      pull(this.listeners, listener)
    }
  }

  update(readStatusMap: Map<string, boolean>) {
    this.items.forEach(i => i.committed = readStatusMap.get(i.id) ?? i.committed)
    if (this.filters.committed !== undefined) {
      this.items = this.items.filter(i => i.committed === this.filters.committed)
      // if the filtered list has one item or less, we update the list with the backend so it can show more items.
      // we can't use loadMore in this case because the page 2 would now skip some items. We'd need the backend to implement a cursor
      // interface.
      if (this.items.length <= 1) this.applyFilters(this.filters)
    }
    this.notify()
  }

  mute() {
    this.listeners = []
  }
}
