import { pull } from 'lodash'
import { LazyNotificationList } from './LazyNotificationList'
import { LoadNotificationsFilters, NotificationConfig, UnreadNotificationListener } from './types'

const DEFAULT_POLLING_MS = 120000

export class NotificationController {
  private lazyLists = new Map<number, LazyNotificationList>()
  readonly config: NotificationConfig
  private readStatusMap = new Map<string, boolean>()
  private nextId = 1
  private unreadNotification = false
  private lastUnreadVerification: Date | undefined
  private pollingTimeoutId: number | undefined
  private unreadNotificationListeners: UnreadNotificationListener[] = []

  constructor(config: NotificationConfig) {
    this.config = config
    config.pollingMS ??= DEFAULT_POLLING_MS
    config.notificationsPath ??= '/notifications'
  }

  private hasUnreadNotificationInMemory() {
    for (const [, read] of this.readStatusMap) {
      if (!read.valueOf()) return true
    }
    return false
  }

  private setUnreadNotification(value: boolean) {
    this.unreadNotification = value
    if (!value) {
      this.pollingTimeoutId = window.setTimeout(() => this.checkUnread(), this.config.pollingMS)
    }
    this.unreadNotificationListeners.forEach(l => l(value))
  }

  createLazyNotificationList(filters?: LoadNotificationsFilters): LazyNotificationList {
    const list = new LazyNotificationList({
      id: this.nextId++,
      filters,
      load: async (options) => {
        const result = await this.config.load(options)
        result.items.forEach((i) => {
          this.readStatusMap.set(i.id, i.committed)
          // updating the unread indicator, since it might be stale
          if (!i.committed) this.setUnreadNotification(true)
        })
        this.lazyLists.forEach(l => l !== list && list.update(this.readStatusMap))
        return result
      },
    })
    this.lazyLists.set(list.id, list)
    return list
  }

  destroyLazyNotificationList(id: number) {
    this.lazyLists.get(id)?.mute()
    this.lazyLists.delete(id)
  }

  async checkUnread() {
    window.clearInterval(this.pollingTimeoutId)
    this.setUnreadNotification(await this.config.checkForUnreadNotificationsSince(this.lastUnreadVerification))
    this.lastUnreadVerification = new Date()
  }

  async markAsCommitted(notificationId: string) {
    if (this.readStatusMap.get(notificationId)) return
    this.readStatusMap.set(notificationId, true)
    this.lazyLists.forEach(l => l.update(this.readStatusMap))
    try {
      await this.config.markAsCommitted(notificationId)
      // update the notification indicator: this is an inconsistency, we should actually ask the API, but since it's an expensive
      // operation in the backend, we won't, instead, we'll only check the notifications we have loaded in memory.
      if (!this.hasUnreadNotificationInMemory()) this.setUnreadNotification(false)
    } catch {
      this.readStatusMap.set(notificationId, false)
      this.lazyLists.forEach(l => l.update(this.readStatusMap))
    }
  }

  onUnreadNotificationChange(listener: UnreadNotificationListener) {
    this.unreadNotificationListeners.push(listener)
    return () => {
      pull(this.unreadNotificationListeners, listener)
    }
  }

  hasUnreadNotification() {
    return this.unreadNotification
  }

  reset() {
    this.lazyLists.clear()
    this.readStatusMap.clear()
    this.lastUnreadVerification = undefined
    this.unreadNotification = false
  }

  mute() {
    this.unreadNotificationListeners = []
  }
}
