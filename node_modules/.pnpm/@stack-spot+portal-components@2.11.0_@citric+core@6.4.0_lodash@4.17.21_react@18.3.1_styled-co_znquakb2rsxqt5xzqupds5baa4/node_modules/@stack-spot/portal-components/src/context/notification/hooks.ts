import { useLanguage } from '@stack-spot/portal-translate'
import { useCallback, useRef, useState } from 'react'
import { useManualRender } from '../../hooks/manual-render'
import { useEffectOnce } from '../../hooks/use-effect-once'
import { GetTenantNotificationsResponse } from '../../notifications'
import { useNotificationController } from './context'
import { LazyNotificationList } from './LazyNotificationList'
import { LoadNotificationsFilters } from './types'

export function useNotificationList(initialFilters: LoadNotificationsFilters = {}) {
  const { repaint } = useManualRender()
  const [status, setStatus] = useState<'startup' | 'idle' | 'error' | 'loading'>('startup')
  const error = useRef<any>()
  const controller = useNotificationController()
  const [filters, setFilters] = useState(initialFilters)
  const list = useRef<LazyNotificationList | undefined>()

  useEffectOnce(() => {
    async function start() {
      list.current = controller.createLazyNotificationList(initialFilters)
      list.current.subscribe(repaint)
      try {
        await list.current?.loadMore()
        setStatus('idle')
      } catch (e) {
        setStatus('error')
        error.current = e
      }
    }
    start()
    return () => {
      if (list.current) controller.destroyLazyNotificationList(list.current.id)
    }
  })

  const applyFilters = useCallback(async (newFilters: LoadNotificationsFilters) => {
    if (!list.current) return
    setStatus('loading')
    // since we're inside a useCallback, we don't have direct access to the current value of "filters". The only way we can access this
    // value is from the function "setFilters". But "setFilters" run async. For this reason, we wait the function to run and retrieve the
    // current value before continuing, hence the use of the await and promise below.
    const { next, prev } = await new Promise<{ next: LoadNotificationsFilters, prev: LoadNotificationsFilters }>((resolve) => {
      setFilters((filters) => {
        const prev = filters
        const next = { ...filters, ...newFilters }
        resolve({ prev, next })
        return next
      })
    })
    try {
      await list.current.applyFilters(next)
      setStatus('idle')
      error.current = undefined
    } catch (e) {
      setFilters(prev)
      if (error.current) {
        error.current = e
        setStatus('error')
      } else {
        setStatus('idle')
      }
    }
  }, [])

  return {
    status,
    items: list.current?.items ?? [],
    hasMore: list.current?.hasMore() ?? false,
    loadMore: () => list.current?.loadMore(),
    refresh: () => applyFilters(filters),
    applyFilters,
    filters,
    error: error.current,
  }
}

export function useGetNotificationTitleAndDescription({ content }: GetTenantNotificationsResponse) {
  const language = useLanguage()
  const { title, description } = content?.[language] || content?.en || {}

  return {
    title,
    description: description?.replace(/^\s*/gm, '').replace(/^#+\s*/gm, '\n'),
  }
}

export function useUnreadNotifications() {
  const [hasUnreadNotifications, setUnreadNotifications] = useState(false)
  const controller = useNotificationController()

  useEffectOnce(() => {
    const unsubscribe = controller.onUnreadNotificationChange(setUnreadNotifications)
    controller.checkUnread()
    return unsubscribe
  })

  return hasUnreadNotifications
}
