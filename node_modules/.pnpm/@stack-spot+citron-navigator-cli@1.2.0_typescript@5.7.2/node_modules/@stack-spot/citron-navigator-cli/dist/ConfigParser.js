"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigParser = void 0;
const yaml_1 = require("yaml");
const constants_1 = require("./constants");
const error_1 = require("./error");
const PARAM_NAME_REGEX = /^[A-z_]\w*$/;
const MODULAR_ROUTE_REGEX = /^\+ (\w+) ~ (\w+(?:\.\w+)*) \(([^)]+)\)\s*$/; // + name ~ reference (path)
class ConfigParser {
    constructor(config) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "routeKeys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.config = config;
    }
    parseParameter({ key, value }) {
        if (typeof value !== 'string')
            throw new error_1.InvalidYamlKeyType(key);
        // regex: modifier? name: jsType (tsType)?
        const [, modifier, name] = key.match(/^(?:(\w+)\s+)?(\w+)$/) ?? [];
        const [, jsType, tsType] = value.match(/^([^\s]+)(?:\s+\((.+)\))?$/) ?? [];
        if (!name || !jsType)
            throw new error_1.InvalidSearchParamFormat(key, value);
        if (modifier && modifier !== 'propagate')
            throw new error_1.InvalidModifier(modifier, name);
        if (!name.match(PARAM_NAME_REGEX))
            throw new error_1.InvalidSearchParamName(name);
        if (!constants_1.VALID_TYPES.includes(jsType))
            throw new error_1.InvalidParameterType(jsType, name);
        return {
            name,
            jsType: jsType,
            tsType: tsType || jsType,
            propagate: modifier === 'propagate',
        };
    }
    parsePath(path, params) {
        const parts = path.split('/').filter(part => !!part);
        return parts.map(part => {
            const [, name] = part.match(/^{([^}]+)}$/) ?? [];
            if (!name)
                return part;
            if (!name.match(PARAM_NAME_REGEX))
                throw new error_1.InvalidRouteParamName(name);
            const details = params.find(p => p.name === name);
            return details ?? { name, jsType: 'string', tsType: 'string' };
        });
    }
    parseParams(rawRoute) {
        if (!rawRoute)
            return [];
        return Object.keys(rawRoute).reduce((result, current) => {
            const pair = { key: current, value: rawRoute[current] };
            return pair.key.startsWith('+') ? result : [...result, this.parseParameter(pair)];
        }, []);
    }
    parseChildren(rawRoute, route) {
        if (!rawRoute)
            return [];
        return Object.keys(rawRoute).reduce((result, current) => {
            const pair = { key: current, value: rawRoute[current] };
            return pair.key.startsWith('+') ? [...result, this.parseRoute(pair, route)] : result;
        }, []);
    }
    getQueryParams(params, routeKey, ownPath, parent) {
        const inheritedQuery = parent?.query?.filter(p => p.propagate) ?? [];
        const ownQuery = params.filter((param) => {
            if (parent?.path?.some(p => typeof p === 'object' && p.name === param.name)) {
                throw new error_1.SearchParamClashWithRouteParamError(param.name, routeKey);
            }
            if (inheritedQuery.some(p => p.name === param.name)) {
                throw new error_1.SearchParamClashWithPropagatedParamError(param.name, routeKey);
            }
            return !ownPath.some(p => typeof p === 'object' && p.name === param.name);
        });
        return [...inheritedQuery, ...ownQuery];
    }
    parseRouteModule({ key, value }, parent) {
        if (parent)
            throw new error_1.InvalidRouteLinkLevel();
        const [, name, ref, path] = key.match(MODULAR_ROUTE_REGEX) ?? [];
        if (!path.startsWith('/'))
            throw new error_1.InvalidPath(path);
        const params = this.parseParams(value);
        const pathObject = this.parsePath(path, params);
        const route = {
            localKey: name,
            globalKey: ref,
            name,
            path: pathObject,
            query: this.getQueryParams(params, name, pathObject, parent),
        };
        route.children = this.parseChildren(value, route);
        return route;
    }
    parseRoute({ key, value }, parent) {
        if (key.match(MODULAR_ROUTE_REGEX))
            return this.parseRouteModule({ key, value }, parent);
        const [, name, path] = key.match(/^\+ (\w+) \(([^)]+)\)\s*$/) ?? []; // + name (path)
        if (!name || !path)
            throw new error_1.InvalidRouteFormat(key);
        if (!path.startsWith('/'))
            throw new error_1.InvalidPath(path);
        const routeKey = parent ? `${parent.localKey}.${name}` : name;
        if (this.routeKeys.includes(routeKey))
            throw new error_1.DuplicatedRouteError(routeKey);
        this.routeKeys.push(routeKey);
        const params = this.parseParams(value);
        const ownPath = this.parsePath(path, params);
        const route = {
            localKey: routeKey,
            globalKey: parent ? `${parent.globalKey}.${name}` : name,
            name,
            path: [...(parent?.path ?? []), ...ownPath],
            query: this.getQueryParams(params, routeKey, ownPath, parent),
            parent,
        };
        route.children = this.parseChildren(value, route);
        return route;
    }
    parse() {
        const yaml = (0, yaml_1.parse)(this.config);
        if (typeof yaml !== 'object')
            throw new error_1.InvalidYaml();
        const keys = Object.keys(yaml);
        if (keys.length !== 1)
            throw new error_1.NoRootError();
        return {
            root: this.parseRoute({ key: keys[0], value: yaml[keys[0]] }, undefined),
            isModule: MODULAR_ROUTE_REGEX.test(keys[0]),
        };
    }
}
exports.ConfigParser = ConfigParser;
//# sourceMappingURL=ConfigParser.js.map