"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoRootError = exports.DuplicatedRouteError = exports.InvalidRouteFormat = exports.InvalidPath = exports.InvalidRouteLinkLevel = exports.SearchParamClashWithPropagatedParamError = exports.SearchParamClashWithRouteParamError = exports.InvalidRouteParamName = exports.InvalidParameterType = exports.InvalidSearchParamName = exports.InvalidModifier = exports.InvalidSearchParamFormat = exports.InvalidYamlKeyType = exports.InvalidYaml = exports.ParseError = void 0;
const constants_1 = require("./constants");
class ParseError extends Error {
}
exports.ParseError = ParseError;
class InvalidYaml extends Error {
    constructor() {
        super('The YAML file is not formatted correctly. Please make sure that:\n  - all parameter values are strings;\n  - all routes start with "+ " and ends with ":".');
    }
}
exports.InvalidYaml = InvalidYaml;
class InvalidYamlKeyType extends ParseError {
    constructor(key) {
        super(`Error while parsing key "${key}" of yaml. Please make sure that:\n  - all parameter values are strings;\n  - all routes start with "+ " and ends with ":".`);
    }
}
exports.InvalidYamlKeyType = InvalidYamlKeyType;
class InvalidSearchParamFormat extends ParseError {
    constructor(key, value) {
        super(`Incorrect parameter format: "${key}: ${value}". Expected format is "modifier name: type (typescriptType)", where modifier and typescriptType are optional.`);
    }
}
exports.InvalidSearchParamFormat = InvalidSearchParamFormat;
class InvalidModifier extends ParseError {
    constructor(modifier, parameterName) {
        super(`Invalid modifier "${modifier}" for parameter "${parameterName}". Valid options are: "propagate".`);
    }
}
exports.InvalidModifier = InvalidModifier;
class InvalidSearchParamName extends ParseError {
    constructor(name) {
        super(`Invalid parameter name: ${name}. Please use only numbers, letters and _. Parameters also can't start with number.`);
    }
}
exports.InvalidSearchParamName = InvalidSearchParamName;
class InvalidParameterType extends ParseError {
    constructor(type, parameterName) {
        super(`Invalid type "${type}" for parameter "${parameterName}". Valid options are: ${constants_1.VALID_TYPES.map(t => `"${t}"`).join(', ')}.`);
    }
}
exports.InvalidParameterType = InvalidParameterType;
class InvalidRouteParamName extends ParseError {
    constructor(name) {
        super(`Invalid route parameter: ${name}. Please use only numbers, letters and _. Route parameters also can't start with number.`);
    }
}
exports.InvalidRouteParamName = InvalidRouteParamName;
class SearchParamClashWithRouteParamError extends ParseError {
    constructor(parameterName, routeKey) {
        super(`Parameter "${parameterName}" of route "${routeKey}" has already been defined as a route parameter for a parent route.`);
    }
}
exports.SearchParamClashWithRouteParamError = SearchParamClashWithRouteParamError;
class SearchParamClashWithPropagatedParamError extends ParseError {
    constructor(parameterName, routeKey) {
        super(`Parameter "${parameterName}" of route "${routeKey}" has already been defined as a propagated query parameter for a parent route.`);
    }
}
exports.SearchParamClashWithPropagatedParamError = SearchParamClashWithPropagatedParamError;
class InvalidRouteLinkLevel extends ParseError {
    constructor() {
        super('Invalid route module: route modules (~) can only appear at the root level.');
    }
}
exports.InvalidRouteLinkLevel = InvalidRouteLinkLevel;
class InvalidPath extends ParseError {
    constructor(path) {
        super(`Invalid path: ${path}. Paths must start with "/".`);
    }
}
exports.InvalidPath = InvalidPath;
class InvalidRouteFormat extends ParseError {
    constructor(key) {
        super(`Invalid route key: ${key}. Expected format: + name (path).`);
    }
}
exports.InvalidRouteFormat = InvalidRouteFormat;
class DuplicatedRouteError extends ParseError {
    constructor(routeKey) {
        super(`Duplicated route: "${routeKey}".`);
    }
}
exports.DuplicatedRouteError = DuplicatedRouteError;
class NoRootError extends ParseError {
    constructor() {
        super('Invalid format. Expected a single route at the root level.');
    }
}
exports.NoRootError = NoRootError;
//# sourceMappingURL=error.js.map