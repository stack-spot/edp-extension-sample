import { form as w } from "./query.js";
import { joinUrl as b } from "./util.js";
import { mergeHeaders as d, normalizeHeaders as h } from "./headers.js";
function J(a = {}) {
  async function e(r, n) {
    const t = await p(r, n);
    let s;
    try {
      s = await t.text();
    } catch {
    }
    return {
      status: t.status,
      headers: t.headers,
      contentType: t.headers.get("content-type"),
      data: s
    };
  }
  async function i(r, n = {}) {
    const { status: t, headers: s, contentType: u, data: o } = await e(r, {
      ...n,
      headers: d(
        {
          Accept: "application/json"
        },
        n.headers
      )
    });
    return (u ? u.includes("json") : !1) ? {
      status: t,
      headers: s,
      data: o ? JSON.parse(o) : null
    } : { status: t, headers: s, data: o };
  }
  async function f(r, n = {}) {
    const t = await p(r, n);
    let s;
    try {
      s = await t.blob();
    } catch {
    }
    return { status: t.status, headers: t.headers, data: s };
  }
  async function p(r, n = {}) {
    const {
      baseUrl: t,
      fetch: s,
      ...u
    } = {
      ...a,
      ...n,
      headers: d(a.headers, n.headers)
    }, o = b(t, r);
    return await (s || fetch)(o, u);
  }
  return {
    ok: y,
    fetchText: e,
    fetchJson: i,
    fetchBlob: f,
    mergeHeaders: d,
    json({ body: r, headers: n, ...t }) {
      return {
        ...t,
        ...r != null && { body: JSON.stringify(r) },
        headers: d(
          {
            "Content-Type": "application/json"
          },
          n
        )
      };
    },
    form({ body: r, headers: n, ...t }) {
      return {
        ...t,
        ...r != null && { body: w(r) },
        headers: d(
          {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          n
        )
      };
    },
    multipart({ body: r, headers: n, ...t }) {
      if (r == null)
        return { ...t, body: r, headers: h(n) };
      const s = new (a.formDataConstructor || t.formDataConstructor || FormData)(), u = (o, c) => {
        typeof c == "string" || c instanceof Blob ? s.append(o, c) : typeof c == "number" ? s.append(o, String(c)) : s.append(
          o,
          new Blob([JSON.stringify(c)], { type: "application/json" })
        );
      };
      return Object.entries(r).forEach(([o, c]) => {
        Array.isArray(c) ? c.forEach((m) => u(o, m)) : u(o, c);
      }), {
        ...t,
        body: s,
        headers: h(n)
      };
    }
  };
}
async function O(a, e) {
  const { status: i, data: f, headers: p } = await a, r = e[i];
  if (r)
    return r(f);
  if (e.default)
    return e.default(i, f);
  throw new l(i, f, p);
}
const j = [200, 201, 202, 204];
async function y(a) {
  const e = await a;
  if (j.some((i) => i == e.status))
    return e.data;
  throw new l(e.status, e.data, e.headers);
}
function E(a) {
  return (...e) => y(a(...e));
}
function x(a) {
  const e = {};
  return Object.entries(a).forEach(([i, f]) => {
    e[i] = typeof f == "function" ? E(f) : f;
  }), e;
}
class l extends Error {
  status;
  data;
  headers;
  constructor(e, i, f) {
    super(`Error: ${e}`), this.status = e, this.data = i, this.headers = f;
  }
}
export {
  l as HttpError,
  j as SUCCESS_CODES,
  O as handle,
  y as ok,
  E as okify,
  x as optimistic,
  J as runtime
};
//# sourceMappingURL=index.js.map
