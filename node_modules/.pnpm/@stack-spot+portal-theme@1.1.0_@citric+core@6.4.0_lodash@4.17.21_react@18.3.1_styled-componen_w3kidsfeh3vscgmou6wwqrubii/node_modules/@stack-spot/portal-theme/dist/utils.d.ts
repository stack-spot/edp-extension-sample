import { ColorPaletteLevel, ColorPaletteName, ColorSchemeLevel, ColorSchemeName } from './definition.js';
/**
 * Gets the ideal contrast color for the color passed as parameter.
 * @param color the color to get a contrast to.
 * @param level the level of the color to get a contrast to. Defaults to 600.
 * @returns the css variable for the contrast color ("var(--color-level)").
 */
export declare function contrastColor<T extends ColorPaletteName | ColorSchemeName>(color: T, level?: T extends ColorPaletteName ? ColorPaletteLevel : ColorSchemeLevel): string;
/**
 * Finds out the value of a CSS variable. By default, it uses the body of the HTML document to get these values from. You can also pass a
 * second parameter with the element you want to get the value from.
 *
 * Supposing the actual name of the variable is `name-of-variable`, the value passed to the first parameter (`varname`) may be:
 * `name-of-variable` or `--name-of-variable` or `var(--name-of-variable)`. All these formats work.
 *
 * Example:
 * ```ts
 * valueOf(theme.color.primary['300']) // results in '#FFC8B5'
 * ```
 *
 * @param varname name of the CSS variable to get the value from.
 * @param element HTML element to get the variable from.
 * @returns the value of variable. If no variable is found, an empty string is returned.
 */
export declare function valueOf(varname: string, element?: HTMLElement): string;
interface ColorGeneratorOptions {
    /**
     * The color to start from.
     */
    fromColor?: ColorPaletteName;
    /**
     * The level to start from.
     */
    fromLevel?: ColorPaletteLevel;
    /**
     * The color array to iterate over.
     */
    colorOrder?: ColorPaletteName[];
    /**
     * The level array to iterate over.
     */
    levelOrder?: ColorPaletteLevel[];
}
interface PaletteColor {
    color: ColorPaletteName;
    level: ColorPaletteLevel;
}
/**
 * Generates a sequence of colors of the palette that are ideally spread. This sequence is infinite and will repeat once all colors are
 * used.
 *
 * The colors generated here are not random! This sequence will always be the same.
 *
 * Example:
 * ```ts
 * // This code generates 10 colors from the palette
 * const color = createColorSequence()
 * const myColors: { color: string, level: number }[] = []
 *
 * for (let i = 0; i < 10; i++) {
 *   myColors.push(color.next().value)
 * }
 * ```
 *
 * @param options the options to change the color sequence {@link ColorGeneratorOptions}.
 * @return an iterator where each element is an object where `name` is the name of the color palette and `level` is the level of
 * the color. To create a color from `color` and `level`, you can use `theme.color[color][level]`.
 */
export declare function createColorSequence({ colorOrder, fromColor, fromLevel, levelOrder }?: ColorGeneratorOptions): Generator<PaletteColor, PaletteColor, PaletteColor>;
/**
 * Same as `createColorSequence`, but it generates the css variables for the colors directly.
 *
 * Example:
 * ```ts
 * // This code generates 10 colors from the palette
 * const color = paletteSequence()
 * const myColors: string[] = []
 *
 * for (let i = 0; i < 10; i++) {
 *   myColors.push(color.next().value)
 * }
 * ```
 * `myColors` will contain values like "var(--blue-300)".
 */
export declare function paletteSequence(options?: ColorGeneratorOptions): Generator<string, string, string>;
/**
 * Applies opacity to a theme color variable.
 * @param opacity the opacity in [0, 1]
 */
export declare function withOpacity(colorVariable: string, opacity: number): string;
/**
 * A utility for using arrays instead of strings when defining the CSS class of an element.
 *
 * This function will remove any falsy value from the array and then join every class name into a valid string.
 *
 * @param list
 * @returns
 */
export declare function listToClass(list: (string | undefined | boolean | null)[]): string;
export {};
//# sourceMappingURL=utils.d.ts.map