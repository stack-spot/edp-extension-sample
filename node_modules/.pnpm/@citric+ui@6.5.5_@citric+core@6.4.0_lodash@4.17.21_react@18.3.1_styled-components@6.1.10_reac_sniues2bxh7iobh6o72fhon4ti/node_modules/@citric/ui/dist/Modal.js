import { jsx as _jsx } from "react/jsx-runtime";
import { Backdrop } from '@citric/core';
import { extendStyle, overwriteStyle } from '@citric/core/dist/component-style.js';
import forwardRefAs from '@citric/core/dist/forward-ref-as.js';
import { css, styled } from '@citric/core/dist/styled.js';
import { defaultConfig } from '@citric/core/dist/utils/config.js';
import { getColor, getFontStyle, getRadius, getSpacing } from '@citric/core/dist/utils/theme.js';
import { Times } from '@citric/icons';
import { createContext, useContext, useEffect, useMemo } from 'react';
import IconButton from './IconButton.js';
const modalSizes = {
    lg: () => css `
    width: 800px;
  `,
    md: () => css `
    width: 600px;
  `,
    sm: () => css `
    width: 400px;
  `,
};
const modalPosition = {
    center: () => css `
    position: relative;
    margin: 3.75rem auto;
    border-radius: ${({ theme }) => getRadius(theme, 'md')};
  `,
    right: () => css `
    position: absolute;
    right: 0;
    height: 100vh;
    margin: 0;
    border-top-left-radius: ${({ theme }) => getRadius(theme, 'md')};
    border-bottom-left-radius: ${({ theme }) => getRadius(theme, 'md')};
  `,
};
export const ModalContext = createContext({});
export const ModalStyled = styled.section
    .withConfig(defaultConfig) `
  box-sizing: border-box;
  display: flex;
  align-items: center;
  padding: ${({ theme }) => getSpacing(theme, 9)};
  flex-wrap: wrap;
  ${extendStyle('Modal')};

  ${({ size = 'lg' }) => modalSizes[size]}
  ${({ position = 'center' }) => modalPosition[position]}

  background-color: ${({ theme }) => getColor(theme, 'light.400')};
  color: ${({ theme }) => getColor(theme, 'light.contrastText')};

  ${overwriteStyle('Modal')};
`;
export const ModalHeader = styled.header.withConfig(defaultConfig) `
  box-sizing: border-box;
  flex-grow: 1;
  ${extendStyle('ModalHeader')};

  font: ${({ theme }) => getFontStyle(theme, 'h3')};
  color: ${({ theme }) => getColor(theme, 'light.contrastText')};

  ${overwriteStyle('ModalHeader')};
`;
export const ModalContent = styled.div.withConfig(defaultConfig) `
  box-sizing: border-box;
  width: 100%;

  max-height: ${({ scrollBehavior = 'inside' }) => scrollBehavior === 'inside' ? '50vh' : 'fit-content'};

  overflow-y: auto;
  &::-webkit-scrollbar {
    width: 5px;
  }
  &::-webkit-scrollbar-track {
    background: ${({ theme }) => getColor(theme, 'light.400')};
  }
  &::-webkit-scrollbar-thumb {
    background: ${({ theme }) => getColor(theme, 'light.700')};
    border-radius: ${({ theme }) => getRadius(theme, 'xs')};
  }

  ${extendStyle('ModalContent')};
  ${overwriteStyle('ModalContent')};
`;
export const ModalFooter = styled.footer.withConfig(defaultConfig) `
  box-sizing: border-box;
  width: 100%;
  display: flex;
  ${extendStyle('ModalFooter')};

  justify-content: ${({ justifyContent = 'space-between' }) => justifyContent};
  ${overwriteStyle('ModalFooter')};
`;
export const ModalCloseButtonStyle = styled(IconButton) `
  ${extendStyle('ModalCloseButton')};
  ${overwriteStyle('ModalCloseButton')};
`;
export const ModalCloseButton = forwardRefAs(function ModalCloseButton({ children = _jsx(Times, {}), ...props }, ref) {
    const ctx = useContext(ModalContext);
    return (_jsx(ModalCloseButtonStyle, { onClick: ctx.onClose, ...props, ref: ref, autoFocus: true, children: children }));
});
export const Modal = forwardRefAs(function Modal({ onClose, ...props }, ref) {
    const ctx = useMemo(() => ({ onClose }), [onClose]);
    const isElementDisabled = (element) => 'disabled' in element && element.disabled;
    useEffect(() => {
        const modal = document.getElementById('modal');
        if (modal) {
            const focusableElements = Array.from(modal.querySelectorAll('*'))
                .filter(element => element instanceof HTMLElement &&
                element.tabIndex >= 0 &&
                !isElementDisabled(element) &&
                !element.hidden);
            modal.addEventListener('keydown', function trapTabKey(e) {
                if (e.key === 'Tab') {
                    const focusableElementsArray = Array.from(focusableElements);
                    if (document.activeElement === focusableElementsArray[focusableElementsArray.length - 1] && !e.shiftKey) {
                        focusableElementsArray[0].focus();
                        e.preventDefault();
                    }
                    else if (document.activeElement === focusableElementsArray[0] && e.shiftKey) {
                        focusableElementsArray[focusableElementsArray.length - 1].focus();
                        e.preventDefault();
                    }
                }
            });
        }
    }, []);
    return (_jsx(ModalContext.Provider, { value: ctx, children: _jsx(Backdrop, { onClick: onClose, "data-testid": "backdrop", children: _jsx(ModalStyled, { ...props, ref: ref, id: "modal" }) }) }));
});
//# sourceMappingURL=Modal.js.map