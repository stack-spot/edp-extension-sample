import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Box, Flex, Input, Text } from '@citric/core';
import { extendStyle, overwriteStyle } from '@citric/core/dist/component-style.js';
import forwardRefAs from '@citric/core/dist/forward-ref-as.js';
import { css, styled } from '@citric/core/dist/styled.js';
import { defaultConfig } from '@citric/core/dist/utils/config.js';
import { getColor, getRadius } from '@citric/core/dist/utils/theme.js';
import { ChevronDown, ChevronLeft, ChevronRight } from '@citric/icons';
import { endOfMonth, isWithinInterval, startOfMonth } from 'date-fns';
import { useEffect, useRef, useState } from 'react';
import IconButton from './IconButton.js';
import useDatepicker from './hooks/useDatepicker.js';
import useOutsideFocus from './hooks/useOutsideFocus.js';
function handleTriggerEvent(props) {
    props.fnEvent && props.ref?.current?.addEventListener(props.event, props.fnEvent);
    setTimeout(() => {
        props.ref?.current?.dispatchEvent(new Event(props.event));
        props.fnEvent && props.ref?.current?.removeEventListener(props.event, props.fnEvent);
    }, 0);
}
const ARIALABELS_PTBR_DEFAULT = {
    showYear: 'abrir lista de anos',
    previousMonth: 'mês anterior',
    nextMonth: 'próximo mês',
};
const ARIALABELS_ENUS_DEFAULT = {
    showYear: 'open years list',
    previousMonth: 'previous month',
    nextMonth: 'next month',
};
const CalendarStyled = styled.div.withConfig(defaultConfig) `
  position: absolute;
  margin-top: 0.3rem;
  z-index: 15000;
  box-sizing: border-box;
  width: 17.5rem;
  padding: 1rem;
  box-shadow:  2px 2px 16px 0px ${({ theme }) => getColor(theme, 'primary.contrastText')};
  border-radius: ${({ theme }) => getRadius(theme, 'xs')};
  ${extendStyle('Datepicker')};

  display: ${({ visible }) => (visible ? 'block' : 'none')};
  background-color: ${({ theme }) => getColor(theme, 'light.300')};

  ${overwriteStyle('Datepicker')};
`;
const WeekStyled = styled.ul.withConfig(defaultConfig) `
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  padding: 0;
  margin: 0;
`;
const WeekOption = styled.li.withConfig(defaultConfig) `
  width: 2rem;
  height: 1rem;
  display: flex;
  box-sizing: border-box;
  justify-content: center;
  align-items: center;
  margin: 0.125rem;
`;
const EmptyDay = styled.li.withConfig(defaultConfig) `
  width: 2rem;
  height: 2rem;
  display: flex;
  box-sizing: border-box;
  justify-content: center;
  align-items: center;
  border-radius: 50%;
  margin: 0.125rem;
`;
const DayStyled = styled.li.withConfig(defaultConfig) `
  width: 2rem;
  height: 2rem;
  display: flex;
  box-sizing: border-box;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  border-radius: 50%;
  margin: 0.125rem;

  background: ${({ theme }) => getColor(theme, 'light.500')};

  /* :focus, */
  &:hover {
    outline: none;
    background: ${({ theme }) => getColor(theme, 'primary.300')};
  }

  &[aria-selected='true'] {
    ${({ theme }) => css `
        background: ${getColor(theme, 'primary.500')};
        color: ${getColor(theme, 'light.300')};
      `}
  }

  &[aria-hidden='true'],
  &[aria-disabled='true'] {
    opacity: 0;
    cursor: none;
  }

  &[aria-disabled='true'] {
    cursor: not-allowed;
  }

  &[aria-current='true'] {
    &[aria-selected='true'] {
      small {
        border-bottom: 1px solid ${({ theme }) => getColor(theme, 'light.300')};
      }
    }

    &[aria-selected='false'] {
      small {
        border-bottom: 1px solid ${({ theme }) => getColor(theme, 'primary.500')};
      }
    }
  }
`;
const ExpanderCalendarStyled = styled.div.withConfig(defaultConfig) `
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
`;
const Dropdown = styled.ul.withConfig(defaultConfig) `
  display: ${({ visible }) => (visible ? 'grid' : 'none')};
  grid-template-columns: repeat(4, 1fr);
  box-sizing: border-box;
  padding: 0;
  margin: 0;
  mb: 1rem;
`;
const DropdownItem = styled.li.withConfig(defaultConfig) `
  width: 3.5rem;
  height: 2rem;
  display: flex;
  box-sizing: border-box;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  border-radius: 1rem;
  margin: 0.25rem 0;

  background: ${({ theme }) => getColor(theme, 'light.400')};

  &:focus,
  &:hover {
    outline: none;
    background: ${({ theme }) => getColor(theme, 'primary.300')};
  }

  &[aria-selected='true'] {
    ${({ theme }) => css `
        background: ${getColor(theme, 'primary.500')};
        color: ${getColor(theme, 'light.300')};
      `}
  }

  &[aria-current='true'] {
    &[aria-selected='true'] {
      small {
        border-bottom: 1px solid ${({ theme }) => getColor(theme, 'light.300')};
      }
    }

    &[aria-selected='false'] {
      small {
        border-bottom: 1px solid ${({ theme }) => getColor(theme, 'primary.500')};
      }
    }
  }
`;
const CalendarHeaderStyled = styled.div.withConfig(defaultConfig) `
  display: flex;
  align-items: center;
  justify-content: space-between;
  box-sizing: border-box;
  padding: 1rem 0;

  &:first-of-type(button) {
    all: unset;
    display: flex;
    align-items: center;
  }
`;
function getIndexChildren(ref, condition, reverse) {
    if (!ref?.current?.children)
        return -1;
    const array = [...Array.from(ref?.current?.children)];
    const index = reverse
        ? array.map((item) => item.attributes[1].nodeValue).lastIndexOf(condition)
        : array.findIndex((item) => item.attributes[1].nodeValue === condition);
    return index;
}
function getIndexChildrenSelect(ref) {
    if (!ref?.current?.children)
        return -1;
    const index = [...Array.from(ref?.current?.children)].findIndex((item) => item.attributes[0].nodeValue === 'true');
    return index;
}
function handleFocus(ref) {
    const children = ref?.current?.children[getIndexChildrenSelect(ref)];
    children?.focus();
}
function handleIsDisabled(date, disabledDays) {
    let isDisabled = false;
    for (let index = 0; index < disabledDays.length; index += 1) {
        if (isWithinInterval(date, disabledDays[index])) {
            isDisabled = true;
        }
    }
    return isDisabled;
}
const useNavigation = (props) => {
    const ref = useRef(null);
    const [currentIndex, setCurrentIndex] = useState(-1);
    useEffect(() => {
        if (currentIndex === -1 && props.visible) {
            setCurrentIndex(getIndexChildrenSelect(ref));
        }
        if (currentIndex >= 0 && props.visible) {
            const item = ref?.current?.children?.[currentIndex];
            item?.focus();
        }
    }, [currentIndex, props.visible]);
    useEffect(() => {
        if (currentIndex === -2 && props.visible) {
            setCurrentIndex(getIndexChildren(ref, props.lastItem, true));
        }
        if (currentIndex === -3 && props.visible) {
            setCurrentIndex(getIndexChildren(ref, props.firstItem));
        }
    }, [props.lastItem, props.firstItem]);
    useEffect(() => {
        if (props.reset) {
            setCurrentIndex(-1);
        }
    }, [props.reset]);
    function checkNextChildren(index) {
        const item = ref?.current?.children?.[currentIndex];
        if (item?.attributes[1].nodeValue === props.lastItem) {
            props.nextChildren?.();
            setCurrentIndex(props.awaitChangeDate ? -3 : getIndexChildren(ref, props.firstItem));
        }
        else {
            setCurrentIndex(currentIndex + index);
        }
    }
    function checkPreviousChildren(index) {
        const item = ref?.current?.children?.[currentIndex];
        if (item?.attributes[1].nodeValue === props.firstItem) {
            props.previousChildren?.();
            setCurrentIndex(props.awaitChangeDate ? -2 : getIndexChildren(ref, props.lastItem));
        }
        else {
            setCurrentIndex(currentIndex - index);
        }
    }
    function handleClickEnter() {
        const item = ref?.current?.children?.[currentIndex];
        item.click();
    }
    const onKeyDown = (event) => {
        switch (event.key) {
            case 'ArrowUp':
                checkPreviousChildren(props.verticalAdvanceValue || 4);
                break;
            case 'ArrowDown':
                checkNextChildren(props.verticalAdvanceValue || 4);
                break;
            case 'ArrowLeft':
                checkPreviousChildren(props.horizontalAdvanceValue || 1);
                break;
            case 'ArrowRight':
                checkNextChildren(props.horizontalAdvanceValue || 1);
                break;
            case 'Escape':
                props.handleClickEscapeKey();
                setCurrentIndex(-1);
                break;
            case 'Enter':
                handleClickEnter();
                setCurrentIndex(-1);
                break;
            default:
                break;
        }
    };
    return [ref, onKeyDown];
};
const Datepicker = forwardRefAs(({ as = 'input', locale = 'en', ariaLabels = locale === 'pt' ? ARIALABELS_PTBR_DEFAULT : ARIALABELS_ENUS_DEFAULT, onChange, onBlur, ...props }, ref) => {
    const inputRef = useRef(null);
    const datepickerRef = useRef(null);
    const { nextMonth, previousMonth, nextYear, previousYear, setNewDate, setNewMonth, setNewYear, isCurrentDate, isSelected, isSameMonth, getCalendar, getNameDaysWeek, getMonthsName, getYears, currentDate, handleChangeTyping, handleLocale, format, } = useDatepicker({
        locale,
        ref: inputRef,
        formatDate: props.formatDate,
        initialDate: props.initialDate,
    });
    const [visibleYears, setVisibleYears] = useState(false);
    const [visibleMonths, setVisibleMonths] = useState(false);
    const [visibleCalendar, setVisibleCalendar] = useState(false);
    const data = getCalendar();
    const weekDays = getNameDaysWeek();
    const months = getMonthsName();
    const years = getYears();
    useOutsideFocus({
        ref: datepickerRef,
        ignoredRef: inputRef,
        callback: () => {
            if (visibleCalendar || inputRef.current === document.activeElement) {
                setVisibleCalendar(false);
                setVisibleYears(false);
                setVisibleMonths(false);
                handleTriggerEvent({ event: 'focusout', ref: inputRef, fnEvent: onBlur });
            }
        },
    });
    useEffect(() => {
        if (ref && typeof ref === 'object') {
            ref.current = inputRef.current;
        }
    }, [ref, inputRef]);
    const [calendarRef, onKeyDownCalendar] = useNavigation({
        awaitChangeDate: true,
        reset: !visibleMonths,
        visible: visibleCalendar,
        firstItem: format(startOfMonth(currentDate), props.formatDate || 'PPP', {
            locale: handleLocale(),
        }),
        lastItem: format(endOfMonth(currentDate), props.formatDate || 'PPP', {
            locale: handleLocale(),
        }),
        nextChildren: nextMonth,
        previousChildren: previousMonth,
        verticalAdvanceValue: 7,
        handleClickEscapeKey: () => {
            setVisibleCalendar(false);
            inputRef?.current?.focus();
        },
    });
    const [monthRef, onKeyDownMonth] = useNavigation({
        awaitChangeDate: false,
        visible: visibleMonths,
        firstItem: months[0].nameFull,
        lastItem: months[11].nameFull,
        handleClickEscapeKey: () => {
            setVisibleMonths(false);
            handleFocus(calendarRef);
        },
    });
    const [yearRef, onKeyDownYear] = useNavigation({
        awaitChangeDate: true,
        visible: visibleYears,
        firstItem: years[0],
        lastItem: years[11],
        nextChildren: nextYear,
        previousChildren: previousYear,
        handleClickEscapeKey: () => {
            setVisibleYears(false);
            handleFocus(calendarRef);
        },
    });
    return (_jsxs(Box, { ref: ref, children: [_jsx(Input, { as: as, ref: inputRef, onKeyDown: (event) => {
                    event.key === 'Enter' &&
                        (setVisibleCalendar(!visibleCalendar), handleFocus(calendarRef));
                    event.key === 'Tab' &&
                        (handleTriggerEvent({ event: 'change', ref: inputRef, fnEvent: onChange }));
                }, onClick: () => {
                    setVisibleCalendar(!visibleCalendar);
                    handleFocus(calendarRef);
                }, onChange: handleChangeTyping, maxLength: 10, ...props }), visibleCalendar && (_jsxs(CalendarStyled, { "aria-activedescendant": format(currentDate, props.formatDate || 'PPP', {
                    locale: handleLocale(),
                }), "aria-expanded": visibleCalendar, visible: visibleCalendar, ref: datepickerRef, children: [_jsxs(CalendarHeaderStyled, { children: [_jsxs(ExpanderCalendarStyled, { children: [_jsx(Text, { appearance: "body2", weight: "medium", sx: { mr: '.5rem' }, "aria-live": "polite", children: format(currentDate, 'MMMM, yyyy', { locale: handleLocale() }) }), _jsx(IconButton, { "aria-label": ariaLabels.showYear, onClick: () => {
                                            setVisibleYears(!visibleYears);
                                            handleFocus(yearRef);
                                        }, type: "button", children: _jsx(ChevronDown, {}) })] }), _jsxs("div", { children: [_jsx(IconButton, { onClick: previousMonth, sx: { mr: '.5rem' }, "aria-label": ariaLabels.previousMonth, type: "button", children: _jsx(ChevronLeft, {}) }), _jsx(IconButton, { onClick: nextMonth, "aria-label": ariaLabels.nextMonth, type: "button", children: _jsx(ChevronRight, {}) })] })] }), _jsx(Dropdown, { ref: monthRef, visible: visibleMonths, onKeyDown: onKeyDownMonth, "aria-expanded": visibleMonths, children: months.map((month) => (_jsx(DropdownItem, { "aria-selected": isSelected({ month: month.number }), "aria-label": month.nameFull, role: "option", tabIndex: -1, "aria-current": isCurrentDate({ month: month.number }), onClick: () => {
                                setNewMonth(month.number);
                                setVisibleMonths(false);
                                handleFocus(calendarRef);
                                handleTriggerEvent({ event: 'change', ref: inputRef, fnEvent: onChange });
                            }, children: _jsx(Text, { appearance: "microtext1", children: month.name }) }, month.name))) }), _jsx(Dropdown, { ref: yearRef, visible: visibleYears, onKeyDown: onKeyDownYear, "aria-expanded": visibleYears, children: years.map((year) => (_jsx(DropdownItem, { "aria-selected": isSelected({ year: parseInt(year, 10) }), "aria-label": year, role: "option", tabIndex: -1, "aria-current": isCurrentDate({ year: parseInt(year, 10) }), onClick: () => {
                                setNewYear(parseInt(year, 10));
                                setVisibleYears(false);
                                setVisibleMonths(true);
                                handleFocus(monthRef);
                                handleTriggerEvent({ event: 'change', ref: inputRef, fnEvent: onChange });
                            }, children: _jsx(Text, { appearance: "microtext1", children: year }) }, year))) }), _jsxs(Flex, { mt: "5", children: [_jsx(WeekStyled, { children: weekDays.map((dayName) => (_jsx(WeekOption, { children: _jsx(Text, { appearance: "microtext1", children: dayName }) }, dayName))) }), _jsx(WeekStyled, { onKeyDown: onKeyDownCalendar, children: data.map((week) => week.map((date, index) => {
                                    if (!isSameMonth(date)) {
                                        return _jsx(EmptyDay, {}, index);
                                    }
                                    return (_jsx(DayStyled, { "aria-selected": isSelected({ day: date }), "aria-label": format(date, props.formatDate || 'PPP', { locale: handleLocale() }), "aria-disabled": props.disabledDays ? handleIsDisabled(date, props.disabledDays) : false, tabIndex: isSelected({ day: date }) ? 0 : -1, role: "option", "aria-current": isCurrentDate({ day: date }), "aria-hidden": !isSameMonth(date), onClick: () => {
                                            const disabled = props.disabledDays ? handleIsDisabled(date, props.disabledDays) : false;
                                            if (!disabled) {
                                                setNewDate(date);
                                                setVisibleCalendar(false);
                                                inputRef?.current?.focus();
                                                handleTriggerEvent({ event: 'change', ref: inputRef, fnEvent: onChange });
                                            }
                                        }, children: _jsx(Text, { appearance: "microtext1", children: format(date, 'dd') }) }, `${date}`));
                                })) })] })] }))] }));
});
export default Datepicker;
//# sourceMappingURL=Datepicker.js.map