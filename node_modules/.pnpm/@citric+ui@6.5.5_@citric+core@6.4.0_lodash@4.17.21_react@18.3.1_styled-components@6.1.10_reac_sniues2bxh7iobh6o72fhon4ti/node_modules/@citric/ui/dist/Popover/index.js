import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Box, Flex, IconBox, Text } from '@citric/core';
import { extendStyle, overwriteStyle } from '@citric/core/dist/component-style.js';
import forwardRefAs from '@citric/core/dist/forward-ref-as.js';
import { css, styled } from '@citric/core/dist/styled.js';
import { getColor, getRadius, getSpacing } from '@citric/core/dist/utils/theme.js';
import { TimesMini } from '@citric/icons';
import { useEffect, useRef, useState } from 'react';
import { getPointerPosition, getPopoverPosition } from './utils.js';
const styles = {
    container: {
        width: 'fit-content',
        position: 'relative',
        height: 'fit-content',
    },
};
const PopoverStyled = styled.div `
  padding: ${({ theme }) => `${getSpacing(theme, 2)}`};
  border-radius: ${({ theme }) => getRadius(theme, 'xs')};
  width: max-content;
  z-index: 100;
  box-sizing: border-box;
  position: relative;
  display: ${({ visible }) => (visible ? 'flex' : 'none')};

  background-color: ${({ theme, colorScheme }) => getColor(theme, colorScheme || 'inverse.500')};

  ${extendStyle('Popover')};

  ${({ nowrap, width }) => nowrap
    ? css `
          max-width: ${width};

          span:last-of-type {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }
        `
    : css `
          max-width: ${width || '250px'};
        `}

  ${({ position = 'top', theme, colorScheme = 'inverse' }) => css `
      position: absolute;
      ${getPopoverPosition(position)}

      &::after {
        content: '';
        position: absolute;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        ${getPointerPosition(position, getColor(theme, colorScheme))}
      }
    `}

  ${overwriteStyle('Popover')};
`;
export const Popover = forwardRefAs(function Popover({ as = 'div', position = 'top', onClose, autoHidden = false, defaultVisible = false, title, containerSx = {}, ...props }, ref) {
    const PopoverRef = useRef(null);
    const popoverId = useRef(`popover-${Math.random().toString(36).substring(2, 9)}`);
    const [visible, setVisible] = useState(defaultVisible);
    useEffect(() => {
        if (ref && typeof ref === 'object') {
            ref.current = PopoverRef.current;
        }
    }, [ref, PopoverRef]);
    useEffect(() => {
        setVisible(defaultVisible);
    }, [defaultVisible]);
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (PopoverRef.current && !PopoverRef.current.contains(event.target)) {
                setVisible(false);
                if (onClose)
                    onClose();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [PopoverRef, onClose]);
    const handleIconBoxClick = () => {
        setVisible(false);
        if (onClose)
            onClose();
    };
    const handleKeyDown = (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            toggleVisibility();
        }
        if (event.key === 'Escape') {
            event.preventDefault();
            setVisible(false);
        }
    };
    function toggleVisibility() {
        setVisible((oldValue) => !oldValue);
    }
    return (_jsxs(Box, { sx: { ...styles.container, ...containerSx }, children: [_jsx("div", { onKeyDown: handleKeyDown, onClick: toggleVisibility, "aria-controls": popoverId.current, role: "button", tabIndex: 0, children: props.children }), _jsx(PopoverStyled, { id: popoverId.current, as: as, ref: PopoverRef, "aria-expanded": visible, visible: visible, position: position, onBlur: (e) => {
                    if (!PopoverRef.current?.contains(e.relatedTarget)) {
                        setVisible(false);
                    }
                }, ...props, children: _jsxs(Box, { p: 3, children: [_jsxs(Flex, { justifyContent: "space-between", alignItems: "center", children: [_jsx(Text, { colorScheme: "inverse.contrastText", weight: "medium", appearance: "body2", children: title }), !autoHidden && (_jsx(IconBox, { role: "button", colorIcon: "inverse.contrastText", sx: { cursor: 'pointer' }, onClick: handleIconBoxClick, "aria-label": "close popover", children: _jsx(TimesMini, {}) }))] }), _jsx(Flex, { children: props.content })] }) })] }));
});
//# sourceMappingURL=index.js.map