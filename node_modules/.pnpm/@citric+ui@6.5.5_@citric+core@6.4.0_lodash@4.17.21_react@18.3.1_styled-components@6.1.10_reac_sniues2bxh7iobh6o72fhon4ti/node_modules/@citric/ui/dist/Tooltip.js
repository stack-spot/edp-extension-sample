import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Text } from '@citric/core';
import { extendStyle, overwriteStyle } from '@citric/core/dist/component-style.js';
import forwardRefAs from '@citric/core/dist/forward-ref-as.js';
import { css, styled } from '@citric/core/dist/styled.js';
import { defaultConfig } from '@citric/core/dist/utils/config.js';
import { getColor, getSpacing } from '@citric/core/dist/utils/theme.js';
import { isNil } from 'lodash';
import { useEffect, useRef, useState } from 'react';
import { useMouseMove } from './hooks/index.js';
const getTooltipPosition = (position) => {
    const tooltipPosition = {
        top: css `
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
    `,
        bottom: css `
      top: 135%;
      left: 50%;
      transform: translateX(-50%);
    `,
        right: css `
      top: 50%;
      transform: translateY(-50%);
      left: 110%;
    `,
        left: css `
      top: 50%;
      transform: translateY(-50%);
      right: 110%;
    `,
    };
    return position ? tooltipPosition[position] : undefined;
};
const getPointerPosition = (position, color, offset) => {
    const pointerPosition = {
        top: css `
      top: 100%;
      left: 50%;
      margin-left: ${-(offset?.x ?? 0) - 5}px;
      border-top-color: ${color};
    `,
        right: css `
      top: 50%;
      right: 100%;
      margin-top: ${-(offset?.y ?? 0) - 5}px;
      border-right-color: ${color};
    `,
        bottom: css `
      bottom: 100%;
      left: 50%;
      margin-left: ${-(offset?.x ?? 0) - 5}px;;
      border-bottom-color: ${color};
    `,
        left: css `
      top: 50%;
      left: 100%;
      margin-top: ${-(offset?.y ?? 0) - 5}px;
      border-left-color: ${color};
    `,
    };
    return position ? pointerPosition[position] : undefined;
};
const Container = styled.div `
  width: fit-content;
  position: relative;
  height: fit-content;
  cursor: pointer;
`;
const TooltipStyled = styled.div.withConfig(defaultConfig) `
  z-index: 15000;
  pointer-events: none;
  padding: ${({ theme }) => `${getSpacing(theme, 2)} ${getSpacing(theme, 3)}`};
  border-radius: 0.375rem;
  width: max-content;
  box-sizing: border-box;

  display: ${({ hover }) => (hover ? 'block' : 'none')};
  background-color: ${({ theme, colorScheme }) => getColor(theme, colorScheme || 'inverse')};

  ${extendStyle('Tooltip')};

  ${(props) => props?.nowrap
    ? css `
          max-width: ${props?.width};

          span:last-of-type {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }
        `
    : css `
          max-width: ${props?.width || '250px'};
        `}

  ${({ theme, coords, offset, position, colorScheme, float }) => float
    ? css `
          position: fixed;
          left: ${`${coords.x}px`};
          top: ${`${coords.y}px`};
        `
    : css `
          position: absolute;
          ${getTooltipPosition(position)}
          ${!isNil(offset?.y) && `margin-top: ${offset?.y}px;`}
          ${!isNil(offset?.x) && `margin-left: ${offset?.x}px;`}

          &::after {
            content: '';
            position: absolute;
            border-width: 5px;
            border-style: solid;
            border-color: transparent;
            ${getPointerPosition(position, getColor(theme, colorScheme || 'inverse'), offset)}
          }
        `}

  ${overwriteStyle('Tooltip')};
`;
const Tooltip = forwardRefAs(function Tooltip({ as = 'div', position = 'top', keyboardControls = true, tabIndex = 0, ...props }, ref) {
    const tooltipRef = useRef(null);
    const { coords, handleMouseMove } = useMouseMove(tooltipRef);
    const [hover, setHover] = useState(false);
    useEffect(() => {
        if (ref && typeof ref === 'object') {
            ref.current = tooltipRef.current;
        }
    }, [ref, tooltipRef]);
    const handleKeyDown = (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            setHover((oldValue) => !oldValue);
            if (!hover) {
                tooltipRef.current?.focus();
            }
        }
        if (event.key === 'Escape') {
            event.preventDefault();
            setHover(false);
        }
    };
    const tooltipId = useRef(`tooltip-${Math.random().toString(36).substring(2, 9)}`);
    return (_jsxs(Container, { onMouseEnter: () => setHover(true), onFocus: () => setHover(true), onBlur: () => setHover(false), onMouseLeave: () => setHover(false), onMouseMove: handleMouseMove, onKeyDown: keyboardControls ? handleKeyDown : undefined, tabIndex: tabIndex !== 'none' ? tabIndex : undefined, children: [_jsx("div", { "aria-describedby": tooltipId.current, children: props.children }), _jsx(TooltipStyled, { role: "tooltip", id: tooltipId.current, as: as, ref: tooltipRef, coords: coords, hover: hover, position: position, "aria-hidden": !hover, tabIndex: -1, "aria-live": "polite", ...props, children: typeof props.text === 'string' ? (_jsx(Text, { appearance: "microtext1", colorScheme: props.colorScheme ? `${props.colorScheme}.contrastText` : 'inverse.contrastText', children: props.text })) : props.text })] }));
});
export default Tooltip;
//# sourceMappingURL=Tooltip.js.map