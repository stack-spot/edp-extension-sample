import { Box, Flex, IconBox, Text } from '@citric/core'
import { extendStyle, overwriteStyle, SxProp } from '@citric/core/dist/component-style'
import forwardRefAs, { AsProp } from '@citric/core/dist/forward-ref-as'
import { css, styled } from '@citric/core/dist/styled'
import { OneOfColorSchemesWithVariants } from '@citric/core/dist/theme-types'
import { getColor, getRadius, getSpacing } from '@citric/core/dist/utils/theme'
import { TimesMini } from '@citric/icons'
import { KeyboardEvent, ReactNode, useEffect, useRef, useState } from 'react'
import { getPointerPosition, getPopoverPosition } from './utils'

type PositionProps = 'left' | 'right' | 'top' | 'bottom'

export interface PopoverProps {
  defaultVisible?: boolean,
  onClose?: () => void,
  children: React.ReactNode,
  content: ReactNode,
  as?: AsProp,
  sx?: SxProp,
  position?: PositionProps,
  title?: string,
  nowrap?: boolean,
  width?: string,
  colorScheme?: OneOfColorSchemesWithVariants,
  autoHidden?: boolean,
  containerSx?: SxProp,
}

const styles = {
  container: {
    width: 'fit-content',
    position: 'relative',
    height: 'fit-content',
  } as SxProp,
}

const PopoverStyled = styled.div<PopoverProps & { visible: boolean }>`
  padding: ${({ theme }) => `${getSpacing(theme, 2)}`};
  border-radius: ${({ theme }) => getRadius(theme, 'xs')};
  width: max-content;
  z-index: 100;
  box-sizing: border-box;
  position: relative;
  display: ${({ visible }) => (visible ? 'flex' : 'none')};

  background-color: ${({ theme, colorScheme }) => getColor(theme, colorScheme || 'inverse.500')};

  ${extendStyle('Popover')};

  ${({ nowrap, width }) =>
    nowrap
      ? css`
          max-width: ${width};

          span:last-of-type {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }
        `
      : css`
          max-width: ${width || '250px'};
        `}

  ${({ position = 'top', theme, colorScheme = 'inverse' }) =>
    css`
      position: absolute;
      ${getPopoverPosition(position)}

      &::after {
        content: '';
        position: absolute;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        ${getPointerPosition(position, getColor(theme, colorScheme))}
      }
    `}

  ${overwriteStyle('Popover')};
`

export const Popover = forwardRefAs<PopoverProps, 'div'>(function Popover(
  { as = 'div', position = 'top', onClose, autoHidden = false, defaultVisible = false, title, containerSx = {}, ...props },
  ref,
) {
  const PopoverRef = useRef<HTMLDivElement>(null)
  const popoverId = useRef(`popover-${Math.random().toString(36).substring(2, 9)}`)
  const [visible, setVisible] = useState(defaultVisible)

  useEffect(() => {
    if (ref && typeof ref === 'object') {
      ref.current = PopoverRef.current
    }
  }, [ref, PopoverRef])

  useEffect(() => {
    setVisible(defaultVisible)
  }, [defaultVisible])

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (PopoverRef.current && !PopoverRef.current.contains(event.target as Node)) {
        setVisible(false)
        if (onClose) onClose()
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [PopoverRef, onClose])

  const handleIconBoxClick = () => {
    setVisible(false)
    if (onClose) onClose()
  }

  const handleKeyDown = (event: KeyboardEvent) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault()
      toggleVisibility()
    }

    if (event.key === 'Escape') {
      event.preventDefault()
      setVisible(false)
    }
  }

  function toggleVisibility() {
    setVisible((oldValue) => !oldValue)
  }

  return (
    <Box sx={{ ...styles.container, ...containerSx }}>
      <div
        onKeyDown={handleKeyDown}
        onClick={toggleVisibility}
        aria-controls={popoverId.current}
        role="button"
        tabIndex={0}>
        {props.children}
      </div>

      <PopoverStyled
        id={popoverId.current}
        as={as}
        ref={PopoverRef}
        aria-expanded={visible}
        visible={visible}
        position={position}
        onBlur={(e: React.FocusEvent) => {
          if (!PopoverRef.current?.contains(e.relatedTarget as Node)) {
            setVisible(false)
          }
        }}
        {...props}
      >
        <Box p={3}>
          <Flex justifyContent="space-between" alignItems="center">
            <Text colorScheme="inverse.contrastText" weight="medium" appearance="body2">{title}</Text>
            {!autoHidden && (
              <IconBox
                role="button"
                colorIcon="inverse.contrastText"
                sx={{ cursor: 'pointer' }}
                onClick={handleIconBoxClick}
                aria-label="close popover"
              >
                <TimesMini />
              </IconBox>
            )}
          </Flex>
          <Flex>{props.content}</Flex>
        </Box>
      </PopoverStyled>
    </Box>
  )
})
