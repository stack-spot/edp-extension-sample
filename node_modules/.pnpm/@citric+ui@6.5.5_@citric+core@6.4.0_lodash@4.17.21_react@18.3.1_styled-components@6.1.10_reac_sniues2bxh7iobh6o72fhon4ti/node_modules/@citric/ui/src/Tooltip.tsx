import { Text } from '@citric/core'
import { extendStyle, overwriteStyle, SxProp } from '@citric/core/dist/component-style'
import forwardRefAs, { AsProp } from '@citric/core/dist/forward-ref-as'
import { css, styled } from '@citric/core/dist/styled'
import { OneOfColorSchemes } from '@citric/core/dist/theme-types'
import { defaultConfig } from '@citric/core/dist/utils/config'
import { getColor, getSpacing } from '@citric/core/dist/utils/theme'
import { isNil } from 'lodash'
import { KeyboardEvent, useEffect, useRef, useState } from 'react'
import { useMouseMove } from './hooks'

type PositionProps = 'left' | 'right' | 'top' | 'bottom'
type CoordsProps = { x: number, y: number }
export interface TooltipProps {
  children: React.ReactNode,
  text: React.ReactNode,
  as?: AsProp,
  sx?: SxProp,
  position?: PositionProps,
  float?: boolean,
  nowrap?: boolean,
  width?: string,
  colorScheme?: OneOfColorSchemes,
  offset?: Partial<CoordsProps>,
  /**
   * Determines if keyboard controls are enabled.
   * When enabled, allows interactions using the keyboard, such as pressing "Enter" or "Space" to toggle the state.
   * 
   * @default true
   */
  keyboardControls?: boolean,
  /**
   * Defines the tab order of the element.
   * When set to `0`, the element is focusable and participates in sequential keyboard navigation.
   * When set to `'none'`, the element is not focusable via keyboard navigation.
   *
   * @default 0
   */
  tabIndex?: 'none' | number,
}

const getTooltipPosition = (position?: PositionProps) => {
  const tooltipPosition = {
    top: css`
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
    `,
    bottom: css`
      top: 135%;
      left: 50%;
      transform: translateX(-50%);
    `,
    right: css`
      top: 50%;
      transform: translateY(-50%);
      left: 110%;
    `,
    left: css`
      top: 50%;
      transform: translateY(-50%);
      right: 110%;
    `,
  }

  return position ? tooltipPosition[position] : undefined
}

const getPointerPosition = (position?: PositionProps, color?: string, offset?: Partial<CoordsProps>) => {
  const pointerPosition = {
    top: css`
      top: 100%;
      left: 50%;
      margin-left: ${-(offset?.x ?? 0) - 5}px;
      border-top-color: ${color};
    `,
    right: css`
      top: 50%;
      right: 100%;
      margin-top: ${-(offset?.y ?? 0) - 5}px;
      border-right-color: ${color};
    `,
    bottom: css`
      bottom: 100%;
      left: 50%;
      margin-left: ${-(offset?.x ?? 0) - 5}px;;
      border-bottom-color: ${color};
    `,
    left: css`
      top: 50%;
      left: 100%;
      margin-top: ${-(offset?.y ?? 0) - 5}px;
      border-left-color: ${color};
    `,
  }

  return position ? pointerPosition[position] : undefined
}

const Container = styled.div`
  width: fit-content;
  position: relative;
  height: fit-content;
  cursor: pointer;
`

const TooltipStyled = styled.div.withConfig(defaultConfig) <TooltipProps & { coords: CoordsProps, hover: boolean }>`
  z-index: 15000;
  pointer-events: none;
  padding: ${({ theme }) => `${getSpacing(theme, 2)} ${getSpacing(theme, 3)}`};
  border-radius: 0.375rem;
  width: max-content;
  box-sizing: border-box;

  display: ${({ hover }: { hover: boolean }) => (hover ? 'block' : 'none')};
  background-color: ${({ theme, colorScheme }) => getColor(theme, colorScheme || 'inverse')};

  ${extendStyle('Tooltip')};

  ${(props: TooltipProps) =>
    props?.nowrap
      ? css`
          max-width: ${props?.width};

          span:last-of-type {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }
        `
      : css`
          max-width: ${props?.width || '250px'};
        `}

  ${({ theme, coords, offset, position, colorScheme, float }) =>
    float
      ? css`
          position: fixed;
          left: ${`${coords.x}px`};
          top: ${`${coords.y}px`};
        `
      : css`
          position: absolute;
          ${getTooltipPosition(position)}
          ${!isNil(offset?.y) && `margin-top: ${offset?.y}px;`}
          ${!isNil(offset?.x) && `margin-left: ${offset?.x}px;`}

          &::after {
            content: '';
            position: absolute;
            border-width: 5px;
            border-style: solid;
            border-color: transparent;
            ${getPointerPosition(position, getColor(theme, colorScheme || 'inverse'), offset)}
          }
        `}

  ${overwriteStyle('Tooltip')};
`

const Tooltip = forwardRefAs<TooltipProps, 'div'>(function Tooltip(
  { as = 'div', position = 'top', keyboardControls = true, tabIndex = 0, ...props },
  ref,
) {
  const tooltipRef = useRef<HTMLDivElement>(null)
  const { coords, handleMouseMove } = useMouseMove(tooltipRef)
  const [hover, setHover] = useState(false)

  useEffect(() => {
    if (ref && typeof ref === 'object') {
      ref.current = tooltipRef.current
    }
  }, [ref, tooltipRef])

  const handleKeyDown = (event: KeyboardEvent) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault()
      setHover((oldValue) => !oldValue)

      if (!hover) {
        tooltipRef.current?.focus()
      }
    }

    if (event.key === 'Escape') {
      event.preventDefault()
      setHover(false)
    }
  }

  const tooltipId = useRef(`tooltip-${Math.random().toString(36).substring(2, 9)}`)

  return (
    <Container
      onMouseEnter={() => setHover(true)}
      onFocus={() => setHover(true)}
      onBlur={() => setHover(false)}
      onMouseLeave={() => setHover(false)}
      onMouseMove={handleMouseMove}
      onKeyDown={keyboardControls ? handleKeyDown : undefined}
      tabIndex={tabIndex !== 'none' ? tabIndex : undefined}
    >
      <div aria-describedby={tooltipId.current}>
        {props.children}
      </div>

      <TooltipStyled
        role="tooltip"
        id={tooltipId.current}
        as={as}
        ref={tooltipRef}
        coords={coords}
        hover={hover}
        position={position}
        aria-hidden={!hover}
        tabIndex={-1}
        aria-live="polite"
        {...props}
      >
        {typeof props.text === 'string' ? (
          <Text
            appearance="microtext1"
            colorScheme={
              props.colorScheme ? `${props.colorScheme}.contrastText` : 'inverse.contrastText'
            }
          >
            {props.text}
          </Text>
        ) : props.text}
      </TooltipStyled>
    </Container>
  )
})

export default Tooltip
