import { Box, Flex, Input, Text } from '@citric/core'
import { SxProp, extendStyle, overwriteStyle } from '@citric/core/dist/component-style'
import forwardRefAs, { AsProp } from '@citric/core/dist/forward-ref-as'
import { css, styled } from '@citric/core/dist/styled'
import { OneOfColorSchemes } from '@citric/core/dist/theme-types'
import { defaultConfig } from '@citric/core/dist/utils/config'
import { getColor, getRadius } from '@citric/core/dist/utils/theme'
import { ChevronDown, ChevronLeft, ChevronRight } from '@citric/icons'
import { endOfMonth, isWithinInterval, startOfMonth } from 'date-fns'
import React, { useEffect, useRef, useState } from 'react'
import IconButton from './IconButton'
import useDatepicker from './hooks/useDatepicker'
import useOutsideFocus from './hooks/useOutsideFocus'

interface HandleTriggerEventProps {
  event: 'change' | 'focusout',
  ref: React.MutableRefObject<HTMLInputElement | null>,
  fnEvent?: (event: any) => void,
}

function handleTriggerEvent(props: HandleTriggerEventProps) {
  props.fnEvent && props.ref?.current?.addEventListener(props.event, props.fnEvent)
  setTimeout(() => {
    props.ref?.current?.dispatchEvent(new Event(props.event))
    props.fnEvent && props.ref?.current?.removeEventListener(props.event, props.fnEvent)
  }, 0)
}


type AriaLabels = {
  showYear?: string,
  previousMonth?: string,
  nextMonth?: string,
}

type ReturnUseNavigationProps = [
  ref: React.MutableRefObject<HTMLUListElement | null>,
  onKeyDown: React.KeyboardEventHandler<HTMLUListElement>
]

type Interval = { start: Date, end: Date }[]

export interface DatepickerProps {
  initialDate?: Date,
  locale?: 'pt' | 'en',
  formatDate?: string,
  as?: AsProp,
  sx?: SxProp,
  colorScheme?: OneOfColorSchemes,
  ariaLabels?: AriaLabels,
  onChange?: React.ChangeEventHandler<HTMLInputElement>,
  onBlur?: React.FocusEventHandler<HTMLInputElement>,
  disabledDays?: Interval,
  readOnly?: boolean,
}

interface UseNavigationProps {
  firstItem: string,
  lastItem: string,
  visible: boolean,
  awaitChangeDate: boolean,
  reset?: boolean,
  nextChildren?: () => void,
  previousChildren?: () => void,
  verticalAdvanceValue?: number,
  horizontalAdvanceValue?: number,
  handleClickEscapeKey: () => void,
}

const ARIALABELS_PTBR_DEFAULT = {
  showYear: 'abrir lista de anos',
  previousMonth: 'mês anterior',
  nextMonth: 'próximo mês',
}

const ARIALABELS_ENUS_DEFAULT = {
  showYear: 'open years list',
  previousMonth: 'previous month',
  nextMonth: 'next month',
}

const CalendarStyled = styled.div.withConfig(defaultConfig) <{ visible: boolean }>`
  position: absolute;
  margin-top: 0.3rem;
  z-index: 15000;
  box-sizing: border-box;
  width: 17.5rem;
  padding: 1rem;
  box-shadow:  2px 2px 16px 0px ${({ theme }) => getColor(theme, 'primary.contrastText')};
  border-radius: ${({ theme }) => getRadius(theme, 'xs')};
  ${extendStyle('Datepicker')};

  display: ${({ visible }: { visible?: boolean }) => (visible ? 'block' : 'none')};
  background-color: ${({ theme }) => getColor(theme, 'light.300')};

  ${overwriteStyle('Datepicker')};
`

const WeekStyled = styled.ul.withConfig(defaultConfig)`
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  padding: 0;
  margin: 0;
`

const WeekOption = styled.li.withConfig(defaultConfig)`
  width: 2rem;
  height: 1rem;
  display: flex;
  box-sizing: border-box;
  justify-content: center;
  align-items: center;
  margin: 0.125rem;
`

const EmptyDay = styled.li.withConfig(defaultConfig)`
  width: 2rem;
  height: 2rem;
  display: flex;
  box-sizing: border-box;
  justify-content: center;
  align-items: center;
  border-radius: 50%;
  margin: 0.125rem;
`

const DayStyled = styled.li.withConfig(defaultConfig)`
  width: 2rem;
  height: 2rem;
  display: flex;
  box-sizing: border-box;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  border-radius: 50%;
  margin: 0.125rem;

  background: ${({ theme }) => getColor(theme, 'light.500')};

  /* :focus, */
  &:hover {
    outline: none;
    background: ${({ theme }) => getColor(theme, 'primary.300')};
  }

  &[aria-selected='true'] {
    ${({ theme }) =>
    css`
        background: ${getColor(theme, 'primary.500')};
        color: ${getColor(theme, 'light.300')};
      `}
  }

  &[aria-hidden='true'],
  &[aria-disabled='true'] {
    opacity: 0;
    cursor: none;
  }

  &[aria-disabled='true'] {
    cursor: not-allowed;
  }

  &[aria-current='true'] {
    &[aria-selected='true'] {
      small {
        border-bottom: 1px solid ${({ theme }) => getColor(theme, 'light.300')};
      }
    }

    &[aria-selected='false'] {
      small {
        border-bottom: 1px solid ${({ theme }) => getColor(theme, 'primary.500')};
      }
    }
  }
`

const ExpanderCalendarStyled = styled.div.withConfig(defaultConfig)`
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
`

const Dropdown = styled.ul.withConfig(defaultConfig) <{ visible: boolean }>`
  display: ${({ visible }: { visible: boolean }) => (visible ? 'grid' : 'none')};
  grid-template-columns: repeat(4, 1fr);
  box-sizing: border-box;
  padding: 0;
  margin: 0;
  mb: 1rem;
`

const DropdownItem = styled.li.withConfig(defaultConfig)`
  width: 3.5rem;
  height: 2rem;
  display: flex;
  box-sizing: border-box;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  border-radius: 1rem;
  margin: 0.25rem 0;

  background: ${({ theme }) => getColor(theme, 'light.400')};

  &:focus,
  &:hover {
    outline: none;
    background: ${({ theme }) => getColor(theme, 'primary.300')};
  }

  &[aria-selected='true'] {
    ${({ theme }) =>
    css`
        background: ${getColor(theme, 'primary.500')};
        color: ${getColor(theme, 'light.300')};
      `}
  }

  &[aria-current='true'] {
    &[aria-selected='true'] {
      small {
        border-bottom: 1px solid ${({ theme }) => getColor(theme, 'light.300')};
      }
    }

    &[aria-selected='false'] {
      small {
        border-bottom: 1px solid ${({ theme }) => getColor(theme, 'primary.500')};
      }
    }
  }
`

const CalendarHeaderStyled = styled.div.withConfig(defaultConfig)`
  display: flex;
  align-items: center;
  justify-content: space-between;
  box-sizing: border-box;
  padding: 1rem 0;

  &:first-of-type(button) {
    all: unset;
    display: flex;
    align-items: center;
  }
`

function getIndexChildren(
  ref: React.MutableRefObject<HTMLUListElement | null>,
  condition: string,
  reverse?: boolean,
) {
  if (!ref?.current?.children) return -1

  const array = [...Array.from(ref?.current?.children)]
  const index = reverse
    ? array.map((item) => item.attributes[1].nodeValue).lastIndexOf(condition)
    : array.findIndex((item) => item.attributes[1].nodeValue === condition)

  return index
}

function getIndexChildrenSelect(ref: React.MutableRefObject<HTMLUListElement | null>) {
  if (!ref?.current?.children) return -1

  const index = [...Array.from(ref?.current?.children)].findIndex(
    (item) => item.attributes[0].nodeValue === 'true',
  )

  return index
}

function handleFocus(ref: React.MutableRefObject<HTMLUListElement | null>) {
  const children = ref?.current?.children[getIndexChildrenSelect(ref)] as HTMLElement

  children?.focus()
}

function handleIsDisabled(date: Date, disabledDays: Interval) {
  let isDisabled = false

  for (let index = 0; index < disabledDays.length; index += 1) {
    if (isWithinInterval(date, disabledDays[index])) {
      isDisabled = true
    }
  }

  return isDisabled
}

const useNavigation = (props: UseNavigationProps): ReturnUseNavigationProps => {
  const ref = useRef<HTMLUListElement>(null)
  const [currentIndex, setCurrentIndex] = useState<number>(-1)

  useEffect(() => {
    if (currentIndex === -1 && props.visible) {
      setCurrentIndex(getIndexChildrenSelect(ref))
    }

    if (currentIndex >= 0 && props.visible) {
      const item = ref?.current?.children?.[currentIndex] as HTMLElement

      item?.focus()
    }
  }, [currentIndex, props.visible])

  useEffect(() => {
    if (currentIndex === -2 && props.visible) {
      setCurrentIndex(getIndexChildren(ref, props.lastItem, true))
    }

    if (currentIndex === -3 && props.visible) {
      setCurrentIndex(getIndexChildren(ref, props.firstItem))
    }

  }, [props.lastItem, props.firstItem])

  useEffect(() => {
    if (props.reset) {
      setCurrentIndex(-1)
    }
  }, [props.reset])

  function checkNextChildren(index: number) {
    const item = ref?.current?.children?.[currentIndex] as HTMLElement

    if (item?.attributes[1].nodeValue === props.lastItem) {
      props.nextChildren?.()
      setCurrentIndex(props.awaitChangeDate ? -3 : getIndexChildren(ref, props.firstItem))
    } else {
      setCurrentIndex(currentIndex + index)
    }
  }

  function checkPreviousChildren(index: number) {
    const item = ref?.current?.children?.[currentIndex] as HTMLElement

    if (item?.attributes[1].nodeValue === props.firstItem) {
      props.previousChildren?.()
      setCurrentIndex(props.awaitChangeDate ? -2 : getIndexChildren(ref, props.lastItem))
    } else {
      setCurrentIndex(currentIndex - index)
    }
  }

  function handleClickEnter() {
    const item = ref?.current?.children?.[currentIndex] as HTMLElement

    item.click()
  }

  const onKeyDown = (event: { key: string }) => {
    switch (event.key) {
      case 'ArrowUp':
        checkPreviousChildren(props.verticalAdvanceValue || 4)
        break
      case 'ArrowDown':
        checkNextChildren(props.verticalAdvanceValue || 4)
        break
      case 'ArrowLeft':
        checkPreviousChildren(props.horizontalAdvanceValue || 1)
        break
      case 'ArrowRight':
        checkNextChildren(props.horizontalAdvanceValue || 1)
        break
      case 'Escape':
        props.handleClickEscapeKey()
        setCurrentIndex(-1)
        break
      case 'Enter':
        handleClickEnter()
        setCurrentIndex(-1)
        break
      default:
        break
    }
  }

  return [ref, onKeyDown]
}

interface DatepickerPropsForwardRef extends React.FC<DatepickerProps> {
  <T>(props: DatepickerProps & T): ReturnType<React.FC<DatepickerProps & T>>,
}


const Datepicker = forwardRefAs<DatepickerProps, 'input'>(
  (
    {
      as = 'input',
      locale = 'en',
      ariaLabels = locale === 'pt' ? ARIALABELS_PTBR_DEFAULT : ARIALABELS_ENUS_DEFAULT,
      onChange,
      onBlur,
      ...props
    },
    ref,
  ) => {
    const inputRef = useRef<HTMLInputElement>(null)
    const datepickerRef = useRef<HTMLDivElement>(null)

    const {
      nextMonth,
      previousMonth,

      nextYear,
      previousYear,

      setNewDate,
      setNewMonth,
      setNewYear,

      isCurrentDate,
      isSelected,
      isSameMonth,

      getCalendar,
      getNameDaysWeek,
      getMonthsName,
      getYears,

      currentDate,

      handleChangeTyping,
      handleLocale,
      format,
    } = useDatepicker({
      locale,
      ref: inputRef,
      formatDate: props.formatDate,
      initialDate: props.initialDate,
    })

    const [visibleYears, setVisibleYears] = useState(false)
    const [visibleMonths, setVisibleMonths] = useState(false)
    const [visibleCalendar, setVisibleCalendar] = useState(false)

    const data = getCalendar()
    const weekDays = getNameDaysWeek()
    const months = getMonthsName()
    const years = getYears()

    useOutsideFocus({
      ref: datepickerRef,
      ignoredRef: inputRef,
      callback: () => {
        if (visibleCalendar || inputRef.current === document.activeElement) {
          setVisibleCalendar(false)
          setVisibleYears(false)
          setVisibleMonths(false)
          handleTriggerEvent({ event: 'focusout', ref: inputRef, fnEvent: onBlur })
        }
      },
    })

    useEffect(() => {
      if (ref && typeof ref === 'object') {
        ref.current = inputRef.current
      }
    }, [ref, inputRef])

    const [calendarRef, onKeyDownCalendar] = useNavigation({
      awaitChangeDate: true,
      reset: !visibleMonths,
      visible: visibleCalendar,
      firstItem: format(startOfMonth(currentDate), props.formatDate || 'PPP', {
        locale: handleLocale(),
      }),
      lastItem: format(endOfMonth(currentDate), props.formatDate || 'PPP', {
        locale: handleLocale(),
      }),
      nextChildren: nextMonth,
      previousChildren: previousMonth,
      verticalAdvanceValue: 7,
      handleClickEscapeKey: () => {
        setVisibleCalendar(false)
        inputRef?.current?.focus()
      },
    })

    const [monthRef, onKeyDownMonth] = useNavigation({
      awaitChangeDate: false,
      visible: visibleMonths,
      firstItem: months[0].nameFull,
      lastItem: months[11].nameFull,
      handleClickEscapeKey: () => {
        setVisibleMonths(false)
        handleFocus(calendarRef)
      },
    })

    const [yearRef, onKeyDownYear] = useNavigation({
      awaitChangeDate: true,
      visible: visibleYears,
      firstItem: years[0],
      lastItem: years[11],
      nextChildren: nextYear,
      previousChildren: previousYear,
      handleClickEscapeKey: () => {
        setVisibleYears(false)
        handleFocus(calendarRef)
      },
    })

    return (
      <Box ref={ref}>
        <Input
          as={as}
          ref={inputRef}
          onKeyDown={(event: KeyboardEvent) => {
            event.key === 'Enter' &&
              (setVisibleCalendar(!visibleCalendar), handleFocus(calendarRef))
            event.key === 'Tab' &&
              (handleTriggerEvent({ event: 'change', ref: inputRef, fnEvent: onChange }))
          }}
          onClick={() => {
            setVisibleCalendar(!visibleCalendar)
            handleFocus(calendarRef)
          }}
          onChange={handleChangeTyping}
          maxLength={10}
          {...props}
        />

        {visibleCalendar && (
          <CalendarStyled
            aria-activedescendant={format(currentDate, props.formatDate || 'PPP', {
              locale: handleLocale(),
            })}
            aria-expanded={visibleCalendar}
            visible={visibleCalendar}
            ref={datepickerRef}
          >
            <CalendarHeaderStyled>
              <ExpanderCalendarStyled>
                <Text appearance="body2" weight="medium" sx={{ mr: '.5rem' }} aria-live="polite">
                  {format(currentDate, 'MMMM, yyyy', { locale: handleLocale() })}
                </Text>
                <IconButton
                  aria-label={ariaLabels.showYear}
                  onClick={() => {
                    setVisibleYears(!visibleYears)
                    handleFocus(yearRef)
                  }}
                  type="button"
                >
                  <ChevronDown />
                </IconButton>
              </ExpanderCalendarStyled>

              <div>
                <IconButton
                  onClick={previousMonth}
                  sx={{ mr: '.5rem' }}
                  aria-label={ariaLabels.previousMonth}
                  type="button"
                >
                  <ChevronLeft />
                </IconButton>
                <IconButton onClick={nextMonth} aria-label={ariaLabels.nextMonth} type="button">
                  <ChevronRight />
                </IconButton>
              </div>
            </CalendarHeaderStyled>

            <Dropdown
              ref={monthRef}
              visible={visibleMonths}
              onKeyDown={onKeyDownMonth}
              aria-expanded={visibleMonths}
            >
              {months.map((month: any) => (
                <DropdownItem
                  aria-selected={isSelected({ month: month.number })}
                  aria-label={month.nameFull}
                  role="option"
                  tabIndex={-1}
                  key={month.name}
                  aria-current={isCurrentDate({ month: month.number })}
                  onClick={() => {
                    setNewMonth(month.number)
                    setVisibleMonths(false)
                    handleFocus(calendarRef)
                    handleTriggerEvent({ event: 'change', ref: inputRef, fnEvent: onChange })
                  }}
                >
                  <Text appearance="microtext1">{month.name}</Text>
                </DropdownItem>
              ))}
            </Dropdown>

            <Dropdown
              ref={yearRef}
              visible={visibleYears}
              onKeyDown={onKeyDownYear}
              aria-expanded={visibleYears}
            >
              {years.map((year: any) => (
                <DropdownItem
                  aria-selected={isSelected({ year: parseInt(year, 10) })}
                  aria-label={year}
                  key={year}
                  role="option"
                  tabIndex={-1}
                  aria-current={isCurrentDate({ year: parseInt(year, 10) })}
                  onClick={() => {
                    setNewYear(parseInt(year, 10))
                    setVisibleYears(false)
                    setVisibleMonths(true)
                    handleFocus(monthRef)
                    handleTriggerEvent({ event: 'change', ref: inputRef, fnEvent: onChange })
                  }}
                >
                  <Text appearance="microtext1">{year}</Text>
                </DropdownItem>
              ))}
            </Dropdown>
            <Flex mt="5">
              <WeekStyled>
                {weekDays.map((dayName: any) => (
                  <WeekOption key={dayName}>
                    <Text appearance="microtext1">{dayName}</Text>
                  </WeekOption>
                ))}
              </WeekStyled>

              <WeekStyled onKeyDown={onKeyDownCalendar}>
                {data.map((week: Array<Date>) =>
                  week.map((date: Date, index) => {
                    if (!isSameMonth(date)) {
                      return <EmptyDay key={index} />
                    }

                    return (
                      <DayStyled
                        aria-selected={isSelected({ day: date })}
                        aria-label={format(date, props.formatDate || 'PPP', { locale: handleLocale() })}
                        aria-disabled={
                          props.disabledDays ? handleIsDisabled(date, props.disabledDays) : false
                        }
                        tabIndex={isSelected({ day: date }) ? 0 : -1}
                        role="option"
                        key={`${date}`}
                        aria-current={isCurrentDate({ day: date })}
                        aria-hidden={!isSameMonth(date)}
                        onClick={() => {
                          const disabled = props.disabledDays ? handleIsDisabled(date, props.disabledDays) : false
                          if (!disabled) {
                            setNewDate(date)
                            setVisibleCalendar(false)
                            inputRef?.current?.focus()
                            handleTriggerEvent({ event: 'change', ref: inputRef, fnEvent: onChange })
                          }
                        }}
                      >
                        <Text appearance="microtext1">{format(date, 'dd')}</Text>
                      </DayStyled>
                    )
                  },
                  ),
                )}
              </WeekStyled>
            </Flex>
          </CalendarStyled>
        )}
      </Box>
    )
  },
) as DatepickerPropsForwardRef

export default Datepicker
