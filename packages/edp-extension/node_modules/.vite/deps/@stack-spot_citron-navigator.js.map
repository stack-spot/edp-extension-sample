{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/src/Route.ts", "../../../../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/src/errors.ts", "../../../../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/src/CitronNavigator.ts", "../../../../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/src/Link.tsx", "../../../../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/src/use-async-view.tsx", "../../../../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/src/use-navigation-list.ts"],
  "sourcesContent": ["import { CitronNavigator } from './CitronNavigator'\nimport { splitPath } from './utils'\n\ntype ParamType = 'string' | 'number' | 'boolean' | 'string[]' | 'number[]' | 'boolean[]' | 'object'\n\ninterface LinkOptions {\n  /**\n   * Whether or not to merge the provided search parameters with the current search parameters.\n   * @default false\n   */\n  mergeSearchParameters?: boolean,\n}\n\ninterface GoOptions {\n  /**\n   * Whether or not to merge the provided search parameters with the current search parameters.\n   * @default true\n   */\n  mergeSearchParameters?: boolean,\n  /**\n   * True to navigate with `history.replaceState`. False to navigate with `history.pushState`.\n   * \n   * When `replace` is undefined, this option will be calculated:\n   * - true if the outgoing route is the same as the current route, i.e. if the only change is to the parameters of the route and not to the\n   * route itself.\n   * - false otherwise.\n   */\n  replace?: boolean,\n  /**\n   * If true, prevents any navigation event from firing. i.e. the URL will change, but nothing else will.\n   * \n   * You can fire a navigation event manually by calling `CitronNavigator.instance?.updateRoute()`.\n   * @default false\n   */\n  preventDefault?: boolean,\n}\n\n/**\n * Any Route of the Citron Navigator.\n */\nexport type AnyRoute = Route<any, any, any>\n\n/**\n * A Route of the Citron Navigator. The root route, i.e. the route that has no parent will be the Navigation Tree.\n * \n * Routes are equal if they have the same key. To test route equality, use `routeA.equals(routeB)`, do not use same-value-zero equality\n * (`routeA === routeB`).\n * \n * Every property of this class not prefixed with \"$\" is a child route.\n */\nexport abstract class Route<\n  Parent extends Route<any, any> | undefined = Route<any, any>,\n  Params extends Record<string, any> | void = Record<string, any>,\n  RouteKey extends string = string,\n> {\n  /**\n   * A unique key that identifies this route.\n   * \n   * This will be in the format \"a.b.c\", where each name separated by \".\" is the name of a route in the navigation tree, \"a\" is the root\n   * node's name and \"c\" is this route's name.\n   */\n  $key: string\n  /**\n   * The path to this route. Variables are represented as `{variable_name}`.\n   */\n  $path: string\n  /**\n   * The Route that is the parent of this route in the navigation tree.\n   */\n  $parent: Parent\n  /**\n   * The parameters this route can have and their types.\n   */\n  $paramMetadata: Record<string, ParamType>\n\n  constructor(key: string, path: string, parent: Parent, paramMetadata: Record<string, ParamType>) {\n    this.$key = key\n    this.$path = path\n    this.$parent = parent\n    this.$paramMetadata = paramMetadata\n  }\n\n  /**\n   * Navigates to this route using the browser's history API. This can be either a page change or just a modification to a route parameter.\n   * \n   * To control whether to use history.pushState or history.replaceState, pass \"replace\" in the options parameter.\n   * \n   * By default, whenever the current route is the same as the route we're navigating to, `history.replaceState` is used. Otherwise,\n   * `history.pushState` is.\n   * \n   * The parameters provided are merged with the parameters of the current URL. To avoid merging unwanted search parameters, pass the option\n   * `mergeSearchParameters: false`.\n   * @param params the parameters for the route.\n   * @param options optional. The options for this navigation.\n   */\n  $go(params: Record<string, never> extends Params ? void | Params : Params, options?: GoOptions) {\n    const replace = options?.replace ?? this.$isActive()\n    const operation = replace ? 'replaceState' : 'pushState'\n    history[operation]({}, '', this.$link(params, { mergeSearchParameters: options?.mergeSearchParameters ?? true }))\n    if (!options?.preventDefault) CitronNavigator.instance?.updateRoute()\n  }\n\n  private setSearchParam(searchParams: URLSearchParams, key: string, value: any) {\n    if (value === undefined || value === null || value === '') return\n    const type = this.$paramMetadata[key]\n    if (type.endsWith('[]') && Array.isArray(value)) return value.forEach(v => searchParams.append(key, v))\n    searchParams.set(key, type === 'object' ? JSON.stringify(value) : value)\n  }\n\n  /**\n   * Creates a link (relative url) to this route.\n   * \n   * When creating a link, the provided search parameters are not merged with the current search parameters. To allow than to merge, pass\n   * `mergeSearchParameters: true` in the options (2nd parameter).\n   * @param params the parameters for the route.\n   * @param options optional. The options for creating the link.\n   * @returns the relative url to this route.\n   */\n  $link(params: Record<string, never> extends Params ? void | Params : Params, options?: LinkOptions): string {\n    const parameters: Record<string, any> = { ...CitronNavigator.instance?.currentParams, ...params }\n    const urlParams: string[] = []\n    const path = this.$path.replace(/\\/\\*$/, '').replace(/\\{(\\w+)\\}/g, (_, match) => {\n      urlParams.push(match)\n      const type = this.$paramMetadata[match]\n      const value = parameters[match]\n      let serialized = `${value}`\n      if (type.endsWith('[]') && Array.isArray(value)) {\n        serialized = value.map(item => typeof item === 'string' ? item.replace(/-/g, '\\\\-') : item).join('-')\n      }\n      else if (type === 'object') serialized = JSON.stringify(value)\n      return encodeURIComponent(serialized)\n    })\n    const url = new URL(CitronNavigator.instance?.useHash ? location.pathname : path, location.origin)\n    if (CitronNavigator.instance?.useHash) url.hash = `#${path}`\n    const newSearchParams = (options?.mergeSearchParameters ? parameters : params) ?? {}\n    Object.keys(this.$paramMetadata).forEach(\n      key => !urlParams.includes(key) && this.setSearchParam(url.searchParams, key, newSearchParams[key]),\n    )\n    return `${url.pathname}${url.hash}${url.search}`\n  }\n\n  /**\n   * Checks if the key passed as parameter corresponds to this route.\n   * @param key the key to compare.\n   * @returns true if the key is the same as this route's key. False otherwise.\n   */\n  $is(key: RouteKey): boolean {\n    return this.$key === key\n  }\n\n  /**\n   * Checks if the route passed as parameter is equivalent to the this route.\n   * @param route the route to compare.\n   * @returns true if it's  equivalent, false otherwise.\n   */\n  $equals(route: AnyRoute) {\n    return this.$key === route.$key\n  }\n\n  /**\n   * Checks if the key passed as parameter corresponds to this route or a sub-route of this route.\n   * \n   * Attention: this will only check the format of the key. It won't verify if the route actually exists.\n   * \n   * @param key the key to compare.\n   * @returns true if the key is a sub-route (or equal). False otherwise.\n   */\n  $containsSubroute(key: RouteKey): boolean {\n    return this.$key === key || key.startsWith(`${this.$key}.`)\n  }\n\n  /**\n   * Checks if this route corresponds to the key passed as parameter or any sub-route of the key.\n   * \n   * @param key the key to compare.\n   * @returns true if this is a sub-route of the key (or equal). False otherwise.\n   */\n  $isSubrouteOf(key: RouteKey): boolean {\n    return this.$key === key || this.$key.startsWith(`${key}.`)\n  }\n\n  /**\n   * Checks how the path passed as parameter matches this route.\n   * \n   * Attention: this won't verify if the path corresponds to an actual route. It will make a decision only based in the path's format.\n   * \n   * @param path the path to test this route against\n   * @returns\n   * - `no-match` if this route and the path passed as parameter are not related.\n   * - `exact` if the path passed as parameter corresponds to this route; wildcards will always match as exact.\n   * - `subroute` if the path passed as parameter corresponds to a sub-route (descendent) of this route.\n   * - `super-route` if the path passed as parameter corresponds to a super-route (ascendent) of this route.\n   */\n  $match(path: string): 'no-match' | 'exact' | 'subroute' | 'super-route' {\n    const thatPathParts = splitPath(path)\n    const thisPathParts = splitPath(this.$path.replace(/\\/\\*$/, ''))\n    const min = Math.min(thisPathParts.length, thatPathParts.length)\n    for (let i = 0; i < min; i++) {\n      const isUrlParam = !!thisPathParts[i].match(/\\{\\w+\\}/)\n      if (!isUrlParam && thatPathParts[i] !== thisPathParts[i]) return 'no-match'\n    }\n    const isWildcard = this.$path.endsWith('/*')\n    if (!isWildcard && thisPathParts.length < thatPathParts.length) return 'subroute'\n    if (thisPathParts.length > thatPathParts.length) return 'super-route'\n    return 'exact'\n  }\n\n  /**\n   * Checks if this route is currently active.\n   * @returns true if this route is the currently active, false otherwise.\n   */\n  $isActive(): boolean {\n    const path = CitronNavigator.instance?.getPath()\n    return path !== undefined && this.$match(path) === 'exact'\n  }\n\n  /**\n   * Checks if this route or any of its sub-route is currently active.\n   * @returns true if this route or any of its sub-routes is the currently active, false otherwise.\n   */\n  $isSubrouteActive(): boolean {\n    const path = CitronNavigator.instance?.getPath()\n    if (!path) return false\n    const match = this.$match(path)\n    return path !== undefined && (match === 'subroute' || match === 'exact')\n  }\n\n  /**\n   * Returns the branch that starts at the root node and ends in this route.\n   * @returns an array of routes where the first is the root node and the last is this route.\n   */\n  $getBranch() {\n    const branch: AnyRoute[] = [this]\n    while (branch[branch.length - 1].$parent) {\n      branch.push(branch[branch.length - 1].$parent)\n    }\n    return branch.reverse()\n  }\n}\n", "export class NavigationError extends Error {\n  constructor(message: string) {\n    super(`Navigation error: ${message}`)\n  }\n}\n\nexport class NavigationSetupError extends Error {\n  constructor(message: string) {\n    super(`Navigation setup error: ${message}`)\n  }\n}\n", "import { AnyRoute, Route } from './Route'\nimport { NavigationError, NavigationSetupError } from './errors'\nimport { removeElementFromArray, splitPath } from './utils'\n\ntype NotFoundListener = (path: string) => void\ntype RouteChangeListener = (route: Route, params: Record<string, any>) => void\ntype AsyncRouteChangeListener = (route: Route, params: Record<string, any>) => Promise<void> | void\n\n/**\n * Singleton. This is the application's navigator (Citron Navigator).\n * \n * To create a CitronNavigator instance, call `CitronNavigator.create`. If there's not yet an instance, it will create one, otherwise, it\n * will return the existing instance.\n * \n * To access the current instance, use `CitronNavigator.instance`, which will be undefined if no instance has been created yet.\n */\nexport class CitronNavigator {\n  private root: AnyRoute\n  private notFoundListeners: NotFoundListener[] = []\n  private routeChangeListeners: RouteChangeListener[] = []\n  private asyncRouteChangeListeners: AsyncRouteChangeListener[] = []\n  currentRoute: AnyRoute | undefined\n  currentParams: Record<string, any> = {}\n  useHash: boolean\n  static readonly instance: CitronNavigator | undefined\n\n  private constructor(root: AnyRoute, useHash = true) {\n    this.root = root\n    this.useHash = useHash\n    window.addEventListener('popstate', () => this.updateRoute())\n    this.updateRoute()\n  }\n\n  /**\n   * Creates a navigator if none has been created yet. Otherwise, returns the current navigator.\n   * @param root the navigation tree.\n   * @param useHash whether or not to use hash-based urls (domain/#/path). The default is true.\n   * @returns the navigator\n   */\n  static create(root: AnyRoute, useHash = true) {\n    // @ts-ignore: should be read-only for external code only\n    CitronNavigator.instance ??= new CitronNavigator(root, useHash)\n    return CitronNavigator.instance\n  }\n\n  /**\n   * Copies every child route of `source` to `target` if the child route of `source` doesn't exist in `target`.\n   * \n   * If a child of `source` exists in `target`, but it's path includes a wildcard (/*), we recursively copy its children to the same route\n   * in `target`.\n   * @param source the route to have its children copied.\n   * @param target the route to copy the children to.\n   */\n  private copy(source: AnyRoute, target: AnyRoute) {\n    Object.keys(source).forEach((key) => {\n      const k = key as keyof AnyRoute\n      if (!k.startsWith('$') && source[k] instanceof Route) {\n        if (!(k in target)) {\n          source[k].$parent = target\n          target[k] = source[k]\n        } else if (source[k].$path.endsWith('/*')) {\n          this.copy(source[k], target[k])\n        }\n      }\n    })\n  }\n\n  /**\n   * Updates the navigation tree by merging a node with another.\n   * \n   * This is used by modular navigation. A module can load more routes into the tree.\n   * @param route the node to be merged into the tree.\n   * @param keyToReplace the key of the node to be merged.\n   */\n  updateNavigationTree(route: Route<any, any, any>, keyToReplace: string) {\n    let oldRoute: any = this.root\n    const reminderKey = keyToReplace.replace(new RegExp(`^${this.root.$key}\\\\.?`), '')\n    const keyParts = reminderKey.split('.')\n    if (reminderKey) keyParts.forEach(key => oldRoute = oldRoute?.[key])\n    if (!oldRoute) {\n      throw new NavigationSetupError(\n        `Navigation error: cannot update navigation tree at route with key \"${keyToReplace}\" because the key doesn't exist.`,\n      )\n    }\n    if (oldRoute === this.root) {\n      this.root = route\n    } else {\n      route.$parent = oldRoute.$parent\n      oldRoute.$parent[keyParts[keyParts.length - 1]] = route\n    }\n    // validation: check for route clashes\n    const oldPaths = Object.keys(oldRoute).reduce<string[]>((result, key) => {\n      if (key.startsWith('$')) return result\n      const value = oldRoute[key as keyof typeof oldRoute]\n      return !(value instanceof Route) || value.$path.endsWith('/*') ? result : [...result, value.$path]\n    }, [])\n    Object.keys(route).forEach((key) => {\n      const value = route[key as keyof typeof route]\n      if (key.startsWith('$') || !(value instanceof Route)) return\n      if (oldPaths.includes(value.$path)) {\n        throw new NavigationSetupError(\n          `Error while merging modular route with key \"${keyToReplace}\". Path \"${value.$path}\" is already defined in parent. Only paths with wildcard can be replaced.`,\n        )\n      }\n      if (key in oldRoute && oldRoute[key] instanceof Route && !oldRoute[key].$path.endsWith('/*')) {\n        throw new NavigationSetupError(\n          `Error while merging modular route, key \"${keyToReplace}\" is already defined in parent with a non-wildcard path.`,\n        )\n      }\n    })\n    \n    this.copy(oldRoute, route)\n    this.updateRoute()\n  }\n\n  /**\n   * Gets the path of the provided url (considering hash-based paths).\n   * \n   * Examples:\n   * - \"https://www.stackspot.com/pt/ai-assistente\" (useHash = false): \"pt/ai-assistente\".\n   * - \"https://www.stackspot.com/#/pt/ai-assistente\" (useHash = true): \"pt/ai-assistente\".\n   * \n   * @param url the url to extract the path from. The current url (window.location) is used if none is provided. \n   * @returns the path part of the url.\n   */\n  getPath(url: URL = new URL(location.toString())) {\n    return this.useHash ? url.hash.replace(/^\\/?#\\/?/, '').replace(/\\?.*/, '') : url.pathname.replace(/^\\//, '')\n  }\n\n  /**\n   * Updates the current route according to the current URL.\n   */\n  async updateRoute() {\n    const route = this.findRouteByPath(this.root, this.getPath())\n    if (route) await this.handleRouteChange(route)\n    else this.handleNotFound()\n  }\n\n  private childrenOf(route: Record<string, any>): Route[] {\n    return Object.keys(route).reduce<Route[]>((result, key) => {\n      if (!key.startsWith('$')) result.push(route[key])\n      return result\n    }, [])\n  }\n\n  private findRouteByPath(route: Route, path: string, lastMatch?: Route): Route | undefined {\n    switch (route.$match(path)) {\n      case 'exact':\n        return route.$path.endsWith('*')\n          ? this.childrenOf(route).reduce<Route | undefined>(\n            (result, child) => result ?? this.findRouteByPath(child, path, route),\n            undefined,\n          ) ?? route\n          : route\n      case 'subroute':\n        return this.childrenOf(route).reduce<Route | undefined>(\n          (result, child) => result ?? this.findRouteByPath(child, path, lastMatch),\n          undefined,\n        ) ?? (route.$path.endsWith('*') ? route : lastMatch)\n    }\n  }\n\n  private async handleRouteChange(route: Route) {\n    this.currentRoute = route\n    const url = new URL(location.toString())\n    this.currentParams = { ...this.extractQueryParams(url), ...this.extractUrlParams(url) }\n    await Promise.all(this.asyncRouteChangeListeners.map(l => l(route, this.currentParams)))\n    this.routeChangeListeners.forEach(l => l(route, this.currentParams))\n  }\n\n  private handleNotFound() {\n    const path = this.getPath()\n    // eslint-disable-next-line no-console\n    console.error(new NavigationError(`route not registered (${path})`).message)\n    this.notFoundListeners.forEach(l => l(path))\n  }\n\n  private paramTypeError(key: string, value: string, type: string, routeKey: string, interpretingAs: string = 'a raw string') {\n    return new NavigationError(\n      `error while deserializing parameter \"${key}\" of route \"${routeKey}\". The value (\"${value}\") is not a valid ${type}. Citron Navigator will interpret it as ${interpretingAs}, which may cause issues ahead.`,\n    ).message\n  }\n\n  private deserializeNumber(key: string, value: string) {\n    const deserialized = parseFloat(value)\n    // eslint-disable-next-line no-console\n    if (isNaN(deserialized)) console.error(this.paramTypeError(key, value, 'number', this.currentRoute?.$key ?? 'unknown', 'NaN'))\n    return deserialized\n  }\n\n  private deserializeBoolean(key: string, value: string) {\n    if (value === 'true' || value === '') return true\n    if (value === 'false') return false\n    // eslint-disable-next-line no-console\n    console.error(this.paramTypeError(key, value, 'boolean', this.currentRoute?.$key ?? 'unknown', 'true'))\n    return true\n  }\n\n  private deserializeParameter(key: string, values: string[]): any {\n    const value = values[0]\n    if (!this.currentRoute) return value\n    const type = this.currentRoute.$paramMetadata[key]\n    switch (type) {\n      case 'string': return value\n      case 'number': return this.deserializeNumber(key, value)\n      case 'boolean': return this.deserializeBoolean(key, value)\n      case 'string[]': return values\n      case 'number[]': return values.map(v => this.deserializeNumber(key, v))\n      case 'boolean[]': return values.map(v => this.deserializeBoolean(key, v))\n      case 'object':\n        try {\n          return JSON.parse(value)\n        } catch {\n          // eslint-disable-next-line no-console\n          console.error(this.paramTypeError(key, value, type, this.currentRoute.$key))\n          return value\n        }\n    }\n  }\n\n  private extractQueryParams(url: URL) {\n    const params = this.useHash ? new URLSearchParams(url.hash.replace(/[^?]*\\??/, '')) : url.searchParams\n    const result: Record<string, any> = {}\n    params.forEach((_, name) => {\n      if (name in result) return\n      result[name] = this.deserializeParameter(name, params.getAll(name))\n    })\n    return result\n  }\n\n  private extractUrlParams(url: URL) {\n    const result: Record<string, any> = {}\n    const routeParts = splitPath(this.currentRoute?.$path)\n    const urlParts = splitPath(this.getPath(url))\n    const paramMetadata = this.currentRoute?.$paramMetadata ?? {}\n    routeParts.forEach((value, index) => {\n      const [, key] = value.match(/\\{(\\w+)\\}/) ?? []\n      const paramStringValue = decodeURIComponent(urlParts[index])\n      /* if the parameter is supposed to be an array, get all of its values by splitting the string by \"-\" (considering \"\\\" as a escape\n      character). */\n      const paramArrayValue = paramMetadata[key]?.endsWith('[]')\n        ? paramStringValue.split(/(?<!\\\\)-/).map(item => item.replace(/\\\\-/g, '-'))\n        : [paramStringValue]\n      if (key) result[key] = this.deserializeParameter(key, paramArrayValue)\n    })\n    return result\n  }\n\n  private addRouteChangeListener(listener: AsyncRouteChangeListener, isAsync: boolean): () => void {\n    const list = isAsync ? this.asyncRouteChangeListeners : this.routeChangeListeners\n    list.push(listener)\n    if (this.currentRoute) listener(this.currentRoute, this.currentParams)\n    return () => {\n      removeElementFromArray(list, listener)\n    }\n  }\n\n  /**\n   * Adds a listener for changes to the route.\n   * \n   * If you need a listener that runs asynchronously, consider using `onRouteChangeAsync`.\n   * @param listener a function called when the route changes.\n   * @returns a function that, when called, removes the listener.\n   */\n  onRouteChange(listener: RouteChangeListener): () => void {\n    return this.addRouteChangeListener(listener, false)\n  }\n\n  /**\n   * Adds a listener for changes to the route. This listener can be async (return a promise).\n   * \n   * Asynchronous listeners are run before every synchronous listener. Synchronous listeners are only run once all async listeners finish\n   * running.\n   * @param listener a function called when the route changes.\n   * @returns a function that, when called, removes the listener.\n   */\n  onRouteChangeAsync(listener: AsyncRouteChangeListener): () => void {\n    return this.addRouteChangeListener(listener, true)\n  }\n\n  /**\n   * Adds a listener that runs when a navigation is performed to a route that doesn't exist.\n   * \n   * @param listener a function called when the route is not found.\n   * @returns a function that, when called, removes the listener.\n   */\n  onNotFound(listener: NotFoundListener): () => void {\n    this.notFoundListeners.push(listener)\n    return () => {\n      removeElementFromArray(this.notFoundListeners, listener)\n    }\n  }\n}\n", "import { useMemo } from 'react'\nimport { CitronNavigator } from './CitronNavigator'\nimport { AnyRoute, Route } from './Route'\nimport { RequiredKeysOf } from './types'\n\ntype RouteProps<T extends AnyRoute | undefined> = { to?: T } & (T extends Route<any, infer Params, any>\n  ? Params extends void\n    ? unknown\n    : RequiredKeysOf<Params> extends never ? { params?: Params } : { params: Params }\n  : unknown)\n\ntype Props<T extends AnyRoute | undefined> = React.AnchorHTMLAttributes<HTMLAnchorElement> & RouteProps<T>\n\ninterface LinkFn {\n  <T extends AnyRoute | undefined>(props: Props<T>): React.ReactElement,\n}\n\nexport const Link: LinkFn = (props) => {\n  const { to, params, href, children, target, onClick, onKeyDown, ...anchorProps } = props as Props<Route<any, object, any>>\n  const { actualHref, shouldActLikeSimpleAnchor } = useMemo(() => {\n    const actualHref = to ? to.$link(params) : href\n    const isHashUrl = actualHref && /^\\/?#/.test(actualHref)\n    const isAbsoluteUrl = actualHref && /^\\w+:\\/\\//.test(actualHref)\n    const shouldActLikeSimpleAnchor = !actualHref || isHashUrl || (target && target != '_self') || isAbsoluteUrl\n    return { actualHref, shouldActLikeSimpleAnchor }\n  }, [to?.$key, href, params])\n\n  if (shouldActLikeSimpleAnchor) {\n    return <a href={actualHref} target={target} onClick={onClick} onKeyDown={onKeyDown} {...anchorProps}>{children}</a>\n  }\n\n  function navigate(event: React.UIEvent) {\n    event.preventDefault()\n    history.pushState(null, '', actualHref)\n    // since we called event.preventDefault(), we now must manually trigger a navigation update\n    CitronNavigator.instance?.updateRoute?.()\n  }\n\n  function handleNavigationClick(event: React.MouseEvent<HTMLAnchorElement, MouseEvent>) {\n    navigate(event)\n    onClick?.(event)\n  }\n\n  function handleNavigationKeyDown(event: React.KeyboardEvent<HTMLAnchorElement>) {\n    if (event.key === 'Enter') navigate(event)\n    onKeyDown?.(event)\n  }\n  \n  return (\n    <a href={actualHref} target={target} onClick={handleNavigationClick} onKeyDown={handleNavigationKeyDown} {...anchorProps}>\n      {children}\n    </a>\n  )\n}\n", "import { FunctionComponent, ReactNode, useCallback, useState } from 'react'\n\ninterface AsyncViewConfig {\n  /**\n   * A component to render when the view can't be loaded (error).\n   * \n   * This component receives the prop \"refresh\" which is a function that refreshes the app when called.\n   */\n  ErrorComponent?: FunctionComponent<{ refresh: () => void }>,\n  /**\n   * Whether or not to automatically refresh the view with cache disabled when an error occurs.\n   * \n   * If another error happens after refreshing, the `errorComponent` is rendered, it doesn't refresh again.\n   */\n  shouldRefreshOnError?: boolean,\n  /**\n   * The initial value for `content`.\n   */\n  initial?: ReactNode,\n} \n\n// used to force the app to retrieve the latest version of index.html.\nconst refreshAppParam = 'update-app'\n\nfunction isAppRefreshed() {\n  return !!location.href.match(`[?&]${refreshAppParam}=\\\\d+`)\n}\n\nfunction refreshApp() {\n  const now = new Date().getTime()\n  const newUrl = isAppRefreshed()\n    ? location.href.replace(new RegExp(`([?&]${refreshAppParam}=)\\\\d+`), `$1${now}`)\n    : location.href.replace(/(\\?.*)?$/, `$1${location.href.includes('?') ? '&' : '?'}${refreshAppParam}=${now}`)\n  history.replaceState(null, '', newUrl)\n  location.reload()\n}\n\n/**\n * A hook for helping loading views asynchronously.\n * \n * Example:\n * ```tsx\n * const PageRenderer = () => {\n *   const { load, content } = useAsyncView({ ErrorComponent: UnderMaintenance })\n *   useNavigationContext((context) => {\n *     context.when('root', props => load(() => import('./Home'), 'Home', props))\n *   })\n *   return content\n * }\n * ```\n * @param options the options for loading async views. \n * @returns the values and functions for manipulating the current view (content).\n */\nexport function useAsyncView({ ErrorComponent, shouldRefreshOnError = true, initial }: AsyncViewConfig = {}) {\n  const [content, setContent] = useState<ReactNode>(initial)\n  const load = useCallback(async<\n    Props extends object,\n    Import extends Record<string, React.FunctionComponent<Props>>,\n    Key extends keyof Import,\n  >(loader: () => Promise<Import>, key: Key, props: Props) => {\n    try {\n      const View: React.FunctionComponent<Props> = (await loader())[key]\n      setContent(<View {...props} />)\n    } catch (error) {\n      if (!shouldRefreshOnError || isAppRefreshed()) {\n        // eslint-disable-next-line no-console\n        console.error(error)\n        setContent(ErrorComponent ? <ErrorComponent refresh={refreshApp} /> : <p>Error while loading the view.</p>)\n        return\n      }\n      // eslint-disable-next-line no-console\n      console.warn('Error while loading page. This is probably because a new version of the site is available. Refreshing...')\n      refreshApp()\n    }\n  }, [])\n\n  return { load, content, setContent }\n}\n", "import { useEffect, useState } from 'react'\nimport { CitronNavigator } from './CitronNavigator'\nimport { AnyRoute } from './Route'\n\ninterface NavigationItem {\n  key: string,\n  href: string,\n  label: string,\n}\n\nfunction routeKeyToLabel(key: string) {\n  const keyParts = key.split('.')\n  const lastKeyPart = keyParts[keyParts.length - 1]\n  // transforms uppercase letters into spaces + lowercase and capitalizes the first letter.\n  return lastKeyPart.replace(/([A-Z])/g, m => ` ${m.toLowerCase()}`).replace(/^[a-z]/, m => m.toUpperCase())\n}\n\n/**\n * Returns the navigation list for the current route. This is useful for building breadcrumb-like user interfaces.\n * \n * The return value is a list where each item contains: key (unique id), label (name) and href (url).\n * \n * @param labelFactory optional. A function to create a label for a route. If not provided, every route will have the last part of\n * its key capitalized as its label. If the label factory returns undefined, the default rule for building labels is used. If it returns\n * null, the route is removed from the list.\n * @param shouldMergeSearchParams optional. A function that takes a route key and returns a boolean indicating whether the search\n * parameters (query string) from the current location should be merged into the route's URL. If the function returns `true`, the \n * search parameters will be merged into the `href` of the route. If it returns `false` or is not provided, the search parameters \n * will not be merged.\n * @returns the navigation list.\n */\nexport function useNavigationList(\n  labelFactory?: (key: string, params: Record<string, any>) => string | undefined | null,\n  shouldMergeSearchParams?: (key: string) => boolean\n): NavigationItem[] {\n  const [data, setData] = useState<{ route?: AnyRoute, params?: Record<string, any> }>({\n    route: CitronNavigator.instance?.currentRoute,\n    params: CitronNavigator.instance?.currentParams,\n  })\n\n  useEffect(() => CitronNavigator.instance?.onRouteChange((route, params) => setData({ route, params })), [])\n\n  if (!data.route) return []\n  const branch = data.route.$getBranch()\n  return branch.reduce(\n    (result, route) => {\n      let label = labelFactory ? labelFactory(route.$key, data.params ?? {}) : routeKeyToLabel(route.$key)\n      if (label === undefined) label = routeKeyToLabel(route.$key)\n      return label === null\n        ? result\n        : [\n          ...result,\n          {\n            key: route.$key,\n            href: route.$link({}, { mergeSearchParameters: shouldMergeSearchParams?.(route.$key) }),\n            label\n          },\n        ]\n    },\n    [] as NavigationItem[],\n  )\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;AAkDM,IAAgB,QAAhB,MAAqB;EAyBzB,YAAY,KAAa,MAAc,QAAgB,eAAwC;AAd/F,WAAA,eAAA,MAAA,QAAA;;;;;;AAIA,WAAA,eAAA,MAAA,SAAA;;;;;;AAIA,WAAA,eAAA,MAAA,WAAA;;;;;;AAIA,WAAA,eAAA,MAAA,kBAAA;;;;;;AAGE,SAAK,OAAO;AACZ,SAAK,QAAQ;AACb,SAAK,UAAU;AACf,SAAK,iBAAiB;EACxB;;;;;;;;;;;;;;EAeA,IAAI,QAAuE,SAAmB;AA/FhG;AAgGI,UAAM,WAAU,mCAAS,YAAW,KAAK,UAAS;AAClD,UAAM,YAAY,UAAU,iBAAiB;AAC7C,YAAQ,SAAS,EAAE,CAAA,GAAI,IAAI,KAAK,MAAM,QAAQ,EAAE,wBAAuB,mCAAS,0BAAyB,KAAI,CAAE,CAAC;AAChH,QAAI,EAAC,mCAAS;AAAgB,4BAAgB,aAAhB,mBAA0B;EAC1D;EAEQ,eAAe,cAA+B,KAAa,OAAU;AAC3E,QAAI,UAAU,UAAa,UAAU,QAAQ,UAAU;AAAI;AAC3D,UAAM,OAAO,KAAK,eAAe,GAAG;AACpC,QAAI,KAAK,SAAS,IAAI,KAAK,MAAM,QAAQ,KAAK;AAAG,aAAO,MAAM,QAAQ,OAAK,aAAa,OAAO,KAAK,CAAC,CAAC;AACtG,iBAAa,IAAI,KAAK,SAAS,WAAW,KAAK,UAAU,KAAK,IAAI,KAAK;EACzE;;;;;;;;;;EAWA,MAAM,QAAuE,SAAqB;AAtHpG;AAuHI,UAAM,aAAkC,EAAE,IAAG,qBAAgB,aAAhB,mBAA0B,eAAe,GAAG,OAAM;AAC/F,UAAM,YAAsB,CAAA;AAC5B,UAAM,OAAO,KAAK,MAAM,QAAQ,SAAS,EAAE,EAAE,QAAQ,cAAc,CAAC,GAAG,UAAS;AAC9E,gBAAU,KAAK,KAAK;AACpB,YAAM,OAAO,KAAK,eAAe,KAAK;AACtC,YAAM,QAAQ,WAAW,KAAK;AAC9B,UAAI,aAAa,GAAG,KAAK;AACzB,UAAI,KAAK,SAAS,IAAI,KAAK,MAAM,QAAQ,KAAK,GAAG;AAC/C,qBAAa,MAAM,IAAI,UAAQ,OAAO,SAAS,WAAW,KAAK,QAAQ,MAAM,KAAK,IAAI,IAAI,EAAE,KAAK,GAAG;MACtG,WACS,SAAS;AAAU,qBAAa,KAAK,UAAU,KAAK;AAC7D,aAAO,mBAAmB,UAAU;IACtC,CAAC;AACD,UAAM,MAAM,IAAI,MAAI,qBAAgB,aAAhB,mBAA0B,WAAU,SAAS,WAAW,MAAM,SAAS,MAAM;AACjG,SAAI,qBAAgB,aAAhB,mBAA0B;AAAS,UAAI,OAAO,IAAI,IAAI;AAC1D,UAAM,oBAAmB,mCAAS,yBAAwB,aAAa,WAAW,CAAA;AAClF,WAAO,KAAK,KAAK,cAAc,EAAE,QAC/B,SAAO,CAAC,UAAU,SAAS,GAAG,KAAK,KAAK,eAAe,IAAI,cAAc,KAAK,gBAAgB,GAAG,CAAC,CAAC;AAErG,WAAO,GAAG,IAAI,QAAQ,GAAG,IAAI,IAAI,GAAG,IAAI,MAAM;EAChD;;;;;;EAOA,IAAI,KAAa;AACf,WAAO,KAAK,SAAS;EACvB;;;;;;EAOA,QAAQ,OAAe;AACrB,WAAO,KAAK,SAAS,MAAM;EAC7B;;;;;;;;;EAUA,kBAAkB,KAAa;AAC7B,WAAO,KAAK,SAAS,OAAO,IAAI,WAAW,GAAG,KAAK,IAAI,GAAG;EAC5D;;;;;;;EAQA,cAAc,KAAa;AACzB,WAAO,KAAK,SAAS,OAAO,KAAK,KAAK,WAAW,GAAG,GAAG,GAAG;EAC5D;;;;;;;;;;;;;EAcA,OAAO,MAAY;AACjB,UAAM,gBAAgB,UAAU,IAAI;AACpC,UAAM,gBAAgB,UAAU,KAAK,MAAM,QAAQ,SAAS,EAAE,CAAC;AAC/D,UAAM,MAAM,KAAK,IAAI,cAAc,QAAQ,cAAc,MAAM;AAC/D,aAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,YAAM,aAAa,CAAC,CAAC,cAAc,CAAC,EAAE,MAAM,SAAS;AACrD,UAAI,CAAC,cAAc,cAAc,CAAC,MAAM,cAAc,CAAC;AAAG,eAAO;IACnE;AACA,UAAM,aAAa,KAAK,MAAM,SAAS,IAAI;AAC3C,QAAI,CAAC,cAAc,cAAc,SAAS,cAAc;AAAQ,aAAO;AACvE,QAAI,cAAc,SAAS,cAAc;AAAQ,aAAO;AACxD,WAAO;EACT;;;;;EAMA,YAAS;AAnNX;AAoNI,UAAM,QAAO,qBAAgB,aAAhB,mBAA0B;AACvC,WAAO,SAAS,UAAa,KAAK,OAAO,IAAI,MAAM;EACrD;;;;;EAMA,oBAAiB;AA5NnB;AA6NI,UAAM,QAAO,qBAAgB,aAAhB,mBAA0B;AACvC,QAAI,CAAC;AAAM,aAAO;AAClB,UAAM,QAAQ,KAAK,OAAO,IAAI;AAC9B,WAAO,SAAS,WAAc,UAAU,cAAc,UAAU;EAClE;;;;;EAMA,aAAU;AACR,UAAM,SAAqB,CAAC,IAAI;AAChC,WAAO,OAAO,OAAO,SAAS,CAAC,EAAE,SAAS;AACxC,aAAO,KAAK,OAAO,OAAO,SAAS,CAAC,EAAE,OAAO;IAC/C;AACA,WAAO,OAAO,QAAO;EACvB;;;;AC7OI,IAAO,kBAAP,cAA+B,MAAK;EACxC,YAAY,SAAe;AACzB,UAAM,qBAAqB,OAAO,EAAE;EACtC;;AAGI,IAAO,uBAAP,cAAoC,MAAK;EAC7C,YAAY,SAAe;AACzB,UAAM,2BAA2B,OAAO,EAAE;EAC5C;;;;ACOI,IAAO,kBAAP,MAAO,iBAAe;EAU1B,YAAoB,MAAgB,UAAU,MAAI;AAT1C,WAAA,eAAA,MAAA,QAAA;;;;;;AACA,WAAA,eAAA,MAAA,qBAAA;;;;aAAwC,CAAA;;AACxC,WAAA,eAAA,MAAA,wBAAA;;;;aAA8C,CAAA;;AAC9C,WAAA,eAAA,MAAA,6BAAA;;;;aAAwD,CAAA;;AAChE,WAAA,eAAA,MAAA,gBAAA;;;;;;AACA,WAAA,eAAA,MAAA,iBAAA;;;;aAAqC,CAAA;;AACrC,WAAA,eAAA,MAAA,WAAA;;;;;;AAIE,SAAK,OAAO;AACZ,SAAK,UAAU;AACf,WAAO,iBAAiB,YAAY,MAAM,KAAK,YAAW,CAAE;AAC5D,SAAK,YAAW;EAClB;;;;;;;EAQA,OAAO,OAAO,MAAgB,UAAU,MAAI;AAE1C,qBAAgB,aAAhB,iBAAgB,WAAa,IAAI,iBAAgB,MAAM,OAAO;AAC9D,WAAO,iBAAgB;EACzB;;;;;;;;;EAUQ,KAAK,QAAkB,QAAgB;AAC7C,WAAO,KAAK,MAAM,EAAE,QAAQ,CAAC,QAAO;AAClC,YAAM,IAAI;AACV,UAAI,CAAC,EAAE,WAAW,GAAG,KAAK,OAAO,CAAC,aAAa,OAAO;AACpD,YAAI,EAAE,KAAK,SAAS;AAClB,iBAAO,CAAC,EAAE,UAAU;AACpB,iBAAO,CAAC,IAAI,OAAO,CAAC;QACtB,WAAW,OAAO,CAAC,EAAE,MAAM,SAAS,IAAI,GAAG;AACzC,eAAK,KAAK,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;QAChC;MACF;IACF,CAAC;EACH;;;;;;;;EASA,qBAAqB,OAA6B,cAAoB;AACpE,QAAI,WAAgB,KAAK;AACzB,UAAM,cAAc,aAAa,QAAQ,IAAI,OAAO,IAAI,KAAK,KAAK,IAAI,MAAM,GAAG,EAAE;AACjF,UAAM,WAAW,YAAY,MAAM,GAAG;AACtC,QAAI;AAAa,eAAS,QAAQ,SAAO,WAAW,qCAAW,IAAI;AACnE,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,qBACR,sEAAsE,YAAY,kCAAkC;IAExH;AACA,QAAI,aAAa,KAAK,MAAM;AAC1B,WAAK,OAAO;IACd,OAAO;AACL,YAAM,UAAU,SAAS;AACzB,eAAS,QAAQ,SAAS,SAAS,SAAS,CAAC,CAAC,IAAI;IACpD;AAEA,UAAM,WAAW,OAAO,KAAK,QAAQ,EAAE,OAAiB,CAAC,QAAQ,QAAO;AACtE,UAAI,IAAI,WAAW,GAAG;AAAG,eAAO;AAChC,YAAM,QAAQ,SAAS,GAA4B;AACnD,aAAO,EAAE,iBAAiB,UAAU,MAAM,MAAM,SAAS,IAAI,IAAI,SAAS,CAAC,GAAG,QAAQ,MAAM,KAAK;IACnG,GAAG,CAAA,CAAE;AACL,WAAO,KAAK,KAAK,EAAE,QAAQ,CAAC,QAAO;AACjC,YAAM,QAAQ,MAAM,GAAyB;AAC7C,UAAI,IAAI,WAAW,GAAG,KAAK,EAAE,iBAAiB;AAAQ;AACtD,UAAI,SAAS,SAAS,MAAM,KAAK,GAAG;AAClC,cAAM,IAAI,qBACR,+CAA+C,YAAY,YAAY,MAAM,KAAK,2EAA2E;MAEjK;AACA,UAAI,OAAO,YAAY,SAAS,GAAG,aAAa,SAAS,CAAC,SAAS,GAAG,EAAE,MAAM,SAAS,IAAI,GAAG;AAC5F,cAAM,IAAI,qBACR,2CAA2C,YAAY,0DAA0D;MAErH;IACF,CAAC;AAED,SAAK,KAAK,UAAU,KAAK;AACzB,SAAK,YAAW;EAClB;;;;;;;;;;;EAYA,QAAQ,MAAW,IAAI,IAAI,SAAS,SAAQ,CAAE,GAAC;AAC7C,WAAO,KAAK,UAAU,IAAI,KAAK,QAAQ,YAAY,EAAE,EAAE,QAAQ,QAAQ,EAAE,IAAI,IAAI,SAAS,QAAQ,OAAO,EAAE;EAC7G;;;;EAKA,MAAM,cAAW;AACf,UAAM,QAAQ,KAAK,gBAAgB,KAAK,MAAM,KAAK,QAAO,CAAE;AAC5D,QAAI;AAAO,YAAM,KAAK,kBAAkB,KAAK;;AACxC,WAAK,eAAc;EAC1B;EAEQ,WAAW,OAA0B;AAC3C,WAAO,OAAO,KAAK,KAAK,EAAE,OAAgB,CAAC,QAAQ,QAAO;AACxD,UAAI,CAAC,IAAI,WAAW,GAAG;AAAG,eAAO,KAAK,MAAM,GAAG,CAAC;AAChD,aAAO;IACT,GAAG,CAAA,CAAE;EACP;EAEQ,gBAAgB,OAAc,MAAc,WAAiB;AACnE,YAAQ,MAAM,OAAO,IAAI,GAAG;MAC1B,KAAK;AACH,eAAO,MAAM,MAAM,SAAS,GAAG,IAC3B,KAAK,WAAW,KAAK,EAAE,OACvB,CAAC,QAAQ,UAAU,UAAU,KAAK,gBAAgB,OAAO,MAAM,KAAK,GACpE,MAAS,KACN,QACH;MACN,KAAK;AACH,eAAO,KAAK,WAAW,KAAK,EAAE,OAC5B,CAAC,QAAQ,UAAU,UAAU,KAAK,gBAAgB,OAAO,MAAM,SAAS,GACxE,MAAS,MACL,MAAM,MAAM,SAAS,GAAG,IAAI,QAAQ;IAC9C;EACF;EAEQ,MAAM,kBAAkB,OAAY;AAC1C,SAAK,eAAe;AACpB,UAAM,MAAM,IAAI,IAAI,SAAS,SAAQ,CAAE;AACvC,SAAK,gBAAgB,EAAE,GAAG,KAAK,mBAAmB,GAAG,GAAG,GAAG,KAAK,iBAAiB,GAAG,EAAC;AACrF,UAAM,QAAQ,IAAI,KAAK,0BAA0B,IAAI,OAAK,EAAE,OAAO,KAAK,aAAa,CAAC,CAAC;AACvF,SAAK,qBAAqB,QAAQ,OAAK,EAAE,OAAO,KAAK,aAAa,CAAC;EACrE;EAEQ,iBAAc;AACpB,UAAM,OAAO,KAAK,QAAO;AAEzB,YAAQ,MAAM,IAAI,gBAAgB,yBAAyB,IAAI,GAAG,EAAE,OAAO;AAC3E,SAAK,kBAAkB,QAAQ,OAAK,EAAE,IAAI,CAAC;EAC7C;EAEQ,eAAe,KAAa,OAAe,MAAc,UAAkB,iBAAyB,gBAAc;AACxH,WAAO,IAAI,gBACT,wCAAwC,GAAG,eAAe,QAAQ,kBAAkB,KAAK,qBAAqB,IAAI,2CAA2C,cAAc,iCAAiC,EAC5M;EACJ;EAEQ,kBAAkB,KAAa,OAAa;AAvLtD;AAwLI,UAAM,eAAe,WAAW,KAAK;AAErC,QAAI,MAAM,YAAY;AAAG,cAAQ,MAAM,KAAK,eAAe,KAAK,OAAO,YAAU,UAAK,iBAAL,mBAAmB,SAAQ,WAAW,KAAK,CAAC;AAC7H,WAAO;EACT;EAEQ,mBAAmB,KAAa,OAAa;AA9LvD;AA+LI,QAAI,UAAU,UAAU,UAAU;AAAI,aAAO;AAC7C,QAAI,UAAU;AAAS,aAAO;AAE9B,YAAQ,MAAM,KAAK,eAAe,KAAK,OAAO,aAAW,UAAK,iBAAL,mBAAmB,SAAQ,WAAW,MAAM,CAAC;AACtG,WAAO;EACT;EAEQ,qBAAqB,KAAa,QAAgB;AACxD,UAAM,QAAQ,OAAO,CAAC;AACtB,QAAI,CAAC,KAAK;AAAc,aAAO;AAC/B,UAAM,OAAO,KAAK,aAAa,eAAe,GAAG;AACjD,YAAQ,MAAM;MACZ,KAAK;AAAU,eAAO;MACtB,KAAK;AAAU,eAAO,KAAK,kBAAkB,KAAK,KAAK;MACvD,KAAK;AAAW,eAAO,KAAK,mBAAmB,KAAK,KAAK;MACzD,KAAK;AAAY,eAAO;MACxB,KAAK;AAAY,eAAO,OAAO,IAAI,OAAK,KAAK,kBAAkB,KAAK,CAAC,CAAC;MACtE,KAAK;AAAa,eAAO,OAAO,IAAI,OAAK,KAAK,mBAAmB,KAAK,CAAC,CAAC;MACxE,KAAK;AACH,YAAI;AACF,iBAAO,KAAK,MAAM,KAAK;QACzB,QAAQ;AAEN,kBAAQ,MAAM,KAAK,eAAe,KAAK,OAAO,MAAM,KAAK,aAAa,IAAI,CAAC;AAC3E,iBAAO;QACT;IACJ;EACF;EAEQ,mBAAmB,KAAQ;AACjC,UAAM,SAAS,KAAK,UAAU,IAAI,gBAAgB,IAAI,KAAK,QAAQ,YAAY,EAAE,CAAC,IAAI,IAAI;AAC1F,UAAM,SAA8B,CAAA;AACpC,WAAO,QAAQ,CAAC,GAAG,SAAQ;AACzB,UAAI,QAAQ;AAAQ;AACpB,aAAO,IAAI,IAAI,KAAK,qBAAqB,MAAM,OAAO,OAAO,IAAI,CAAC;IACpE,CAAC;AACD,WAAO;EACT;EAEQ,iBAAiB,KAAQ;AAtOnC;AAuOI,UAAM,SAA8B,CAAA;AACpC,UAAM,aAAa,WAAU,UAAK,iBAAL,mBAAmB,KAAK;AACrD,UAAM,WAAW,UAAU,KAAK,QAAQ,GAAG,CAAC;AAC5C,UAAM,kBAAgB,UAAK,iBAAL,mBAAmB,mBAAkB,CAAA;AAC3D,eAAW,QAAQ,CAAC,OAAO,UAAS;AA3OxC,UAAAA;AA4OM,YAAM,CAAC,EAAE,GAAG,IAAI,MAAM,MAAM,WAAW,KAAK,CAAA;AAC5C,YAAM,mBAAmB,mBAAmB,SAAS,KAAK,CAAC;AAG3D,YAAM,oBAAkBA,MAAA,cAAc,GAAG,MAAjB,gBAAAA,IAAoB,SAAS,SACjD,iBAAiB,MAAM,WAAA,YAAU,GAAE,IAAI,UAAQ,KAAK,QAAQ,QAAQ,GAAG,CAAC,IACxE,CAAC,gBAAgB;AACrB,UAAI;AAAK,eAAO,GAAG,IAAI,KAAK,qBAAqB,KAAK,eAAe;IACvE,CAAC;AACD,WAAO;EACT;EAEQ,uBAAuB,UAAoC,SAAgB;AACjF,UAAM,OAAO,UAAU,KAAK,4BAA4B,KAAK;AAC7D,SAAK,KAAK,QAAQ;AAClB,QAAI,KAAK;AAAc,eAAS,KAAK,cAAc,KAAK,aAAa;AACrE,WAAO,MAAK;AACV,6BAAuB,MAAM,QAAQ;IACvC;EACF;;;;;;;;EASA,cAAc,UAA6B;AACzC,WAAO,KAAK,uBAAuB,UAAU,KAAK;EACpD;;;;;;;;;EAUA,mBAAmB,UAAkC;AACnD,WAAO,KAAK,uBAAuB,UAAU,IAAI;EACnD;;;;;;;EAQA,WAAW,UAA0B;AACnC,SAAK,kBAAkB,KAAK,QAAQ;AACpC,WAAO,MAAK;AACV,6BAAuB,KAAK,mBAAmB,QAAQ;IACzD;EACF;;;;;ACnSF,mBAAwB;AAiBjB,IAAM,OAAe,CAAC,UAAS;AACpC,QAAM,EAAE,IAAI,QAAQ,MAAM,UAAU,QAAQ,SAAS,WAAW,GAAG,YAAW,IAAK;AACnF,QAAM,EAAE,YAAY,0BAAyB,QAAK,sBAAQ,MAAK;AAC7D,UAAMC,cAAa,KAAK,GAAG,MAAM,MAAM,IAAI;AAC3C,UAAM,YAAYA,eAAc,QAAQ,KAAKA,WAAU;AACvD,UAAM,gBAAgBA,eAAc,YAAY,KAAKA,WAAU;AAC/D,UAAMC,6BAA4B,CAACD,eAAc,aAAc,UAAU,UAAU,WAAY;AAC/F,WAAO,EAAE,YAAAA,aAAY,2BAAAC,2BAAyB;EAChD,GAAG,CAAC,yBAAI,MAAM,MAAM,MAAM,CAAC;AAE3B,MAAI,2BAA2B;AAC7B,eAAO,mBAAAC,KAAA,KAAA,EAAG,MAAM,YAAY,QAAgB,SAAkB,WAAoB,GAAM,aAAW,SAAW,CAAA;EAChH;AAEA,WAAS,SAAS,OAAoB;;AACpC,UAAM,eAAc;AACpB,YAAQ,UAAU,MAAM,IAAI,UAAU;AAEtC,gCAAgB,aAAhB,mBAA0B,gBAA1B;EACF;AAEA,WAAS,sBAAsB,OAAsD;AACnF,aAAS,KAAK;AACd,uCAAU;EACZ;AAEA,WAAS,wBAAwB,OAA6C;AAC5E,QAAI,MAAM,QAAQ;AAAS,eAAS,KAAK;AACzC,2CAAY;EACd;AAEA,aACE,mBAAAA,KAAA,KAAA,EAAG,MAAM,YAAY,QAAgB,SAAS,uBAAuB,WAAW,yBAAuB,GAAM,aAAW,SAC7G,CAAA;AAGf;;;;ACrDA,IAAAC,gBAAoE;AAsBpE,IAAM,kBAAkB;AAExB,SAAS,iBAAc;AACrB,SAAO,CAAC,CAAC,SAAS,KAAK,MAAM,OAAO,eAAe,OAAO;AAC5D;AAEA,SAAS,aAAU;AACjB,QAAM,OAAM,oBAAI,KAAI,GAAG,QAAO;AAC9B,QAAM,SAAS,eAAc,IACzB,SAAS,KAAK,QAAQ,IAAI,OAAO,QAAQ,eAAe,QAAQ,GAAG,KAAK,GAAG,EAAE,IAC7E,SAAS,KAAK,QAAQ,YAAY,KAAK,SAAS,KAAK,SAAS,GAAG,IAAI,MAAM,GAAG,GAAG,eAAe,IAAI,GAAG,EAAE;AAC7G,UAAQ,aAAa,MAAM,IAAI,MAAM;AACrC,WAAS,OAAM;AACjB;AAkBM,SAAU,aAAa,EAAE,gBAAgB,uBAAuB,MAAM,QAAO,IAAsB,CAAA,GAAE;AACzG,QAAM,CAAC,SAAS,UAAU,QAAI,wBAAoB,OAAO;AACzD,QAAM,WAAO,2BAAY,OAIvB,QAA+B,KAAU,UAAgB;AACzD,QAAI;AACF,YAAM,QAAwC,MAAM,OAAM,GAAI,GAAG;AACjE,qBAAW,oBAAAC,KAAC,MAAI,EAAA,GAAK,MAAK,CAAA,CAAI;IAChC,SAAS,OAAO;AACd,UAAI,CAAC,wBAAwB,eAAc,GAAI;AAE7C,gBAAQ,MAAM,KAAK;AACnB,mBAAW,qBAAiB,oBAAAA,KAAC,gBAAc,EAAC,SAAS,WAAU,CAAA,QAAO,oBAAAA,KAAA,KAAA,EAAA,UAAA,gCAAA,CAAA,CAAoC;AAC1G;MACF;AAEA,cAAQ,KAAK,0GAA0G;AACvH,iBAAU;IACZ;EACF,GAAG,CAAA,CAAE;AAEL,SAAO,EAAE,MAAM,SAAS,WAAU;AACpC;;;AC7EA,IAAAC,gBAAoC;AAUpC,SAAS,gBAAgB,KAAW;AAClC,QAAM,WAAW,IAAI,MAAM,GAAG;AAC9B,QAAM,cAAc,SAAS,SAAS,SAAS,CAAC;AAEhD,SAAO,YAAY,QAAQ,YAAY,OAAK,IAAI,EAAE,YAAW,CAAE,EAAE,EAAE,QAAQ,UAAU,OAAK,EAAE,YAAW,CAAE;AAC3G;AAgBM,SAAU,kBACd,cACA,yBAAkD;AAjCpD;AAmCE,QAAM,CAAC,MAAM,OAAO,QAAI,wBAA6D;IACnF,QAAO,qBAAgB,aAAhB,mBAA0B;IACjC,SAAQ,qBAAgB,aAAhB,mBAA0B;GACnC;AAED,+BAAU,MAAG;AAxCf,QAAAC;AAwCkB,YAAAA,MAAA,gBAAgB,aAAhB,gBAAAA,IAA0B,cAAc,CAAC,OAAO,WAAW,QAAQ,EAAE,OAAO,OAAM,CAAE;KAAI,CAAA,CAAE;AAE1G,MAAI,CAAC,KAAK;AAAO,WAAO,CAAA;AACxB,QAAM,SAAS,KAAK,MAAM,WAAU;AACpC,SAAO,OAAO,OACZ,CAAC,QAAQ,UAAS;AAChB,QAAI,QAAQ,eAAe,aAAa,MAAM,MAAM,KAAK,UAAU,CAAA,CAAE,IAAI,gBAAgB,MAAM,IAAI;AACnG,QAAI,UAAU;AAAW,cAAQ,gBAAgB,MAAM,IAAI;AAC3D,WAAO,UAAU,OACb,SACA;MACA,GAAG;MACH;QACE,KAAK,MAAM;QACX,MAAM,MAAM,MAAM,CAAA,GAAI,EAAE,uBAAuB,mEAA0B,MAAM,MAAK,CAAE;QACtF;;;EAGR,GACA,CAAA,CAAsB;AAE1B;",
  "names": ["_a", "actualHref", "shouldActLikeSimpleAnchor", "_jsx", "import_react", "_jsx", "import_react", "_a"]
}
