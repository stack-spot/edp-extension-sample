import {
  removeElementFromArray,
  splitPath
} from "./chunk-WDK4I7EI.js";
import {
  require_jsx_runtime
} from "./chunk-3U5MBTNC.js";
import {
  require_react
} from "./chunk-HL4WHFNK.js";
import {
  __toESM
} from "./chunk-3O7X656O.js";

// ../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/dist/Route.js
var Route = class {
  constructor(key, path, parent, paramMetadata) {
    Object.defineProperty(this, "$key", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "$path", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "$parent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "$paramMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.$key = key;
    this.$path = path;
    this.$parent = parent;
    this.$paramMetadata = paramMetadata;
  }
  /**
   * Navigates to this route using the browser's history API. This can be either a page change or just a modification to a route parameter.
   *
   * To control whether to use history.pushState or history.replaceState, pass "replace" in the options parameter.
   *
   * By default, whenever the current route is the same as the route we're navigating to, `history.replaceState` is used. Otherwise,
   * `history.pushState` is.
   *
   * The parameters provided are merged with the parameters of the current URL. To avoid merging unwanted search parameters, pass the option
   * `mergeSearchParameters: false`.
   * @param params the parameters for the route.
   * @param options optional. The options for this navigation.
   */
  $go(params, options) {
    var _a;
    const replace = (options == null ? void 0 : options.replace) ?? this.$isActive();
    const operation = replace ? "replaceState" : "pushState";
    history[operation]({}, "", this.$link(params, { mergeSearchParameters: (options == null ? void 0 : options.mergeSearchParameters) ?? true }));
    if (!(options == null ? void 0 : options.preventDefault))
      (_a = CitronNavigator.instance) == null ? void 0 : _a.updateRoute();
  }
  setSearchParam(searchParams, key, value) {
    if (value === void 0 || value === null || value === "")
      return;
    const type = this.$paramMetadata[key];
    if (type.endsWith("[]") && Array.isArray(value))
      return value.forEach((v) => searchParams.append(key, v));
    searchParams.set(key, type === "object" ? JSON.stringify(value) : value);
  }
  /**
   * Creates a link (relative url) to this route.
   *
   * When creating a link, the provided search parameters are not merged with the current search parameters. To allow than to merge, pass
   * `mergeSearchParameters: true` in the options (2nd parameter).
   * @param params the parameters for the route.
   * @param options optional. The options for creating the link.
   * @returns the relative url to this route.
   */
  $link(params, options) {
    var _a, _b, _c;
    const parameters = { ...(_a = CitronNavigator.instance) == null ? void 0 : _a.currentParams, ...params };
    const urlParams = [];
    const path = this.$path.replace(/\/\*$/, "").replace(/\{(\w+)\}/g, (_, match) => {
      urlParams.push(match);
      const type = this.$paramMetadata[match];
      const value = parameters[match];
      let serialized = `${value}`;
      if (type.endsWith("[]") && Array.isArray(value)) {
        serialized = value.map((item) => typeof item === "string" ? item.replace(/-/g, "\\-") : item).join("-");
      } else if (type === "object")
        serialized = JSON.stringify(value);
      return encodeURIComponent(serialized);
    });
    const url = new URL(((_b = CitronNavigator.instance) == null ? void 0 : _b.useHash) ? location.pathname : path, location.origin);
    if ((_c = CitronNavigator.instance) == null ? void 0 : _c.useHash)
      url.hash = `#${path}`;
    const newSearchParams = ((options == null ? void 0 : options.mergeSearchParameters) ? parameters : params) ?? {};
    Object.keys(this.$paramMetadata).forEach((key) => !urlParams.includes(key) && this.setSearchParam(url.searchParams, key, newSearchParams[key]));
    return `${url.pathname}${url.hash}${url.search}`;
  }
  /**
   * Checks if the key passed as parameter corresponds to this route.
   * @param key the key to compare.
   * @returns true if the key is the same as this route's key. False otherwise.
   */
  $is(key) {
    return this.$key === key;
  }
  /**
   * Checks if the route passed as parameter is equivalent to the this route.
   * @param route the route to compare.
   * @returns true if it's  equivalent, false otherwise.
   */
  $equals(route) {
    return this.$key === route.$key;
  }
  /**
   * Checks if the key passed as parameter corresponds to this route or a sub-route of this route.
   *
   * Attention: this will only check the format of the key. It won't verify if the route actually exists.
   *
   * @param key the key to compare.
   * @returns true if the key is a sub-route (or equal). False otherwise.
   */
  $containsSubroute(key) {
    return this.$key === key || key.startsWith(`${this.$key}.`);
  }
  /**
   * Checks if this route corresponds to the key passed as parameter or any sub-route of the key.
   *
   * @param key the key to compare.
   * @returns true if this is a sub-route of the key (or equal). False otherwise.
   */
  $isSubrouteOf(key) {
    return this.$key === key || this.$key.startsWith(`${key}.`);
  }
  /**
   * Checks how the path passed as parameter matches this route.
   *
   * Attention: this won't verify if the path corresponds to an actual route. It will make a decision only based in the path's format.
   *
   * @param path the path to test this route against
   * @returns
   * - `no-match` if this route and the path passed as parameter are not related.
   * - `exact` if the path passed as parameter corresponds to this route; wildcards will always match as exact.
   * - `subroute` if the path passed as parameter corresponds to a sub-route (descendent) of this route.
   * - `super-route` if the path passed as parameter corresponds to a super-route (ascendent) of this route.
   */
  $match(path) {
    const thatPathParts = splitPath(path);
    const thisPathParts = splitPath(this.$path.replace(/\/\*$/, ""));
    const min = Math.min(thisPathParts.length, thatPathParts.length);
    for (let i = 0; i < min; i++) {
      const isUrlParam = !!thisPathParts[i].match(/\{\w+\}/);
      if (!isUrlParam && thatPathParts[i] !== thisPathParts[i])
        return "no-match";
    }
    const isWildcard = this.$path.endsWith("/*");
    if (!isWildcard && thisPathParts.length < thatPathParts.length)
      return "subroute";
    if (thisPathParts.length > thatPathParts.length)
      return "super-route";
    return "exact";
  }
  /**
   * Checks if this route is currently active.
   * @returns true if this route is the currently active, false otherwise.
   */
  $isActive() {
    var _a;
    const path = (_a = CitronNavigator.instance) == null ? void 0 : _a.getPath();
    return path !== void 0 && this.$match(path) === "exact";
  }
  /**
   * Checks if this route or any of its sub-route is currently active.
   * @returns true if this route or any of its sub-routes is the currently active, false otherwise.
   */
  $isSubrouteActive() {
    var _a;
    const path = (_a = CitronNavigator.instance) == null ? void 0 : _a.getPath();
    if (!path)
      return false;
    const match = this.$match(path);
    return path !== void 0 && (match === "subroute" || match === "exact");
  }
  /**
   * Returns the branch that starts at the root node and ends in this route.
   * @returns an array of routes where the first is the root node and the last is this route.
   */
  $getBranch() {
    const branch = [this];
    while (branch[branch.length - 1].$parent) {
      branch.push(branch[branch.length - 1].$parent);
    }
    return branch.reverse();
  }
};

// ../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/dist/errors.js
var NavigationError = class extends Error {
  constructor(message) {
    super(`Navigation error: ${message}`);
  }
};
var NavigationSetupError = class extends Error {
  constructor(message) {
    super(`Navigation setup error: ${message}`);
  }
};

// ../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/dist/CitronNavigator.js
var CitronNavigator = class _CitronNavigator {
  constructor(root, useHash = true) {
    Object.defineProperty(this, "root", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "notFoundListeners", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "routeChangeListeners", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "asyncRouteChangeListeners", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "currentRoute", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "currentParams", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "useHash", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.root = root;
    this.useHash = useHash;
    window.addEventListener("popstate", () => this.updateRoute());
    this.updateRoute();
  }
  /**
   * Creates a navigator if none has been created yet. Otherwise, returns the current navigator.
   * @param root the navigation tree.
   * @param useHash whether or not to use hash-based urls (domain/#/path). The default is true.
   * @returns the navigator
   */
  static create(root, useHash = true) {
    _CitronNavigator.instance ?? (_CitronNavigator.instance = new _CitronNavigator(root, useHash));
    return _CitronNavigator.instance;
  }
  /**
   * Copies every child route of `source` to `target` if the child route of `source` doesn't exist in `target`.
   *
   * If a child of `source` exists in `target`, but it's path includes a wildcard (/*), we recursively copy its children to the same route
   * in `target`.
   * @param source the route to have its children copied.
   * @param target the route to copy the children to.
   */
  copy(source, target) {
    Object.keys(source).forEach((key) => {
      const k = key;
      if (!k.startsWith("$") && source[k] instanceof Route) {
        if (!(k in target)) {
          source[k].$parent = target;
          target[k] = source[k];
        } else if (source[k].$path.endsWith("/*")) {
          this.copy(source[k], target[k]);
        }
      }
    });
  }
  /**
   * Updates the navigation tree by merging a node with another.
   *
   * This is used by modular navigation. A module can load more routes into the tree.
   * @param route the node to be merged into the tree.
   * @param keyToReplace the key of the node to be merged.
   */
  updateNavigationTree(route, keyToReplace) {
    let oldRoute = this.root;
    const reminderKey = keyToReplace.replace(new RegExp(`^${this.root.$key}\\.?`), "");
    const keyParts = reminderKey.split(".");
    if (reminderKey)
      keyParts.forEach((key) => oldRoute = oldRoute == null ? void 0 : oldRoute[key]);
    if (!oldRoute) {
      throw new NavigationSetupError(`Navigation error: cannot update navigation tree at route with key "${keyToReplace}" because the key doesn't exist.`);
    }
    if (oldRoute === this.root) {
      this.root = route;
    } else {
      route.$parent = oldRoute.$parent;
      oldRoute.$parent[keyParts[keyParts.length - 1]] = route;
    }
    const oldPaths = Object.keys(oldRoute).reduce((result, key) => {
      if (key.startsWith("$"))
        return result;
      const value = oldRoute[key];
      return !(value instanceof Route) || value.$path.endsWith("/*") ? result : [...result, value.$path];
    }, []);
    Object.keys(route).forEach((key) => {
      const value = route[key];
      if (key.startsWith("$") || !(value instanceof Route))
        return;
      if (oldPaths.includes(value.$path)) {
        throw new NavigationSetupError(`Error while merging modular route with key "${keyToReplace}". Path "${value.$path}" is already defined in parent. Only paths with wildcard can be replaced.`);
      }
      if (key in oldRoute && oldRoute[key] instanceof Route && !oldRoute[key].$path.endsWith("/*")) {
        throw new NavigationSetupError(`Error while merging modular route, key "${keyToReplace}" is already defined in parent with a non-wildcard path.`);
      }
    });
    this.copy(oldRoute, route);
    this.updateRoute();
  }
  /**
   * Gets the path of the provided url (considering hash-based paths).
   *
   * Examples:
   * - "https://www.stackspot.com/pt/ai-assistente" (useHash = false): "pt/ai-assistente".
   * - "https://www.stackspot.com/#/pt/ai-assistente" (useHash = true): "pt/ai-assistente".
   *
   * @param url the url to extract the path from. The current url (window.location) is used if none is provided.
   * @returns the path part of the url.
   */
  getPath(url = new URL(location.toString())) {
    return this.useHash ? url.hash.replace(/^\/?#\/?/, "").replace(/\?.*/, "") : url.pathname.replace(/^\//, "");
  }
  /**
   * Updates the current route according to the current URL.
   */
  async updateRoute() {
    const route = this.findRouteByPath(this.root, this.getPath());
    if (route)
      await this.handleRouteChange(route);
    else
      this.handleNotFound();
  }
  childrenOf(route) {
    return Object.keys(route).reduce((result, key) => {
      if (!key.startsWith("$"))
        result.push(route[key]);
      return result;
    }, []);
  }
  findRouteByPath(route, path, lastMatch) {
    switch (route.$match(path)) {
      case "exact":
        return route.$path.endsWith("*") ? this.childrenOf(route).reduce((result, child) => result ?? this.findRouteByPath(child, path, route), void 0) ?? route : route;
      case "subroute":
        return this.childrenOf(route).reduce((result, child) => result ?? this.findRouteByPath(child, path, lastMatch), void 0) ?? (route.$path.endsWith("*") ? route : lastMatch);
    }
  }
  async handleRouteChange(route) {
    this.currentRoute = route;
    const url = new URL(location.toString());
    this.currentParams = { ...this.extractQueryParams(url), ...this.extractUrlParams(url) };
    await Promise.all(this.asyncRouteChangeListeners.map((l) => l(route, this.currentParams)));
    this.routeChangeListeners.forEach((l) => l(route, this.currentParams));
  }
  handleNotFound() {
    const path = this.getPath();
    console.error(new NavigationError(`route not registered (${path})`).message);
    this.notFoundListeners.forEach((l) => l(path));
  }
  paramTypeError(key, value, type, routeKey, interpretingAs = "a raw string") {
    return new NavigationError(`error while deserializing parameter "${key}" of route "${routeKey}". The value ("${value}") is not a valid ${type}. Citron Navigator will interpret it as ${interpretingAs}, which may cause issues ahead.`).message;
  }
  deserializeNumber(key, value) {
    var _a;
    const deserialized = parseFloat(value);
    if (isNaN(deserialized))
      console.error(this.paramTypeError(key, value, "number", ((_a = this.currentRoute) == null ? void 0 : _a.$key) ?? "unknown", "NaN"));
    return deserialized;
  }
  deserializeBoolean(key, value) {
    var _a;
    if (value === "true" || value === "")
      return true;
    if (value === "false")
      return false;
    console.error(this.paramTypeError(key, value, "boolean", ((_a = this.currentRoute) == null ? void 0 : _a.$key) ?? "unknown", "true"));
    return true;
  }
  deserializeParameter(key, values) {
    const value = values[0];
    if (!this.currentRoute)
      return value;
    const type = this.currentRoute.$paramMetadata[key];
    switch (type) {
      case "string":
        return value;
      case "number":
        return this.deserializeNumber(key, value);
      case "boolean":
        return this.deserializeBoolean(key, value);
      case "string[]":
        return values;
      case "number[]":
        return values.map((v) => this.deserializeNumber(key, v));
      case "boolean[]":
        return values.map((v) => this.deserializeBoolean(key, v));
      case "object":
        try {
          return JSON.parse(value);
        } catch {
          console.error(this.paramTypeError(key, value, type, this.currentRoute.$key));
          return value;
        }
    }
  }
  extractQueryParams(url) {
    const params = this.useHash ? new URLSearchParams(url.hash.replace(/[^?]*\??/, "")) : url.searchParams;
    const result = {};
    params.forEach((_, name) => {
      if (name in result)
        return;
      result[name] = this.deserializeParameter(name, params.getAll(name));
    });
    return result;
  }
  extractUrlParams(url) {
    var _a, _b;
    const result = {};
    const routeParts = splitPath((_a = this.currentRoute) == null ? void 0 : _a.$path);
    const urlParts = splitPath(this.getPath(url));
    const paramMetadata = ((_b = this.currentRoute) == null ? void 0 : _b.$paramMetadata) ?? {};
    routeParts.forEach((value, index) => {
      var _a2;
      const [, key] = value.match(/\{(\w+)\}/) ?? [];
      const paramStringValue = decodeURIComponent(urlParts[index]);
      const paramArrayValue = ((_a2 = paramMetadata[key]) == null ? void 0 : _a2.endsWith("[]")) ? paramStringValue.split(new RegExp("(?<!\\\\)-")).map((item) => item.replace(/\\-/g, "-")) : [paramStringValue];
      if (key)
        result[key] = this.deserializeParameter(key, paramArrayValue);
    });
    return result;
  }
  addRouteChangeListener(listener, isAsync) {
    const list = isAsync ? this.asyncRouteChangeListeners : this.routeChangeListeners;
    list.push(listener);
    if (this.currentRoute)
      listener(this.currentRoute, this.currentParams);
    return () => {
      removeElementFromArray(list, listener);
    };
  }
  /**
   * Adds a listener for changes to the route.
   *
   * If you need a listener that runs asynchronously, consider using `onRouteChangeAsync`.
   * @param listener a function called when the route changes.
   * @returns a function that, when called, removes the listener.
   */
  onRouteChange(listener) {
    return this.addRouteChangeListener(listener, false);
  }
  /**
   * Adds a listener for changes to the route. This listener can be async (return a promise).
   *
   * Asynchronous listeners are run before every synchronous listener. Synchronous listeners are only run once all async listeners finish
   * running.
   * @param listener a function called when the route changes.
   * @returns a function that, when called, removes the listener.
   */
  onRouteChangeAsync(listener) {
    return this.addRouteChangeListener(listener, true);
  }
  /**
   * Adds a listener that runs when a navigation is performed to a route that doesn't exist.
   *
   * @param listener a function called when the route is not found.
   * @returns a function that, when called, removes the listener.
   */
  onNotFound(listener) {
    this.notFoundListeners.push(listener);
    return () => {
      removeElementFromArray(this.notFoundListeners, listener);
    };
  }
};

// ../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/dist/Link.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var Link = (props) => {
  const { to, params, href, children, target, onClick, onKeyDown, ...anchorProps } = props;
  const { actualHref, shouldActLikeSimpleAnchor } = (0, import_react.useMemo)(() => {
    const actualHref2 = to ? to.$link(params) : href;
    const isHashUrl = actualHref2 && /^\/?#/.test(actualHref2);
    const isAbsoluteUrl = actualHref2 && /^\w+:\/\//.test(actualHref2);
    const shouldActLikeSimpleAnchor2 = !actualHref2 || isHashUrl || target && target != "_self" || isAbsoluteUrl;
    return { actualHref: actualHref2, shouldActLikeSimpleAnchor: shouldActLikeSimpleAnchor2 };
  }, [to == null ? void 0 : to.$key, href, params]);
  if (shouldActLikeSimpleAnchor) {
    return (0, import_jsx_runtime.jsx)("a", { href: actualHref, target, onClick, onKeyDown, ...anchorProps, children });
  }
  function navigate(event) {
    var _a, _b;
    event.preventDefault();
    history.pushState(null, "", actualHref);
    (_b = (_a = CitronNavigator.instance) == null ? void 0 : _a.updateRoute) == null ? void 0 : _b.call(_a);
  }
  function handleNavigationClick(event) {
    navigate(event);
    onClick == null ? void 0 : onClick(event);
  }
  function handleNavigationKeyDown(event) {
    if (event.key === "Enter")
      navigate(event);
    onKeyDown == null ? void 0 : onKeyDown(event);
  }
  return (0, import_jsx_runtime.jsx)("a", { href: actualHref, target, onClick: handleNavigationClick, onKeyDown: handleNavigationKeyDown, ...anchorProps, children });
};

// ../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/dist/use-async-view.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
var refreshAppParam = "update-app";
function isAppRefreshed() {
  return !!location.href.match(`[?&]${refreshAppParam}=\\d+`);
}
function refreshApp() {
  const now = (/* @__PURE__ */ new Date()).getTime();
  const newUrl = isAppRefreshed() ? location.href.replace(new RegExp(`([?&]${refreshAppParam}=)\\d+`), `$1${now}`) : location.href.replace(/(\?.*)?$/, `$1${location.href.includes("?") ? "&" : "?"}${refreshAppParam}=${now}`);
  history.replaceState(null, "", newUrl);
  location.reload();
}
function useAsyncView({ ErrorComponent, shouldRefreshOnError = true, initial } = {}) {
  const [content, setContent] = (0, import_react2.useState)(initial);
  const load = (0, import_react2.useCallback)(async (loader, key, props) => {
    try {
      const View = (await loader())[key];
      setContent((0, import_jsx_runtime2.jsx)(View, { ...props }));
    } catch (error) {
      if (!shouldRefreshOnError || isAppRefreshed()) {
        console.error(error);
        setContent(ErrorComponent ? (0, import_jsx_runtime2.jsx)(ErrorComponent, { refresh: refreshApp }) : (0, import_jsx_runtime2.jsx)("p", { children: "Error while loading the view." }));
        return;
      }
      console.warn("Error while loading page. This is probably because a new version of the site is available. Refreshing...");
      refreshApp();
    }
  }, []);
  return { load, content, setContent };
}

// ../../node_modules/.pnpm/@stack-spot+citron-navigator@1.7.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@stack-spot/citron-navigator/dist/use-navigation-list.js
var import_react3 = __toESM(require_react(), 1);
function routeKeyToLabel(key) {
  const keyParts = key.split(".");
  const lastKeyPart = keyParts[keyParts.length - 1];
  return lastKeyPart.replace(/([A-Z])/g, (m) => ` ${m.toLowerCase()}`).replace(/^[a-z]/, (m) => m.toUpperCase());
}
function useNavigationList(labelFactory, shouldMergeSearchParams) {
  var _a, _b;
  const [data, setData] = (0, import_react3.useState)({
    route: (_a = CitronNavigator.instance) == null ? void 0 : _a.currentRoute,
    params: (_b = CitronNavigator.instance) == null ? void 0 : _b.currentParams
  });
  (0, import_react3.useEffect)(() => {
    var _a2;
    return (_a2 = CitronNavigator.instance) == null ? void 0 : _a2.onRouteChange((route, params) => setData({ route, params }));
  }, []);
  if (!data.route)
    return [];
  const branch = data.route.$getBranch();
  return branch.reduce((result, route) => {
    let label = labelFactory ? labelFactory(route.$key, data.params ?? {}) : routeKeyToLabel(route.$key);
    if (label === void 0)
      label = routeKeyToLabel(route.$key);
    return label === null ? result : [
      ...result,
      {
        key: route.$key,
        href: route.$link({}, { mergeSearchParameters: shouldMergeSearchParams == null ? void 0 : shouldMergeSearchParams(route.$key) }),
        label
      }
    ];
  }, []);
}
export {
  CitronNavigator,
  Link,
  NavigationError,
  NavigationSetupError,
  Route,
  useAsyncView,
  useNavigationList
};
//# sourceMappingURL=@stack-spot_citron-navigator.js.map
